

namespace std {
typedef long unsigned int size_t;
typedef long int ptrdiff_t;

typedef decltype(nullptr) nullptr_t;

#pragma GCC visibility push(default)

extern "C++" __attribute__((__noreturn__, __always_inline__)) inline void
__terminate() noexcept {
void terminate() noexcept __attribute__((__noreturn__));
terminate();
}
#pragma GCC visibility pop
} // namespace std
namespace std {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace std
namespace __gnu_cxx {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace __gnu_cxx
namespace std {
#pragma GCC visibility push(default)

constexpr inline bool __is_constant_evaluated() noexcept {

return __builtin_is_constant_evaluated();
}
#pragma GCC visibility pop
} // namespace std

namespace std __attribute__((__visibility__("default"))) {

void __throw_bad_exception(void) __attribute__((__noreturn__));

void __throw_bad_alloc(void) __attribute__((__noreturn__));

void __throw_bad_array_new_length(void) __attribute__((__noreturn__));

void __throw_bad_cast(void) __attribute__((__noreturn__));

void __throw_bad_typeid(void) __attribute__((__noreturn__));

void __throw_logic_error(const char *) __attribute__((__noreturn__));

void __throw_domain_error(const char *) __attribute__((__noreturn__));

void __throw_invalid_argument(const char *) __attribute__((__noreturn__));

void __throw_length_error(const char *) __attribute__((__noreturn__));

void __throw_out_of_range(const char *) __attribute__((__noreturn__));

void __throw_out_of_range_fmt(const char *, ...) __attribute__((__noreturn__))
__attribute__((__format__(__gnu_printf__, 1, 2)));

void __throw_runtime_error(const char *) __attribute__((__noreturn__));

void __throw_range_error(const char *) __attribute__((__noreturn__));

void __throw_overflow_error(const char *) __attribute__((__noreturn__));

void __throw_underflow_error(const char *) __attribute__((__noreturn__));

void __throw_ios_failure(const char *) __attribute__((__noreturn__));

void __throw_ios_failure(const char *, int) __attribute__((__noreturn__));

void __throw_system_error(int) __attribute__((__noreturn__));

void __throw_future_error(int) __attribute__((__noreturn__));

void __throw_bad_function_call() __attribute__((__noreturn__));

} // namespace std

extern "C++" {

namespace std __attribute__((__visibility__("default"))) {

struct __true_type {};
struct __false_type {};

template <bool> struct __truth_type {
typedef __false_type __type;
};

template <> struct __truth_type<true> {
typedef __true_type __type;
};

template <class _Sp, class _Tp> struct __traitor {
enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
typedef typename __truth_type<__value>::__type __type;
};

template <typename, typename> struct __are_same {
enum { __value = 0 };
typedef __false_type __type;
};

template <typename _Tp> struct __are_same<_Tp, _Tp> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Tp> struct __is_void {
enum { __value = 0 };
typedef __false_type __type;
};

template <> struct __is_void<void> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Tp> struct __is_integer {
enum { __value = 0 };
typedef __false_type __type;
};

template <> struct __is_integer<bool> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<signed char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<unsigned char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<wchar_t> {
enum { __value = 1 };
typedef __true_type __type;
};
template <> struct __is_integer<char16_t> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<char32_t> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<short> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<unsigned short> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<int> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<unsigned int> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<long> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<unsigned long> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<long long> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_integer<unsigned long long> {
enum { __value = 1 };
typedef __true_type __type;
};
__extension__ template <> struct __is_integer<__int128> {
enum { __value = 1 };
typedef __true_type __type;
};
__extension__ template <> struct __is_integer<unsigned __int128> {
enum { __value = 1 };
typedef __true_type __type;
};
template <typename _Tp> struct __is_floating {
enum { __value = 0 };
typedef __false_type __type;
};

template <> struct __is_floating<float> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_floating<double> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_floating<long double> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Tp> struct __is_pointer {
enum { __value = 0 };
typedef __false_type __type;
};

template <typename _Tp> struct __is_pointer<_Tp *> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Tp>
struct __is_arithmetic
: public __traitor<__is_integer<_Tp>, __is_floating<_Tp>>{};

template <typename _Tp>
struct __is_scalar
: public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>>{};

template <typename _Tp> struct __is_char {
enum { __value = 0 };
typedef __false_type __type;
};

template <> struct __is_char<char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_char<wchar_t> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Tp> struct __is_byte {
enum { __value = 0 };
typedef __false_type __type;
};

template <> struct __is_byte<char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_byte<signed char> {
enum { __value = 1 };
typedef __true_type __type;
};

template <> struct __is_byte<unsigned char> {
enum { __value = 1 };
typedef __true_type __type;
};

enum class byte : unsigned char;

template <> struct __is_byte<byte> {
enum { __value = 1 };
typedef __true_type __type;
};
template <typename> struct iterator_traits;

template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
enum { __value = __is_trivially_copyable(_Tp) };
};

template <typename _Tp>
struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
enum { __value = 0 };
};

template <typename _OutputIter, typename _InputIter> struct __memcpyable {
enum { __value = 0 };
};

template <typename _Tp>
struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
};

template <typename _Tp>
struct __memcpyable<_Tp *, const _Tp *>
: __is_nonvolatile_trivially_copyable<_Tp> {};

template <typename _Iter1, typename _Iter2> struct __memcmpable {
enum { __value = 0 };
};

template <typename _Tp>
struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
};

template <typename _Tp>
struct __memcmpable<const _Tp *, _Tp *>
: __is_nonvolatile_trivially_copyable<_Tp> {};

template <typename _Tp>
struct __memcmpable<_Tp *, const _Tp *>
: __is_nonvolatile_trivially_copyable<_Tp> {};

template <typename _Tp, bool _TreatAsBytes =

__is_byte<_Tp>::__value

>
struct __is_memcmp_ordered {
static const bool __value = _Tp(-1) > _Tp(1);
};

template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
static const bool __value = false;
};

template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
struct __is_memcmp_ordered_with {
static const bool __value =
__is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
};

template <typename _Tp, typename _Up>
struct __is_memcmp_ordered_with<_Tp, _Up, false> {
static const bool __value = false;
};
template <> struct __is_memcmp_ordered_with<std::byte, std::byte, true> {
static constexpr bool __value = true;
};

template <typename _Tp, bool _SameSize>
struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize> {
static constexpr bool __value = false;
};

template <typename _Up, bool _SameSize>
struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize> {
static constexpr bool __value = false;
};

template <typename _Tp> struct __is_move_iterator {
enum { __value = 0 };
typedef __false_type __type;
};

template <typename _Iterator>

inline _Iterator __miter_base(_Iterator __it) {
return __it;
}

} // namespace std
}

extern "C++" {

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

template <bool, typename> struct __enable_if {};

template <typename _Tp> struct __enable_if<true, _Tp> {
typedef _Tp __type;
};

template <bool _Cond, typename _Iftrue, typename _Iffalse>
struct __conditional_type {
typedef _Iftrue __type;
};

template <typename _Iftrue, typename _Iffalse>
struct __conditional_type<false, _Iftrue, _Iffalse> {
typedef _Iffalse __type;
};

template <typename _Tp> struct __add_unsigned {
private:
typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

public:
typedef typename __if_type::__type __type;
};

template <> struct __add_unsigned<char> {
typedef unsigned char __type;
};

template <> struct __add_unsigned<signed char> {
typedef unsigned char __type;
};

template <> struct __add_unsigned<short> {
typedef unsigned short __type;
};

template <> struct __add_unsigned<int> {
typedef unsigned int __type;
};

template <> struct __add_unsigned<long> {
typedef unsigned long __type;
};

template <> struct __add_unsigned<long long> {
typedef unsigned long long __type;
};

template <> struct __add_unsigned<bool>;

template <> struct __add_unsigned<wchar_t>;

template <typename _Tp> struct __remove_unsigned {
private:
typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

public:
typedef typename __if_type::__type __type;
};

template <> struct __remove_unsigned<char> {
typedef signed char __type;
};

template <> struct __remove_unsigned<unsigned char> {
typedef signed char __type;
};

template <> struct __remove_unsigned<unsigned short> {
typedef short __type;
};

template <> struct __remove_unsigned<unsigned int> {
typedef int __type;
};

template <> struct __remove_unsigned<unsigned long> {
typedef long __type;
};

template <> struct __remove_unsigned<unsigned long long> {
typedef long long __type;
};

template <> struct __remove_unsigned<bool>;

template <> struct __remove_unsigned<wchar_t>;

template <typename _Type>
constexpr inline bool __is_null_pointer(_Type * __ptr) {
return __ptr == 0;
}

template <typename _Type> constexpr inline bool __is_null_pointer(_Type) {
return false;
}

constexpr bool __is_null_pointer(std::nullptr_t) { return true; }

template <typename _Tp, bool = std::__is_integer<_Tp>::__value>
struct __promote {
typedef double __type;
};

template <typename _Tp> struct __promote<_Tp, false> {};

template <> struct __promote<long double> {
typedef long double __type;
};

template <> struct __promote<double> {
typedef double __type;
};

template <> struct __promote<float> {
typedef float __type;
};

template <typename... _Tp>
using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));

template <typename _Tp, typename _Up>
using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

template <typename _Tp, typename _Up, typename _Vp>
using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

template <typename _Tp, typename _Up, typename _Vp, typename _Wp>
using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;

} // namespace __gnu_cxx
}

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

template <typename _Tp>
struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
using std::__is_integer<_Tp>::__value;

enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
};

template <typename _Value> struct __numeric_traits_integer {

static_assert(__is_integer_nonstrict<_Value>::__value,
"invalid specialization");

static const bool __is_signed = (_Value)(-1) < 0;
static const int __digits =
__is_integer_nonstrict<_Value>::__width - __is_signed;

static const _Value __max =
__is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
: ~(_Value)0;
static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
};

template <typename _Value>
const _Value __numeric_traits_integer<_Value>::__min;

template <typename _Value>
const _Value __numeric_traits_integer<_Value>::__max;

template <typename _Value>
const bool __numeric_traits_integer<_Value>::__is_signed;

template <typename _Value>
const int __numeric_traits_integer<_Value>::__digits;
template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
template <typename _Value> struct __numeric_traits_floating {

static const int __max_digits10 =
(2 + (std::__are_same<_Value, float>::__value    ? 24
: std::__are_same<_Value, double>::__value ? 53
: 64) *
643L / 2136);

static const bool __is_signed = true;
static const int __digits10 =
(std::__are_same<_Value, float>::__value    ? 6
: std::__are_same<_Value, double>::__value ? 15
: 18);
static const int __max_exponent10 =
(std::__are_same<_Value, float>::__value    ? 38
: std::__are_same<_Value, double>::__value ? 308
: 4932);
};

template <typename _Value>
const int __numeric_traits_floating<_Value>::__max_digits10;

template <typename _Value>
const bool __numeric_traits_floating<_Value>::__is_signed;

template <typename _Value>
const int __numeric_traits_floating<_Value>::__digits10;

template <typename _Value>
const int __numeric_traits_floating<_Value>::__max_exponent10;

template <typename _Value>
struct __numeric_traits : public __numeric_traits_integer<_Value> {};

template <>
struct __numeric_traits<float> : public __numeric_traits_floating<float> {};

template <>
struct __numeric_traits<double> : public __numeric_traits_floating<double> {};

template <>
struct __numeric_traits<long double>
: public __numeric_traits_floating<long double> {};

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp> class reference_wrapper;
template <typename _Tp, _Tp __v> struct integral_constant {
static constexpr _Tp value = __v;
typedef _Tp value_type;
typedef integral_constant<_Tp, __v> type;
constexpr operator value_type() const noexcept { return value; }

constexpr value_type operator()() const noexcept { return value; }
};

using true_type = integral_constant<bool, true>;

using false_type = integral_constant<bool, false>;

template <bool __v> using __bool_constant = integral_constant<bool, __v>;

template <bool __v> using bool_constant = integral_constant<bool, __v>;

template <bool> struct __conditional {
template <typename _Tp, typename> using type = _Tp;
};

template <> struct __conditional<false> {
template <typename, typename _Up> using type = _Up;
};

template <bool _Cond, typename _If, typename _Else>
using __conditional_t =
typename __conditional<_Cond>::template type<_If, _Else>;

template <typename _Type> struct __type_identity {
using type = _Type;
};

template <typename _Tp>
using __type_identity_t = typename __type_identity<_Tp>::type;

template <typename...> struct __or_;

template <> struct __or_<> : public false_type {};

template <typename _B1> struct __or_<_B1> : public _B1 {};

template <typename _B1, typename _B2>
struct __or_<_B1, _B2> : public __conditional_t<_B1::value, _B1, _B2> {};

template <typename _B1, typename _B2, typename _B3, typename... _Bn>
struct __or_<_B1, _B2, _B3, _Bn...>
: public __conditional_t<_B1::value, _B1, __or_<_B2, _B3, _Bn...>> {};

template <typename...> struct __and_;

template <> struct __and_<> : public true_type {};

template <typename _B1> struct __and_<_B1> : public _B1 {};

template <typename _B1, typename _B2>
struct __and_<_B1, _B2> : public __conditional_t<_B1::value, _B2, _B1> {};

template <typename _B1, typename _B2, typename _B3, typename... _Bn>
struct __and_<_B1, _B2, _B3, _Bn...>
: public __conditional_t<_B1::value, __and_<_B2, _B3, _Bn...>, _B1> {};

template <typename _Pp>
struct __not_ : public __bool_constant<!bool(_Pp::value)> {};

template <typename... _Bn>
inline constexpr bool __or_v = __or_<_Bn...>::value;
template <typename... _Bn>
inline constexpr bool __and_v = __and_<_Bn...>::value;

template <typename... _Bn> struct conjunction : __and_<_Bn...> {};

template <typename... _Bn> struct disjunction : __or_<_Bn...> {};

template <typename _Pp> struct negation : __not_<_Pp> {};

template <typename... _Bn>
inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

template <typename... _Bn>
inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

template <typename _Pp>
inline constexpr bool negation_v = negation<_Pp>::value;

template <typename> struct is_reference;
template <typename> struct is_function;
template <typename> struct is_void;
template <typename> struct remove_cv;
template <typename> struct is_const;

template <typename> struct __is_array_unknown_bounds;

template <typename _Tp, size_t = sizeof(_Tp)>
constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
return {};
}

template <typename _TypeIdentity,
typename _NestedType = typename _TypeIdentity::type>
constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>,
is_void<_NestedType>,
__is_array_unknown_bounds<_NestedType>>::type
__is_complete_or_unbounded(_TypeIdentity) {
return {};
}

template <typename _Tp> struct __success_type {
typedef _Tp type;
};

struct __failure_type {};

template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;

template <typename> struct __is_void_helper : public false_type {};

template <> struct __is_void_helper<void> : public true_type {};

template <typename _Tp>
struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {};

template <typename> struct __is_integral_helper : public false_type {};

template <> struct __is_integral_helper<bool> : public true_type {};

template <> struct __is_integral_helper<char> : public true_type {};

template <> struct __is_integral_helper<signed char> : public true_type {};

template <> struct __is_integral_helper<unsigned char> : public true_type {};

template <> struct __is_integral_helper<wchar_t> : public true_type {};

template <> struct __is_integral_helper<char16_t> : public true_type {};

template <> struct __is_integral_helper<char32_t> : public true_type {};

template <> struct __is_integral_helper<short> : public true_type {};

template <> struct __is_integral_helper<unsigned short> : public true_type {};

template <> struct __is_integral_helper<int> : public true_type {};

template <> struct __is_integral_helper<unsigned int> : public true_type {};

template <> struct __is_integral_helper<long> : public true_type {};

template <> struct __is_integral_helper<unsigned long> : public true_type {};

template <> struct __is_integral_helper<long long> : public true_type {};

template <>
struct __is_integral_helper<unsigned long long> : public true_type {};

__extension__ template <>
struct __is_integral_helper<__int128> : public true_type {};

__extension__ template <>
struct __is_integral_helper<unsigned __int128> : public true_type {};
template <typename _Tp>
struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {};

template <typename> struct __is_floating_point_helper : public false_type {};

template <> struct __is_floating_point_helper<float> : public true_type {};

template <> struct __is_floating_point_helper<double> : public true_type {};

template <>
struct __is_floating_point_helper<long double> : public true_type {};

template <>
struct __is_floating_point_helper<__float128> : public true_type {};

template <typename _Tp>
struct is_floating_point
: public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {};

template <typename> struct is_array : public false_type {};

template <typename _Tp, std::size_t _Size>
struct is_array<_Tp[_Size]> : public true_type {};

template <typename _Tp> struct is_array<_Tp[]> : public true_type {};

template <typename> struct __is_pointer_helper : public false_type {};

template <typename _Tp>
struct __is_pointer_helper<_Tp *> : public true_type {};

template <typename _Tp>
struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename> struct is_lvalue_reference : public false_type {};

template <typename _Tp>
struct is_lvalue_reference<_Tp &> : public true_type {};

template <typename> struct is_rvalue_reference : public false_type {};

template <typename _Tp>
struct is_rvalue_reference<_Tp &&> : public true_type {};

template <typename>
struct __is_member_object_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_object_pointer_helper<_Tp _Cp::*>
: public __not_<is_function<_Tp>>::type {};

template <typename _Tp>
struct is_member_object_pointer
: public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename>
struct __is_member_function_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_function_pointer_helper<_Tp _Cp::*>
: public is_function<_Tp>::type {};

template <typename _Tp>
struct is_member_function_pointer
: public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};

template <typename _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};

template <typename _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};

template <typename _Tp>
struct is_function : public __bool_constant<!is_const<const _Tp>::value> {};

template <typename _Tp> struct is_function<_Tp &> : public false_type {};

template <typename _Tp> struct is_function<_Tp &&> : public false_type {};

template <typename> struct __is_null_pointer_helper : public false_type {};

template <>
struct __is_null_pointer_helper<std::nullptr_t> : public true_type {};

template <typename _Tp>
struct is_null_pointer
: public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename _Tp> struct __is_nullptr_t : public is_null_pointer<_Tp> {
} __attribute__((__deprecated__("use '"
"std::is_null_pointer"
"' instead")));

template <typename _Tp>
struct is_reference
: public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp>>::type {
};

template <typename _Tp>
struct is_arithmetic
: public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {};

template <typename _Tp>
struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
is_null_pointer<_Tp>>::type {};

template <typename _Tp>
struct is_object
: public __not_<
__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {};

template <typename> struct is_member_pointer;

template <typename _Tp>
struct is_scalar
: public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {};

template <typename _Tp>
struct is_compound : public __not_<is_fundamental<_Tp>>::type {};

template <typename _Tp>
struct __is_member_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_pointer_helper<_Tp _Cp::*> : public true_type {};

template <typename _Tp>
struct is_member_pointer
: public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename, typename> struct is_same;

template <typename _Tp, typename... _Types>
using __is_one_of = __or_<is_same<_Tp, _Types>...>;

__extension__ template <typename _Tp>
using __is_signed_integer =
__is_one_of<__remove_cv_t<_Tp>, signed char, signed short, signed int,
signed long, signed long long

,
signed __int128>;

__extension__ template <typename _Tp>
using __is_unsigned_integer =
__is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short,
unsigned int, unsigned long, unsigned long long

,
unsigned __int128>;

template <typename _Tp>
using __is_standard_integer =
__or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;

template <typename...> using __void_t = void;

template <typename _Tp, typename = void>
struct __is_referenceable : public false_type{};

template <typename _Tp>
struct __is_referenceable<_Tp, __void_t<_Tp &>> : public true_type{};

template <typename> struct is_const : public false_type {};

template <typename _Tp> struct is_const<_Tp const> : public true_type {};

template <typename> struct is_volatile : public false_type {};

template <typename _Tp>
struct is_volatile<_Tp volatile> : public true_type {};

template <typename _Tp>
struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_trivially_copyable
: public integral_constant<bool, __is_trivially_copyable(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_standard_layout
: public integral_constant<bool, __is_standard_layout(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct

is_pod : public integral_constant<bool, __is_pod(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct [[__deprecated__]] is_literal_type
: public integral_constant<bool, __is_literal_type(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};

template <typename _Tp>
struct is_polymorphic
: public integral_constant<bool, __is_polymorphic(_Tp)> {};

template <typename _Tp>
struct is_final : public integral_constant<bool, __is_final(_Tp)> {};

template <typename _Tp>
struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};

template <typename _Tp, bool = is_arithmetic<_Tp>::value>
struct __is_signed_helper : public false_type {};

template <typename _Tp>
struct __is_signed_helper<_Tp, true>
: public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <typename _Tp>
struct is_signed : public __is_signed_helper<_Tp>::type {};

template <typename _Tp>
struct is_unsigned
: public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {};

template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);

template <typename _Tp> _Tp __declval(long);

template <typename _Tp>
auto declval() noexcept -> decltype(__declval<_Tp>(0));

template <typename, unsigned = 0> struct extent;

template <typename> struct remove_all_extents;

template <typename _Tp>
struct __is_array_known_bounds
: public integral_constant<bool, (extent<_Tp>::value > 0)> {};

template <typename _Tp>
struct __is_array_unknown_bounds
: public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {};
struct __do_is_destructible_impl {
template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())>
static true_type __test(int);

template <typename> static false_type __test(...);
};

template <typename _Tp>
struct __is_destructible_impl : public __do_is_destructible_impl {
typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp,
bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
is_function<_Tp>>::value,
bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
struct __is_destructible_safe;

template <typename _Tp>
struct __is_destructible_safe<_Tp, false, false>
: public __is_destructible_impl<
typename remove_all_extents<_Tp>::type>::type {};

template <typename _Tp>
struct __is_destructible_safe<_Tp, true, false> : public false_type {};

template <typename _Tp>
struct __is_destructible_safe<_Tp, false, true> : public true_type {};

template <typename _Tp>
struct is_destructible : public __is_destructible_safe<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

struct __do_is_nt_destructible_impl {
template <typename _Tp>
static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);

template <typename> static false_type __test(...);
};

template <typename _Tp>
struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl {
typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp,
bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
is_function<_Tp>>::value,
bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
struct __is_nt_destructible_safe;

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, false, false>
: public __is_nt_destructible_impl<
typename remove_all_extents<_Tp>::type>::type {};

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, true, false> : public false_type {};

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, false, true> : public true_type {};

template <typename _Tp>
struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename... _Args>
struct __is_constructible_impl
: public __bool_constant<__is_constructible(_Tp, _Args...)> {};

template <typename _Tp, typename... _Args>
struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_default_constructible : public __is_constructible_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_copy_constructible_impl;

template <typename _Tp>
struct __is_copy_constructible_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_copy_constructible_impl<_Tp, true>
: public __is_constructible_impl<_Tp, const _Tp &> {};

template <typename _Tp>
struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_move_constructible_impl;

template <typename _Tp>
struct __is_move_constructible_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_move_constructible_impl<_Tp, true>
: public __is_constructible_impl<_Tp, _Tp &&> {};

template <typename _Tp>
struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename... _Args>
using __is_nothrow_constructible_impl =
__bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;

template <typename _Tp, typename... _Args>
struct is_nothrow_constructible
: public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_nothrow_default_constructible
: public __bool_constant<__is_nothrow_constructible(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_nothrow_copy_constructible_impl;

template <typename _Tp>
struct __is_nothrow_copy_constructible_impl<_Tp, false> : public false_type {
};

template <typename _Tp>
struct __is_nothrow_copy_constructible_impl<_Tp, true>
: public __is_nothrow_constructible_impl<_Tp, const _Tp &> {};

template <typename _Tp>
struct is_nothrow_copy_constructible
: public __is_nothrow_copy_constructible_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_nothrow_move_constructible_impl;

template <typename _Tp>
struct __is_nothrow_move_constructible_impl<_Tp, false> : public false_type {
};

template <typename _Tp>
struct __is_nothrow_move_constructible_impl<_Tp, true>
: public __is_nothrow_constructible_impl<_Tp, _Tp &&> {};

template <typename _Tp>
struct is_nothrow_move_constructible
: public __is_nothrow_move_constructible_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename _Up>
struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_copy_assignable_impl;

template <typename _Tp>
struct __is_copy_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_copy_assignable_impl<_Tp, true>
: public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {};

template <typename _Tp>
struct is_copy_assignable : public __is_copy_assignable_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_move_assignable_impl;

template <typename _Tp>
struct __is_move_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_move_assignable_impl<_Tp, true>
: public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {};

template <typename _Tp>
struct is_move_assignable : public __is_move_assignable_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename _Up>
using __is_nothrow_assignable_impl =
__bool_constant<__is_nothrow_assignable(_Tp, _Up)>;

template <typename _Tp, typename _Up>
struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_nt_copy_assignable_impl;

template <typename _Tp>
struct __is_nt_copy_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_nt_copy_assignable_impl<_Tp, true>
: public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {};

template <typename _Tp>
struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_nt_move_assignable_impl;

template <typename _Tp>
struct __is_nt_move_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_nt_move_assignable_impl<_Tp, true>
: public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {};

template <typename _Tp>
struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename... _Args>
struct is_trivially_constructible
: public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_trivially_default_constructible
: public __bool_constant<__is_trivially_constructible(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

struct __do_is_implicitly_default_constructible_impl {
template <typename _Tp> static void __helper(const _Tp &);

template <typename _Tp>
static true_type __test(const _Tp &,
decltype(__helper<const _Tp &>({})) * = 0);

static false_type __test(...);
};

template <typename _Tp>
struct __is_implicitly_default_constructible_impl
: public __do_is_implicitly_default_constructible_impl {
typedef decltype(__test(declval<_Tp>())) type;
};

template <typename _Tp>
struct __is_implicitly_default_constructible_safe
: public __is_implicitly_default_constructible_impl<_Tp>::type {};

template <typename _Tp>
struct __is_implicitly_default_constructible
: public __and_<__is_constructible_impl<_Tp>,
__is_implicitly_default_constructible_safe<_Tp>> {};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_trivially_copy_constructible_impl;

template <typename _Tp>
struct __is_trivially_copy_constructible_impl<_Tp, false>
: public false_type {};

template <typename _Tp>
struct __is_trivially_copy_constructible_impl<_Tp, true>
: public __and_<__is_copy_constructible_impl<_Tp>,
integral_constant<bool, __is_trivially_constructible(
_Tp, const _Tp &)>> {};

template <typename _Tp>
struct is_trivially_copy_constructible
: public __is_trivially_copy_constructible_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_trivially_move_constructible_impl;

template <typename _Tp>
struct __is_trivially_move_constructible_impl<_Tp, false>
: public false_type {};

template <typename _Tp>
struct __is_trivially_move_constructible_impl<_Tp, true>
: public __and_<__is_move_constructible_impl<_Tp>,
integral_constant<bool, __is_trivially_constructible(
_Tp, _Tp &&)>> {};

template <typename _Tp>
struct is_trivially_move_constructible
: public __is_trivially_move_constructible_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, typename _Up>
struct is_trivially_assignable
: public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_trivially_copy_assignable_impl;

template <typename _Tp>
struct __is_trivially_copy_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_trivially_copy_assignable_impl<_Tp, true>
: public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
};

template <typename _Tp>
struct is_trivially_copy_assignable
: public __is_trivially_copy_assignable_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __is_trivially_move_assignable_impl;

template <typename _Tp>
struct __is_trivially_move_assignable_impl<_Tp, false> : public false_type {};

template <typename _Tp>
struct __is_trivially_move_assignable_impl<_Tp, true>
: public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {};

template <typename _Tp>
struct is_trivially_move_assignable
: public __is_trivially_move_assignable_impl<_Tp> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_trivially_destructible
: public __and_<__is_destructible_safe<_Tp>,
__bool_constant<__has_trivial_destructor(_Tp)>> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct has_virtual_destructor
: public integral_constant<bool, __has_virtual_destructor(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename> struct rank : public integral_constant<std::size_t, 0> {};

template <typename _Tp, std::size_t _Size>
struct rank<_Tp[_Size]>
: public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

template <typename _Tp>
struct rank<_Tp[]>
: public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

template <typename, unsigned _Uint>
struct extent : public integral_constant<std::size_t, 0> {};

template <typename _Tp, unsigned _Uint, std::size_t _Size>
struct extent<_Tp[_Size], _Uint>
: public integral_constant<
std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {};

template <typename _Tp, unsigned _Uint>
struct extent<_Tp[], _Uint>
: public integral_constant<
std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {};

template <typename _Tp, typename _Up>
struct is_same

: public integral_constant<bool, __is_same(_Tp, _Up)>

{};
template <typename _Base, typename _Derived>
struct is_base_of
: public integral_constant<bool, __is_base_of(_Base, _Derived)> {};

template <typename _From, typename _To,
bool =
__or_<is_void<_From>, is_function<_To>, is_array<_To>>::value>
struct __is_convertible_helper {
typedef typename is_void<_To>::type type;
};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
template <typename _From, typename _To>
class __is_convertible_helper<_From, _To, false> {
template <typename _To1> static void __test_aux(_To1) noexcept;

template <typename _From1, typename _To1,
typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
static true_type __test(int);

template <typename, typename> static false_type __test(...);

public:
typedef decltype(__test<_From, _To>(0)) type;
};
#pragma GCC diagnostic pop

template <typename _From, typename _To>
struct is_convertible : public __is_convertible_helper<_From, _To>::type {};

template <typename _ToElementType, typename _FromElementType>
using __is_array_convertible =
is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

template <typename _From, typename _To,
bool =
__or_<is_void<_From>, is_function<_To>, is_array<_To>>::value>
struct __is_nt_convertible_helper : is_void<_To> {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
template <typename _From, typename _To>
class __is_nt_convertible_helper<_From, _To, false> {
template <typename _To1> static void __test_aux(_To1) noexcept;

template <typename _From1, typename _To1>
static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
__test(int);

template <typename, typename> static false_type __test(...);

public:
using type = decltype(__test<_From, _To>(0));
};
#pragma GCC diagnostic pop

template <typename _From, typename _To>
struct __is_nothrow_convertible
: public __is_nt_convertible_helper<_From, _To>::type {};
template <typename _Tp> struct remove_const {
typedef _Tp type;
};

template <typename _Tp> struct remove_const<_Tp const> {
typedef _Tp type;
};

template <typename _Tp> struct remove_volatile {
typedef _Tp type;
};

template <typename _Tp> struct remove_volatile<_Tp volatile> {
typedef _Tp type;
};

template <typename _Tp> struct remove_cv {
using type = _Tp;
};

template <typename _Tp> struct remove_cv<const _Tp> {
using type = _Tp;
};

template <typename _Tp> struct remove_cv<volatile _Tp> {
using type = _Tp;
};

template <typename _Tp> struct remove_cv<const volatile _Tp> {
using type = _Tp;
};

template <typename _Tp> struct add_const {
typedef _Tp const type;
};

template <typename _Tp> struct add_volatile {
typedef _Tp volatile type;
};

template <typename _Tp> struct add_cv {
typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
};

template <typename _Tp>
using remove_const_t = typename remove_const<_Tp>::type;

template <typename _Tp>
using remove_volatile_t = typename remove_volatile<_Tp>::type;

template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;

template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;

template <typename _Tp>
using add_volatile_t = typename add_volatile<_Tp>::type;

template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;

template <typename _Tp> struct remove_reference {
typedef _Tp type;
};

template <typename _Tp> struct remove_reference<_Tp &> {
typedef _Tp type;
};

template <typename _Tp> struct remove_reference<_Tp &&> {
typedef _Tp type;
};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_lvalue_reference_helper {
typedef _Tp type;
};

template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
typedef _Tp &type;
};

template <typename _Tp>
struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {};

template <typename _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_rvalue_reference_helper {
typedef _Tp type;
};

template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
typedef _Tp &&type;
};

template <typename _Tp>
struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {};

template <typename _Tp>
using remove_reference_t = typename remove_reference<_Tp>::type;

template <typename _Tp>
using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;

template <typename _Tp>
using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;

template <typename _Unqualified, bool _IsConst, bool _IsVol>
struct __cv_selector;

template <typename _Unqualified>
struct __cv_selector<_Unqualified, false, false> {
typedef _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, false, true> {
typedef volatile _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, true, false> {
typedef const _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, true, true> {
typedef const volatile _Unqualified __type;
};

template <typename _Qualified, typename _Unqualified,
bool _IsConst = is_const<_Qualified>::value,
bool _IsVol = is_volatile<_Qualified>::value>
class __match_cv_qualifiers {
typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

public:
typedef typename __match::__type __type;
};

template <typename _Tp> struct __make_unsigned { typedef _Tp __type; };

template <> struct __make_unsigned<char> { typedef unsigned char __type; };

template <> struct __make_unsigned<signed char> {
typedef unsigned char __type;
};

template <> struct __make_unsigned<short> { typedef unsigned short __type; };

template <> struct __make_unsigned<int> { typedef unsigned int __type; };

template <> struct __make_unsigned<long> { typedef unsigned long __type; };

template <> struct __make_unsigned<long long> {
typedef unsigned long long __type;
};

__extension__ template <> struct __make_unsigned<__int128> {
typedef unsigned __int128 __type;
};
template <typename _Tp, bool _IsInt = is_integral<_Tp>::value,
bool _IsEnum = is_enum<_Tp>::value>
class __make_unsigned_selector;

template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
using __unsigned_type =
typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

public:
using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
};

class __make_unsigned_selector_base {
protected:
template <typename...> struct _List {};

template <typename _Tp, typename... _Up>
struct _List<_Tp, _Up...> : _List<_Up...> {
static constexpr size_t __size = sizeof(_Tp);
};

template <size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
struct __select;

template <size_t _Sz, typename _Uint, typename... _UInts>
struct __select<_Sz, _List<_Uint, _UInts...>, true> {
using __type = _Uint;
};

template <size_t _Sz, typename _Uint, typename... _UInts>
struct __select<_Sz, _List<_Uint, _UInts...>, false>
: __select<_Sz, _List<_UInts...>> {};
};

template <typename _Tp>
class __make_unsigned_selector<_Tp, false, true>
: __make_unsigned_selector_base {

using _UInts = _List<unsigned char, unsigned short, unsigned int,
unsigned long, unsigned long long>;

using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

public:
using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
};

template <> struct __make_unsigned<wchar_t> {
using __type =
typename __make_unsigned_selector<wchar_t, false, true>::__type;
};
template <> struct __make_unsigned<char16_t> {
using __type =
typename __make_unsigned_selector<char16_t, false, true>::__type;
};

template <> struct __make_unsigned<char32_t> {
using __type =
typename __make_unsigned_selector<char32_t, false, true>::__type;
};

template <typename _Tp> struct make_unsigned {
typedef typename __make_unsigned_selector<_Tp>::__type type;
};

template <> struct make_unsigned<bool>;

template <typename _Tp> struct __make_signed { typedef _Tp __type; };

template <> struct __make_signed<char> { typedef signed char __type; };

template <> struct __make_signed<unsigned char> {
typedef signed char __type;
};

template <> struct __make_signed<unsigned short> {
typedef signed short __type;
};

template <> struct __make_signed<unsigned int> { typedef signed int __type; };

template <> struct __make_signed<unsigned long> {
typedef signed long __type;
};

template <> struct __make_signed<unsigned long long> {
typedef signed long long __type;
};

__extension__ template <> struct __make_signed<unsigned __int128> {
typedef __int128 __type;
};
template <typename _Tp, bool _IsInt = is_integral<_Tp>::value,
bool _IsEnum = is_enum<_Tp>::value>
class __make_signed_selector;

template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;

public:
using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
};

template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

public:
typedef typename __make_signed_selector<__unsigned_type>::__type __type;
};

template <> struct __make_signed<wchar_t> {
using __type =
typename __make_signed_selector<wchar_t, false, true>::__type;
};
template <> struct __make_signed<char16_t> {
using __type =
typename __make_signed_selector<char16_t, false, true>::__type;
};

template <> struct __make_signed<char32_t> {
using __type =
typename __make_signed_selector<char32_t, false, true>::__type;
};

template <typename _Tp> struct make_signed {
typedef typename __make_signed_selector<_Tp>::__type type;
};

template <> struct make_signed<bool>;

template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;

template <typename _Tp>
using make_unsigned_t = typename make_unsigned<_Tp>::type;

template <typename _Tp> struct remove_extent {
typedef _Tp type;
};

template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp[_Size]> {
typedef _Tp type;
};

template <typename _Tp> struct remove_extent<_Tp[]> {
typedef _Tp type;
};

template <typename _Tp> struct remove_all_extents {
typedef _Tp type;
};

template <typename _Tp, std::size_t _Size>
struct remove_all_extents<_Tp[_Size]> {
typedef typename remove_all_extents<_Tp>::type type;
};

template <typename _Tp> struct remove_all_extents<_Tp[]> {
typedef typename remove_all_extents<_Tp>::type type;
};

template <typename _Tp>
using remove_extent_t = typename remove_extent<_Tp>::type;

template <typename _Tp>
using remove_all_extents_t = typename remove_all_extents<_Tp>::type;

template <typename _Tp, typename> struct __remove_pointer_helper {
typedef _Tp type;
};

template <typename _Tp, typename _Up>
struct __remove_pointer_helper<_Tp, _Up *> {
typedef _Up type;
};

template <typename _Tp>
struct remove_pointer
: public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {};

template <typename _Tp,
bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value>
struct __add_pointer_helper {
typedef _Tp type;
};

template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
typedef typename remove_reference<_Tp>::type *type;
};

template <typename _Tp>
struct add_pointer : public __add_pointer_helper<_Tp> {};

template <typename _Tp>
using remove_pointer_t = typename remove_pointer<_Tp>::type;

template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;

template <std::size_t _Len> struct __aligned_storage_msa {
union __type {
unsigned char __data[_Len];
struct __attribute__((__aligned__)) {
} __align;
};
};
template <std::size_t _Len, std::size_t _Align = __alignof__(
typename __aligned_storage_msa<_Len>::__type)>
struct aligned_storage {
union type {
unsigned char __data[_Len];
struct __attribute__((__aligned__((_Align)))) {
} __align;
};
};

template <typename... _Types> struct __strictest_alignment {
static const size_t _S_alignment = 0;
static const size_t _S_size = 0;
};

template <typename _Tp, typename... _Types>
struct __strictest_alignment<_Tp, _Types...> {
static const size_t
_S_alignment = alignof(_Tp) >
__strictest_alignment<_Types...>::_S_alignment
? alignof(_Tp)
: __strictest_alignment<_Types...>::_S_alignment;
static const size_t
_S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
? sizeof(_Tp)
: __strictest_alignment<_Types...>::_S_size;
};
template <size_t _Len, typename... _Types> struct aligned_union {
private:
static_assert(sizeof...(_Types) != 0, "At least one type is required");

using __strictest = __strictest_alignment<_Types...>;
static const size_t _S_len =
_Len > __strictest::_S_size ? _Len : __strictest::_S_size;

public:
static const size_t alignment_value = __strictest::_S_alignment;

typedef typename aligned_storage<_S_len, alignment_value>::type type;
};

template <size_t _Len, typename... _Types>
const size_t aligned_union<_Len, _Types...>::alignment_value;

template <typename _Up, bool _IsArray = is_array<_Up>::value,
bool _IsFunction = is_function<_Up>::value>
struct __decay_selector;

template <typename _Up> struct __decay_selector<_Up, false, false> {
typedef __remove_cv_t<_Up> __type;
};

template <typename _Up> struct __decay_selector<_Up, true, false> {
typedef typename remove_extent<_Up>::type *__type;
};

template <typename _Up> struct __decay_selector<_Up, false, true> {
typedef typename add_pointer<_Up>::type __type;
};

template <typename _Tp> class decay {
typedef typename remove_reference<_Tp>::type __remove_type;

public:
typedef typename __decay_selector<__remove_type>::__type type;
};

template <typename _Tp> struct __strip_reference_wrapper {
typedef _Tp __type;
};

template <typename _Tp>
struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
typedef _Tp &__type;
};

template <typename _Tp> using __decay_t = typename decay<_Tp>::type;

template <typename _Tp>
using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;

template <bool, typename _Tp = void> struct enable_if {};

template <typename _Tp> struct enable_if<true, _Tp> {
typedef _Tp type;
};

template <bool _Cond, typename _Tp = void>
using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

template <typename... _Cond>
using _Require = __enable_if_t<__and_<_Cond...>::value>;

template <typename _Tp>
using __remove_cvref_t =
typename remove_cv<typename remove_reference<_Tp>::type>::type;

template <bool _Cond, typename _Iftrue, typename _Iffalse>
struct conditional {
typedef _Iftrue type;
};

template <typename _Iftrue, typename _Iffalse>
struct conditional<false, _Iftrue, _Iffalse> {
typedef _Iffalse type;
};

template <typename... _Tp> struct common_type;

struct __do_common_type_impl {
template <typename _Tp, typename _Up>
using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());

template <typename _Tp, typename _Up>
static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
template <typename, typename> static __failure_type _S_test_2(...);

template <typename _Tp, typename _Up>
static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
};

template <> struct common_type<> {};

template <typename _Tp0>
struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {};

template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>,
typename _Dp2 = __decay_t<_Tp2>>
struct __common_type_impl {

using type = common_type<_Dp1, _Dp2>;
};

template <typename _Tp1, typename _Tp2>
struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
: private __do_common_type_impl {

using type = decltype(_S_test<_Tp1, _Tp2>(0));
};

template <typename _Tp1, typename _Tp2>
struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
};

template <typename...> struct __common_type_pack {};

template <typename, typename, typename = void> struct __common_type_fold;

template <typename _Tp1, typename _Tp2, typename... _Rp>
struct common_type<_Tp1, _Tp2, _Rp...>
: public __common_type_fold<common_type<_Tp1, _Tp2>,
__common_type_pack<_Rp...>> {};

template <typename _CTp, typename... _Rp>
struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
__void_t<typename _CTp::type>>
: public common_type<typename _CTp::type, _Rp...> {};

template <typename _CTp, typename _Rp>
struct __common_type_fold<_CTp, _Rp, void> {};

template <typename _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl {
using type = __underlying_type(_Tp);
};

template <typename _Tp> struct __underlying_type_impl<_Tp, false> {};

template <typename _Tp>
struct underlying_type : public __underlying_type_impl<_Tp> {};

template <typename _Tp> struct __declval_protector {
static const bool __stop = false;
};

template <typename _Tp>
auto declval() noexcept -> decltype(__declval<_Tp>(0)) {
static_assert(__declval_protector<_Tp>::__stop,
"declval() must not be used!");
return __declval<_Tp>(0);
}

template <typename _Signature> struct result_of;

struct __invoke_memfun_ref {};
struct __invoke_memfun_deref {};
struct __invoke_memobj_ref {};
struct __invoke_memobj_deref {};
struct __invoke_other {};

template <typename _Tp, typename _Tag>
struct __result_of_success : __success_type<_Tp> {
using __invoke_type = _Tag;
};

struct __result_of_memfun_ref_impl {
template <typename _Fp, typename _Tp1, typename... _Args>
static __result_of_success<
decltype((std::declval<_Tp1>().*
std::declval<_Fp>())(std::declval<_Args>()...)),
__invoke_memfun_ref>
_S_test(int);

template <typename...> static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun_ref : private __result_of_memfun_ref_impl {
typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
};

struct __result_of_memfun_deref_impl {
template <typename _Fp, typename _Tp1, typename... _Args>
static __result_of_success<
decltype(((*std::declval<_Tp1>()).*
std::declval<_Fp>())(std::declval<_Args>()...)),
__invoke_memfun_deref>
_S_test(int);

template <typename...> static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun_deref : private __result_of_memfun_deref_impl {
typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
};

struct __result_of_memobj_ref_impl {
template <typename _Fp, typename _Tp1>
static __result_of_success<decltype(std::declval<_Tp1>().*
std::declval<_Fp>()),
__invoke_memobj_ref>
_S_test(int);

template <typename, typename> static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg>
struct __result_of_memobj_ref : private __result_of_memobj_ref_impl {
typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
};

struct __result_of_memobj_deref_impl {
template <typename _Fp, typename _Tp1>
static __result_of_success<decltype((*std::declval<_Tp1>()).*
std::declval<_Fp>()),
__invoke_memobj_deref>
_S_test(int);

template <typename, typename> static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg>
struct __result_of_memobj_deref : private __result_of_memobj_deref_impl {
typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
};

template <typename _MemPtr, typename _Arg> struct __result_of_memobj;

template <typename _Res, typename _Class, typename _Arg>
struct __result_of_memobj<_Res _Class::*, _Arg> {
typedef __remove_cvref_t<_Arg> _Argval;
typedef _Res _Class::*_MemPtr;
typedef typename __conditional_t<
__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value,
__result_of_memobj_ref<_MemPtr, _Arg>,
__result_of_memobj_deref<_MemPtr, _Arg>>::type type;
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun;

template <typename _Res, typename _Class, typename _Arg, typename... _Args>
struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
typedef typename remove_reference<_Arg>::type _Argval;
typedef _Res _Class::*_MemPtr;
typedef typename __conditional_t<
is_base_of<_Class, _Argval>::value,
__result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
__result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
};

template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
struct __inv_unwrap {
using type = _Tp;
};

template <typename _Tp, typename _Up>
struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
using type = _Up &;
};

template <bool, bool, typename _Functor, typename... _ArgTypes>
struct __result_of_impl {
typedef __failure_type type;
};

template <typename _MemPtr, typename _Arg>
struct __result_of_impl<true, false, _MemPtr, _Arg>
: public __result_of_memobj<__decay_t<_MemPtr>,
typename __inv_unwrap<_Arg>::type> {};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
: public __result_of_memfun<__decay_t<_MemPtr>,
typename __inv_unwrap<_Arg>::type, _Args...> {
};

struct __result_of_other_impl {
template <typename _Fn, typename... _Args>
static __result_of_success<
decltype(std::declval<_Fn>()(std::declval<_Args>()...)), __invoke_other>
_S_test(int);

template <typename...> static __failure_type _S_test(...);
};

template <typename _Functor, typename... _ArgTypes>
struct __result_of_impl<false, false, _Functor, _ArgTypes...>
: private __result_of_other_impl {
typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
};

template <typename _Functor, typename... _ArgTypes>
struct __invoke_result
: public __result_of_impl<
is_member_object_pointer<
typename remove_reference<_Functor>::type>::value,
is_member_function_pointer<
typename remove_reference<_Functor>::type>::value,
_Functor, _ArgTypes...>::type {};

template <typename _Functor, typename... _ArgTypes>
struct result_of<_Functor(_ArgTypes...)>
: public __invoke_result<_Functor, _ArgTypes...> {
} __attribute__((__deprecated__("use '"
"std::invoke_result"
"' instead")));

template <size_t _Len, size_t _Align = __alignof__(
typename __aligned_storage_msa<_Len>::__type)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template <size_t _Len, typename... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template <typename _Tp> using decay_t = typename decay<_Tp>::type;

template <bool _Cond, typename _Tp = void>
using enable_if_t = typename enable_if<_Cond, _Tp>::type;

template <bool _Cond, typename _Iftrue, typename _Iffalse>
using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;

template <typename... _Tp>
using common_type_t = typename common_type<_Tp...>::type;

template <typename _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;

template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;

template <typename...> using void_t = void;

template <typename _Default, typename _AlwaysVoid,
template <typename...> class _Op, typename... _Args>
struct __detector {
using value_t = false_type;
using type = _Default;
};

template <typename _Default, template <typename...> class _Op,
typename... _Args>
struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
using value_t = true_type;
using type = _Op<_Args...>;
};

template <typename _Default, template <typename...> class _Op,
typename... _Args>
using __detected_or = __detector<_Default, void, _Op, _Args...>;

template <typename _Default, template <typename...> class _Op,
typename... _Args>
using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
template <typename _Tp> struct __is_swappable;

template <typename _Tp> struct __is_nothrow_swappable;

template <typename> struct __is_tuple_like_impl : false_type {};

template <typename _Tp>
struct __is_tuple_like
: public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {};

template <typename _Tp>

inline _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>,
is_move_assignable<_Tp>>
swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
is_nothrow_move_assignable<_Tp>>::value);

template <typename _Tp, size_t _Nm>

inline __enable_if_t<__is_swappable<_Tp>::value> swap(
_Tp(&__a)[_Nm],
_Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);

namespace __swappable_details {
using std::swap;

struct __do_is_swappable_impl {
template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(),
std::declval<_Tp &>()))>
static true_type __test(int);

template <typename> static false_type __test(...);
};

struct __do_is_nothrow_swappable_impl {
template <typename _Tp>
static __bool_constant<noexcept(swap(std::declval<_Tp &>(),
std::declval<_Tp &>()))>
__test(int);

template <typename> static false_type __test(...);
};

} // namespace __swappable_details

template <typename _Tp>
struct __is_swappable_impl
: public __swappable_details::__do_is_swappable_impl {
typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp>
struct __is_nothrow_swappable_impl
: public __swappable_details::__do_is_nothrow_swappable_impl {
typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp>
struct __is_swappable : public __is_swappable_impl<_Tp>::type {};

template <typename _Tp>
struct __is_nothrow_swappable
: public __is_nothrow_swappable_impl<_Tp>::type {};

template <typename _Tp>
struct is_swappable : public __is_swappable_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;

template <typename _Tp>
inline constexpr bool is_nothrow_swappable_v =
is_nothrow_swappable<_Tp>::value;

namespace __swappable_with_details {
using std::swap;

struct __do_is_swappable_with_impl {
template <
typename _Tp, typename _Up,
typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
static true_type __test(int);

template <typename, typename> static false_type __test(...);
};

struct __do_is_nothrow_swappable_with_impl {
template <typename _Tp, typename _Up>
static __bool_constant<
noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) &&
noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))>
__test(int);

template <typename, typename> static false_type __test(...);
};

} // namespace __swappable_with_details

template <typename _Tp, typename _Up>
struct __is_swappable_with_impl
: public __swappable_with_details::__do_is_swappable_with_impl {
typedef decltype(__test<_Tp, _Up>(0)) type;
};

template <typename _Tp>
struct __is_swappable_with_impl<_Tp &, _Tp &>
: public __swappable_details::__do_is_swappable_impl {
typedef decltype(__test<_Tp &>(0)) type;
};

template <typename _Tp, typename _Up>
struct __is_nothrow_swappable_with_impl
: public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
typedef decltype(__test<_Tp, _Up>(0)) type;
};

template <typename _Tp>
struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &>
: public __swappable_details::__do_is_nothrow_swappable_impl {
typedef decltype(__test<_Tp &>(0)) type;
};

template <typename _Tp, typename _Up>
struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"first template argument must be a complete class or an "
"unbounded array");
static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
"second template argument must be a complete class or an "
"unbounded array");
};

template <typename _Tp, typename _Up>
struct is_nothrow_swappable_with
: public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"first template argument must be a complete class or an "
"unbounded array");
static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
"second template argument must be a complete class or an "
"unbounded array");
};

template <typename _Tp, typename _Up>
inline constexpr bool is_swappable_with_v =
is_swappable_with<_Tp, _Up>::value;

template <typename _Tp, typename _Up>
inline constexpr bool is_nothrow_swappable_with_v =
is_nothrow_swappable_with<_Tp, _Up>::value;
template <typename _Result, typename _Ret, bool = is_void<_Ret>::value,
typename = void>
struct __is_invocable_impl : false_type {};

template <typename _Result, typename _Ret>
struct __is_invocable_impl<_Result, _Ret, true,
__void_t<typename _Result::type>> : true_type {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

template <typename _Result, typename _Ret>
struct __is_invocable_impl<_Result, _Ret, false,
__void_t<typename _Result::type>> {
private:
static typename _Result::type _S_get();

template <typename _Tp> static void _S_conv(_Tp);

template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
static true_type _S_test(int);

template <typename _Tp> static false_type _S_test(...);

public:
using type = decltype(_S_test<_Ret>(1));
};
#pragma GCC diagnostic pop

template <typename _Fn, typename... _ArgTypes>
struct __is_invocable
: __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {};

template <typename _Fn, typename _Tp, typename... _Args>
constexpr bool __call_is_nt(__invoke_memfun_ref) {
using _Up = typename __inv_unwrap<_Tp>::type;
return noexcept(
(std::declval<_Up>().*std::declval<_Fn>())(std::declval<_Args>()...));
}

template <typename _Fn, typename _Tp, typename... _Args>
constexpr bool __call_is_nt(__invoke_memfun_deref) {
return noexcept(((*std::declval<_Tp>()).*
std::declval<_Fn>())(std::declval<_Args>()...));
}

template <typename _Fn, typename _Tp>
constexpr bool __call_is_nt(__invoke_memobj_ref) {
using _Up = typename __inv_unwrap<_Tp>::type;
return noexcept(std::declval<_Up>().*std::declval<_Fn>());
}

template <typename _Fn, typename _Tp>
constexpr bool __call_is_nt(__invoke_memobj_deref) {
return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
}

template <typename _Fn, typename... _Args>
constexpr bool __call_is_nt(__invoke_other) {
return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
}

template <typename _Result, typename _Fn, typename... _Args>
struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(
typename _Result::__invoke_type{})> {};

template <typename _Fn, typename... _Args>
using __call_is_nothrow_ =
__call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;

template <typename _Fn, typename... _Args>
struct __is_nothrow_invocable
: __and_<__is_invocable<_Fn, _Args...>,
__call_is_nothrow_<_Fn, _Args...>>::type {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
struct __nonesuchbase {};
struct __nonesuch : private __nonesuchbase {
~__nonesuch() = delete;
__nonesuch(__nonesuch const &) = delete;
void operator=(__nonesuch const &) = delete;
};
#pragma GCC diagnostic pop

template <typename _Functor, typename... _ArgTypes>
struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
"_Functor must be a complete class or an unbounded array");
static_assert(
(std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
"each argument type must be a complete class or an unbounded array");
};

template <typename _Fn, typename... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;

template <typename _Fn, typename... _ArgTypes>
struct is_invocable
: __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
"_Fn must be a complete class or an unbounded array");
static_assert(
(std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
"each argument type must be a complete class or an unbounded array");
};

template <typename _Ret, typename _Fn, typename... _ArgTypes>
struct is_invocable_r
: __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
"_Fn must be a complete class or an unbounded array");
static_assert(
(std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
"each argument type must be a complete class or an unbounded array");
static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
"_Ret must be a complete class or an unbounded array");
};

template <typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable
: __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
__call_is_nothrow_<_Fn, _ArgTypes...>>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
"_Fn must be a complete class or an unbounded array");
static_assert(
(std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
"each argument type must be a complete class or an unbounded array");
};

template <typename _Result, typename _Ret, typename = void>
struct __is_nt_invocable_impl : false_type {};

template <typename _Result, typename _Ret>
struct __is_nt_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
: __or_<is_void<_Ret>,
__is_nothrow_convertible<typename _Result::type, _Ret>> {};

template <typename _Ret, typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable_r
: __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
__call_is_nothrow_<_Fn, _ArgTypes...>>::type {
static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
"_Fn must be a complete class or an unbounded array");
static_assert(
(std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
"each argument type must be a complete class or an unbounded array");
static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
"_Ret must be a complete class or an unbounded array");
};
template <typename _Tp> inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_array_v = is_array<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_member_object_pointer_v =
is_member_object_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_member_function_pointer_v =
is_member_function_pointer<_Tp>::value;
template <typename _Tp> inline constexpr bool is_enum_v = is_enum<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_union_v = is_union<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_class_v = is_class<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_reference_v = is_reference<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_const_v = is_const<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivially_copyable_v =
is_trivially_copyable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <typename _Tp>

inline constexpr bool is_pod_v = is_pod<_Tp>::value;
template <typename _Tp>
[[__deprecated__]] inline constexpr bool is_literal_type_v =
is_literal_type<_Tp>::value;
#pragma GCC diagnostic pop
template <typename _Tp>
inline constexpr bool is_empty_v = is_empty<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_final_v = is_final<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
template <typename _Tp, typename... _Args>
inline constexpr bool is_constructible_v =
is_constructible<_Tp, _Args...>::value;
template <typename _Tp>
inline constexpr bool is_default_constructible_v =
is_default_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_copy_constructible_v =
is_copy_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_move_constructible_v =
is_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
template <typename _Tp>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
inline constexpr bool is_trivially_constructible_v =
is_trivially_constructible<_Tp, _Args...>::value;
template <typename _Tp>
inline constexpr bool is_trivially_default_constructible_v =
is_trivially_default_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivially_copy_constructible_v =
is_trivially_copy_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivially_move_constructible_v =
is_trivially_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
inline constexpr bool is_trivially_assignable_v =
is_trivially_assignable<_Tp, _Up>::value;
template <typename _Tp>
inline constexpr bool is_trivially_copy_assignable_v =
is_trivially_copy_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivially_move_assignable_v =
is_trivially_move_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_trivially_destructible_v =
is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
inline constexpr bool is_nothrow_constructible_v =
is_nothrow_constructible<_Tp, _Args...>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_default_constructible_v =
is_nothrow_default_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_copy_constructible_v =
is_nothrow_copy_constructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_move_constructible_v =
is_nothrow_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
inline constexpr bool is_nothrow_assignable_v =
is_nothrow_assignable<_Tp, _Up>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_copy_assignable_v =
is_nothrow_copy_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_move_assignable_v =
is_nothrow_move_assignable<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_nothrow_destructible_v =
is_nothrow_destructible<_Tp>::value;
template <typename _Tp>
inline constexpr bool has_virtual_destructor_v =
has_virtual_destructor<_Tp>::value;
template <typename _Tp>
inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
template <typename _Tp> inline constexpr size_t rank_v = rank<_Tp>::value;
template <typename _Tp, unsigned _Idx = 0>
inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;

template <typename _Tp, typename _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);

template <typename _Base, typename _Derived>
inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template <typename _From, typename _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template <typename _Fn, typename... _Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template <typename _Fn, typename... _Args>
inline constexpr bool is_nothrow_invocable_v =
is_nothrow_invocable<_Fn, _Args...>::value;
template <typename _Ret, typename _Fn, typename... _Args>
inline constexpr bool is_invocable_r_v =
is_invocable_r<_Ret, _Fn, _Args...>::value;
template <typename _Ret, typename _Fn, typename... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;

template <typename _Tp>
struct has_unique_object_representations
: bool_constant<__has_unique_object_representations(
remove_cv_t<remove_all_extents_t<_Tp>>)> {
static_assert(
std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
"template argument must be a complete class or an unbounded array");
};

template <typename _Tp>
inline constexpr bool has_unique_object_representations_v =
has_unique_object_representations<_Tp>::value;

template <typename _Tp>
struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {};

template <typename _Tp>
inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp>
inline constexpr _Tp *__addressof(_Tp & __r) noexcept {
return __builtin_addressof(__r);
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp>
[[__nodiscard__]] constexpr _Tp &&forward(
typename std::remove_reference<_Tp>::type & __t) noexcept {
return static_cast<_Tp &&>(__t);
}

template <typename _Tp>
[[__nodiscard__]] constexpr _Tp &&forward(
typename std::remove_reference<_Tp>::type && __t) noexcept {
static_assert(
!std::is_lvalue_reference<_Tp>::value,
"std::forward must not be used to convert an rvalue to an lvalue");
return static_cast<_Tp &&>(__t);
}

template <typename _Tp>
[[__nodiscard__]] constexpr typename std::remove_reference<_Tp>::type &&move(
_Tp && __t) noexcept {
return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
}

template <typename _Tp>
struct __move_if_noexcept_cond
: public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
is_copy_constructible<_Tp>>::type {};
template <typename _Tp>
[[__nodiscard__]] constexpr __conditional_t<
__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>
move_if_noexcept(_Tp & __x) noexcept {
return std::move(__x);
}
template <typename _Tp>
[[__nodiscard__]] inline constexpr _Tp *addressof(_Tp & __r) noexcept {
return std::__addressof(__r);
}

template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete;

template <typename _Tp, typename _Up = _Tp>

inline _Tp __exchange(_Tp & __obj, _Up && __new_val) {
_Tp __old_val = std::move(__obj);
__obj = std::forward<_Up>(__new_val);
return __old_val;
}
template <typename _Tp>

inline

typename enable_if<
__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>,
is_move_assignable<_Tp>>::value>::type

swap(_Tp & __a,
_Tp & __b) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
is_nothrow_move_assignable<_Tp>>::value)

{

_Tp __tmp = std::move(__a);
__a = std::move(__b);
__b = std::move(__tmp);
}

template <typename _Tp, size_t _Nm>

inline

typename enable_if<__is_swappable<_Tp>::value>::type

swap(_Tp(&__a)[_Nm],
_Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value) {
for (size_t __n = 0; __n < _Nm; ++__n)
swap(__a[__n], __b[__n]);
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp> struct tuple_size;

template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type,
typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
size_t = tuple_size<_Tp>::value>
using __enable_if_has_tuple_size = _Tp;

template <typename _Tp>
struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
: public tuple_size<_Tp> {};

template <typename _Tp>
struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
: public tuple_size<_Tp> {};

template <typename _Tp>
struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
: public tuple_size<_Tp> {};

template <typename _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;

template <size_t __i, typename _Tp> struct tuple_element;

template <size_t __i, typename _Tp>
using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

template <size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
};

template <size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
};

template <size_t __i, typename _Tp>
struct tuple_element<__i, const volatile _Tp> {
typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
};

template <typename _Tp, typename... _Types>
constexpr size_t __find_uniq_type_in_pack() {
constexpr size_t __sz = sizeof...(_Types);
constexpr bool __found[__sz] = {__is_same(_Tp, _Types)...};
size_t __n = __sz;
for (size_t __i = 0; __i < __sz; ++__i) {
if (__found[__i]) {
if (__n < __sz)
return __sz;
__n = __i;
}
}
return __n;
}
template <size_t __i, typename _Tp>
using tuple_element_t = typename tuple_element<__i, _Tp>::type;

template <size_t... _Indexes> struct _Index_tuple {};

template <size_t _Num> struct _Build_index_tuple {
using __type = _Index_tuple<__integer_pack(_Num)...>;
};

template <typename _Tp, _Tp... _Idx> struct integer_sequence {
typedef _Tp value_type;
static constexpr size_t size() noexcept { return sizeof...(_Idx); }
};

template <typename _Tp, _Tp _Num>
using make_integer_sequence

= integer_sequence<_Tp, __integer_pack(_Num)...>;

template <size_t... _Idx>
using index_sequence = integer_sequence<size_t, _Idx...>;

template <size_t _Num>
using make_index_sequence = make_integer_sequence<size_t, _Num>;

template <typename... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

struct in_place_t {
explicit in_place_t() = default;
};

inline constexpr in_place_t in_place{};

template <typename _Tp> struct in_place_type_t {
explicit in_place_type_t() = default;
};

template <typename _Tp> inline constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx> struct in_place_index_t {
explicit in_place_index_t() = default;
};

template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};

template <typename> inline constexpr bool __is_in_place_type_v = false;

template <typename _Tp>
inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

template <typename _Tp>
using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

template <size_t _Np, typename... _Types> struct _Nth_type {};

template <typename _Tp0, typename... _Rest>
struct _Nth_type<0, _Tp0, _Rest...> {
using type = _Tp0;
};

template <typename _Tp0, typename _Tp1, typename... _Rest>
struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
using type = _Tp1;
};

template <typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
using type = _Tp2;
};

template <size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2,
typename... _Rest>

struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>
: _Nth_type<_Np - 3, _Rest...> {};

template <typename _Tp0, typename _Tp1, typename... _Rest>
struct _Nth_type<0, _Tp0, _Tp1, _Rest...> {
using type = _Tp0;
};

template <typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
struct _Nth_type<0, _Tp0, _Tp1, _Tp2, _Rest...> {
using type = _Tp0;
};

template <typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
struct _Nth_type<1, _Tp0, _Tp1, _Tp2, _Rest...> {
using type = _Tp1;
};

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

struct piecewise_construct_t {
explicit piecewise_construct_t() = default;
};

inline constexpr piecewise_construct_t piecewise_construct =
piecewise_construct_t();

template <typename...> class tuple;

template <size_t...> struct _Index_tuple;

template <bool, typename _T1, typename _T2> struct _PCC {
template <typename _U1, typename _U2>
static constexpr bool _ConstructiblePair() {
return __and_<is_constructible<_T1, const _U1 &>,
is_constructible<_T2, const _U2 &>>::value;
}

template <typename _U1, typename _U2>
static constexpr bool _ImplicitlyConvertiblePair() {
return __and_<is_convertible<const _U1 &, _T1>,
is_convertible<const _U2 &, _T2>>::value;
}

template <typename _U1, typename _U2>
static constexpr bool _MoveConstructiblePair() {
return __and_<is_constructible<_T1, _U1 &&>,
is_constructible<_T2, _U2 &&>>::value;
}

template <typename _U1, typename _U2>
static constexpr bool _ImplicitlyMoveConvertiblePair() {
return __and_<is_convertible<_U1 &&, _T1>,
is_convertible<_U2 &&, _T2>>::value;
}
};

template <typename _T1, typename _T2> struct _PCC<false, _T1, _T2> {
template <typename _U1, typename _U2>
static constexpr bool _ConstructiblePair() {
return false;
}

template <typename _U1, typename _U2>
static constexpr bool _ImplicitlyConvertiblePair() {
return false;
}

template <typename _U1, typename _U2>
static constexpr bool _MoveConstructiblePair() {
return false;
}

template <typename _U1, typename _U2>
static constexpr bool _ImplicitlyMoveConvertiblePair() {
return false;
}
};

template <typename _U1, typename _U2> class __pair_base {

template <typename _T1, typename _T2> friend struct pair;
__pair_base() = default;
~__pair_base() = default;
__pair_base(const __pair_base &) = default;
__pair_base &operator=(const __pair_base &) = delete;
};
template <typename _T1, typename _T2>
struct pair : public __pair_base<_T1, _T2> {
typedef _T1 first_type;
typedef _T2 second_type;

_T1 first;
_T2 second;

constexpr pair(const pair &) = default;
constexpr pair(pair &&) = default;

template <typename... _Args1, typename... _Args2>

pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

void swap(pair &__p) noexcept(__and_<__is_nothrow_swappable<_T1>,
__is_nothrow_swappable<_T2>>::value) {
using std::swap;
swap(first, __p.first);
swap(second, __p.second);
}

private:
template <typename... _Args1, size_t... _Indexes1, typename... _Args2,
size_t... _Indexes2>

pair(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>,
_Index_tuple<_Indexes2...>);

public:
template <typename _U1 = _T1, typename _U2 = _T2,
typename enable_if<
__and_<__is_implicitly_default_constructible<_U1>,
__is_implicitly_default_constructible<_U2>>::value,
bool>::type = true>
constexpr pair() : first(), second() {}

template <
typename _U1 = _T1, typename _U2 = _T2,
typename enable_if<
__and_<is_default_constructible<_U1>, is_default_constructible<_U2>,
__not_<__and_<__is_implicitly_default_constructible<_U1>,
__is_implicitly_default_constructible<_U2>>>>::
value,
bool>::type = false>
explicit constexpr pair() : first(), second() {}

using _PCCP = _PCC<true, _T1, _T2>;

template <typename _U1 = _T1, typename _U2 = _T2,
typename enable_if<
_PCCP::template _ConstructiblePair<_U1, _U2>() &&
_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(),
bool>::type = true>
constexpr pair(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) {}

template <typename _U1 = _T1, typename _U2 = _T2,
typename enable_if<
_PCCP::template _ConstructiblePair<_U1, _U2>() &&
!_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(),
bool>::type = false>
explicit constexpr pair(const _T1 &__a, const _T2 &__b)
: first(__a), second(__b) {}

template <typename _U1, typename _U2>
using _PCCFP =
_PCC<!is_same<_T1, _U1>::value || !is_same<_T2, _U2>::value, _T1, _T2>;

template <typename _U1, typename _U2,
typename enable_if<
_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() &&
_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<
_U1, _U2>(),
bool>::type = true>
constexpr pair(const pair<_U1, _U2> &__p)
: first(__p.first), second(__p.second) {}

template <typename _U1, typename _U2,
typename enable_if<
_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() &&
!_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<
_U1, _U2>(),
bool>::type = false>
explicit constexpr pair(const pair<_U1, _U2> &__p)
: first(__p.first), second(__p.second) {}

private:
struct __zero_as_null_pointer_constant {
__zero_as_null_pointer_constant(int __zero_as_null_pointer_constant::*) {}
template <typename _Tp,
typename = __enable_if_t<is_null_pointer<_Tp>::value>>
__zero_as_null_pointer_constant(_Tp) = delete;
};

public:
template <typename _U1,
__enable_if_t<__and_<__not_<is_reference<_U1>>, is_pointer<_T2>,
is_constructible<_T1, _U1>,
__not_<is_constructible<_T1, const _U1 &>>,
is_convertible<_U1, _T1>>::value,
bool> = true>
__attribute__((__deprecated__(
"use 'nullptr' instead of '0' to "
"initialize std::pair of move-only "
"type and pointer"))) constexpr pair(_U1 &&__x,
__zero_as_null_pointer_constant,
...)
: first(std::forward<_U1>(__x)), second(nullptr) {}

template <typename _U1,
__enable_if_t<__and_<__not_<is_reference<_U1>>, is_pointer<_T2>,
is_constructible<_T1, _U1>,
__not_<is_constructible<_T1, const _U1 &>>,
__not_<is_convertible<_U1, _T1>>>::value,
bool> = false>
__attribute__((__deprecated__(
"use 'nullptr' instead of '0' to "
"initialize std::pair of move-only "
"type and pointer"))) explicit constexpr pair(_U1 &&__x,
__zero_as_null_pointer_constant,
...)
: first(std::forward<_U1>(__x)), second(nullptr) {}

template <typename _U2,
__enable_if_t<__and_<is_pointer<_T1>, __not_<is_reference<_U2>>,
is_constructible<_T2, _U2>,
__not_<is_constructible<_T2, const _U2 &>>,
is_convertible<_U2, _T2>>::value,
bool> = true>
__attribute__((__deprecated__(
"use 'nullptr' instead of '0' to "
"initialize std::pair of move-only "
"type and pointer"))) constexpr pair(__zero_as_null_pointer_constant,
_U2 &&__y, ...)
: first(nullptr), second(std::forward<_U2>(__y)) {}

template <typename _U2,
__enable_if_t<__and_<is_pointer<_T1>, __not_<is_reference<_U2>>,
is_constructible<_T2, _U2>,
__not_<is_constructible<_T2, const _U2 &>>,
__not_<is_convertible<_U2, _T2>>>::value,
bool> = false>
__attribute__((__deprecated__(
"use 'nullptr' instead of '0' to "
"initialize std::pair of move-only "
"type and pointer"))) explicit constexpr pair(__zero_as_null_pointer_constant,
_U2 &&__y, ...)
: first(nullptr), second(std::forward<_U2>(__y)) {}

template <
typename _U1, typename _U2,
typename enable_if<
_PCCP::template _MoveConstructiblePair<_U1, _U2>() &&
_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
bool>::type = true>
constexpr pair(_U1 &&__x, _U2 &&__y)
: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {}

template <
typename _U1, typename _U2,
typename enable_if<
_PCCP::template _MoveConstructiblePair<_U1, _U2>() &&
!_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
bool>::type = false>
explicit constexpr pair(_U1 &&__x, _U2 &&__y)
: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {}

template <
typename _U1, typename _U2,
typename enable_if<
_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() &&
_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<
_U1, _U2>(),
bool>::type = true>
constexpr pair(pair<_U1, _U2> &&__p)
: first(std::forward<_U1>(__p.first)),
second(std::forward<_U2>(__p.second)) {}

template <
typename _U1, typename _U2,
typename enable_if<
_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() &&
!_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<
_U1, _U2>(),
bool>::type = false>
explicit constexpr pair(pair<_U1, _U2> &&__p)
: first(std::forward<_U1>(__p.first)),
second(std::forward<_U2>(__p.second)) {}

pair &
operator=(__conditional_t<
__and_<is_copy_assignable<_T1>, is_copy_assignable<_T2>>::value,
const pair &, const __nonesuch &>
__p) {
first = __p.first;
second = __p.second;
return *this;
}

pair &operator=(
__conditional_t<
__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value,
pair &&, __nonesuch &&>
__p) noexcept(__and_<is_nothrow_move_assignable<_T1>,
is_nothrow_move_assignable<_T2>>::value) {
first = std::forward<first_type>(__p.first);
second = std::forward<second_type>(__p.second);
return *this;
}

template <typename _U1, typename _U2>
typename enable_if<__and_<is_assignable<_T1 &, const _U1 &>,
is_assignable<_T2 &, const _U2 &>>::value,
pair &>::type
operator=(const pair<_U1, _U2> &__p) {
first = __p.first;
second = __p.second;
return *this;
}

template <typename _U1, typename _U2>
typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>,
is_assignable<_T2 &, _U2 &&>>::value,
pair &>::type
operator=(pair<_U1, _U2> &&__p) {
first = std::forward<_U1>(__p.first);
second = std::forward<_U2>(__p.second);
return *this;
}
};

template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;

template <typename _T1, typename _T2>
inline constexpr bool operator==(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return __x.first == __y.first && __x.second == __y.second;
}
template <typename _T1, typename _T2>
inline constexpr bool operator<(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return __x.first < __y.first ||
(!(__y.first < __x.first) && __x.second < __y.second);
}

template <typename _T1, typename _T2>
inline constexpr bool operator!=(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return !(__x == __y);
}

template <typename _T1, typename _T2>
inline constexpr bool operator>(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return __y < __x;
}

template <typename _T1, typename _T2>
inline constexpr bool operator<=(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return !(__y < __x);
}

template <typename _T1, typename _T2>
inline constexpr bool operator>=(const pair<_T1, _T2> &__x,
const pair<_T1, _T2> &__y) {
return !(__x < __y);
}
template <typename _T1, typename _T2>
inline

typename enable_if<
__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type

swap(pair<_T1, _T2> & __x,
pair<_T1, _T2> & __y) noexcept(noexcept(__x.swap(__y))) {
__x.swap(__y);
}

template <typename _T1, typename _T2>
typename enable_if<
!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type
swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete;
template <typename _T1, typename _T2>
constexpr pair<typename __decay_and_strip<_T1>::__type,
typename __decay_and_strip<_T2>::__type>
make_pair(_T1 && __x, _T2 && __y) {
typedef typename __decay_and_strip<_T1>::__type __ds_type1;
typedef typename __decay_and_strip<_T2>::__type __ds_type2;
typedef pair<__ds_type1, __ds_type2> __pair_type;
return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
}
template <typename _T1, typename _T2>
struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type {};

template <class _Tp1, class _Tp2>
struct tuple_size<pair<_Tp1, _Tp2>> : public integral_constant<size_t, 2> {};

template <class _Tp1, class _Tp2> struct tuple_element<0, pair<_Tp1, _Tp2>> {
typedef _Tp1 type;
};

template <class _Tp1, class _Tp2> struct tuple_element<1, pair<_Tp1, _Tp2>> {
typedef _Tp2 type;
};

template <typename _Tp1, typename _Tp2>
inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

template <typename _Tp1, typename _Tp2>
inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

template <typename _Tp> inline constexpr bool __is_pair = false;

template <typename _Tp, typename _Up>
inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;

template <typename _Tp, typename _Up>
inline constexpr bool __is_pair<const pair<_Tp, _Up>> = true;

template <size_t _Int> struct __pair_get;

template <> struct __pair_get<0> {
template <typename _Tp1, typename _Tp2>
static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
return __pair.first;
}

template <typename _Tp1, typename _Tp2>
static constexpr _Tp1 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
return std::forward<_Tp1>(__pair.first);
}

template <typename _Tp1, typename _Tp2>
static constexpr const _Tp1 &
__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
return __pair.first;
}

template <typename _Tp1, typename _Tp2>
static constexpr const _Tp1 &&
__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
return std::forward<const _Tp1>(__pair.first);
}
};

template <> struct __pair_get<1> {
template <typename _Tp1, typename _Tp2>
static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
return __pair.second;
}

template <typename _Tp1, typename _Tp2>
static constexpr _Tp2 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
return std::forward<_Tp2>(__pair.second);
}

template <typename _Tp1, typename _Tp2>
static constexpr const _Tp2 &
__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
return __pair.second;
}

template <typename _Tp1, typename _Tp2>
static constexpr const _Tp2 &&
__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
return std::forward<const _Tp2>(__pair.second);
}
};

template <size_t _Int, class _Tp1, class _Tp2>
constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(
pair<_Tp1, _Tp2> & __in) noexcept {
return __pair_get<_Int>::__get(__in);
}

template <size_t _Int, class _Tp1, class _Tp2>
constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(
pair<_Tp1, _Tp2> && __in) noexcept {
return __pair_get<_Int>::__move_get(std::move(__in));
}

template <size_t _Int, class _Tp1, class _Tp2>
constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(
const pair<_Tp1, _Tp2> &__in) noexcept {
return __pair_get<_Int>::__const_get(__in);
}

template <size_t _Int, class _Tp1, class _Tp2>
constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(
const pair<_Tp1, _Tp2> &&__in) noexcept {
return __pair_get<_Int>::__const_move_get(std::move(__in));
}

template <typename _Tp, typename _Up>
constexpr _Tp &get(pair<_Tp, _Up> & __p) noexcept {
return __p.first;
}

template <typename _Tp, typename _Up>
constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept {
return __p.first;
}

template <typename _Tp, typename _Up>
constexpr _Tp &&get(pair<_Tp, _Up> && __p) noexcept {
return std::move(__p.first);
}

template <typename _Tp, typename _Up>
constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept {
return std::move(__p.first);
}

template <typename _Tp, typename _Up>
constexpr _Tp &get(pair<_Up, _Tp> & __p) noexcept {
return __p.second;
}

template <typename _Tp, typename _Up>
constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept {
return __p.second;
}

template <typename _Tp, typename _Up>
constexpr _Tp &&get(pair<_Up, _Tp> && __p) noexcept {
return std::move(__p.second);
}

template <typename _Tp, typename _Up>
constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept {
return std::move(__p.second);
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

struct input_iterator_tag {};

struct output_iterator_tag {};

struct forward_iterator_tag : public input_iterator_tag {};

struct bidirectional_iterator_tag : public forward_iterator_tag {};

struct random_access_iterator_tag : public bidirectional_iterator_tag {};
template <typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
typename _Pointer = _Tp *, typename _Reference = _Tp &>
struct [[__deprecated__]] iterator {

typedef _Category iterator_category;

typedef _Tp value_type;

typedef _Distance difference_type;

typedef _Pointer pointer;

typedef _Reference reference;
};
template <typename _Iterator> struct iterator_traits;

template <typename _Iterator, typename = __void_t<>>
struct __iterator_traits {};

template <typename _Iterator>
struct __iterator_traits<
_Iterator,
__void_t<typename _Iterator::iterator_category,
typename _Iterator::value_type,
typename _Iterator::difference_type, typename _Iterator::pointer,
typename _Iterator::reference>> {
typedef typename _Iterator::iterator_category iterator_category;
typedef typename _Iterator::value_type value_type;
typedef typename _Iterator::difference_type difference_type;
typedef typename _Iterator::pointer pointer;
typedef typename _Iterator::reference reference;
};

template <typename _Iterator>
struct iterator_traits : public __iterator_traits<_Iterator> {};
template <typename _Tp> struct iterator_traits<_Tp *> {
typedef random_access_iterator_tag iterator_category;
typedef _Tp value_type;
typedef ptrdiff_t difference_type;
typedef _Tp *pointer;
typedef _Tp &reference;
};

template <typename _Tp> struct iterator_traits<const _Tp *> {
typedef random_access_iterator_tag iterator_category;
typedef _Tp value_type;
typedef ptrdiff_t difference_type;
typedef const _Tp *pointer;
typedef const _Tp &reference;
};

template <typename _Iter>
inline constexpr typename iterator_traits<_Iter>::iterator_category
__iterator_category(const _Iter &) {
return typename iterator_traits<_Iter>::iterator_category();
}

template <typename _Iter>
using __iterator_category_t =
typename iterator_traits<_Iter>::iterator_category;

template <typename _InIter>
using _RequireInputIter =
__enable_if_t<is_convertible<__iterator_category_t<_InIter>,
input_iterator_tag>::value>;

template <typename _It, typename _Cat = __iterator_category_t<_It>>
struct __is_random_access_iter
: is_base_of<random_access_iterator_tag, _Cat> {
typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
enum { __value = _Base::value };
};

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename> struct _List_iterator;
template <typename> struct _List_const_iterator;

template <typename _InputIterator>
inline constexpr typename iterator_traits<_InputIterator>::difference_type
__distance(_InputIterator __first, _InputIterator __last,
input_iterator_tag) {

typename iterator_traits<_InputIterator>::difference_type __n = 0;
while (__first != __last) {
++__first;
++__n;
}
return __n;
}

template <typename _RandomAccessIterator>
inline constexpr
typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
random_access_iterator_tag) {

return __last - __first;
}

template <typename _Tp>
ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>,
input_iterator_tag);

template <typename _Tp>
ptrdiff_t __distance(std::_List_const_iterator<_Tp>,
std::_List_const_iterator<_Tp>, input_iterator_tag);

template <typename _OutputIterator>
void __distance(_OutputIterator, _OutputIterator, output_iterator_tag) =
delete;
template <typename _InputIterator>
[[__nodiscard__]] inline constexpr
typename iterator_traits<_InputIterator>::difference_type
distance(_InputIterator __first, _InputIterator __last) {

return std::__distance(__first, __last, std::__iterator_category(__first));
}

template <typename _InputIterator, typename _Distance>
inline constexpr void __advance(_InputIterator & __i, _Distance __n,
input_iterator_tag) {

do {
if (std::__is_constant_evaluated() && !bool(__n >= 0))
__builtin_unreachable();
} while (false);
while (__n--)
++__i;
}

template <typename _BidirectionalIterator, typename _Distance>
inline constexpr void __advance(_BidirectionalIterator & __i, _Distance __n,
bidirectional_iterator_tag) {

if (__n > 0)
while (__n--)
++__i;
else
while (__n++)
--__i;
}

template <typename _RandomAccessIterator, typename _Distance>
inline constexpr void __advance(_RandomAccessIterator & __i, _Distance __n,
random_access_iterator_tag) {

if (__builtin_constant_p(__n) && __n == 1)
++__i;
else if (__builtin_constant_p(__n) && __n == -1)
--__i;
else
__i += __n;
}

template <typename _OutputIterator, typename _Distance>
void __advance(_OutputIterator &, _Distance, output_iterator_tag) = delete;
template <typename _InputIterator, typename _Distance>
inline constexpr void advance(_InputIterator & __i, _Distance __n) {

typename iterator_traits<_InputIterator>::difference_type __d = __n;
std::__advance(__i, __d, std::__iterator_category(__i));
}

template <typename _InputIterator>
[[__nodiscard__]] inline constexpr _InputIterator next(
_InputIterator __x,
typename iterator_traits<_InputIterator>::difference_type __n = 1) {

std::advance(__x, __n);
return __x;
}

template <typename _BidirectionalIterator>
[[__nodiscard__]] inline constexpr _BidirectionalIterator prev(
_BidirectionalIterator __x,
typename iterator_traits<_BidirectionalIterator>::difference_type __n =
1) {

std::advance(__x, -__n);
return __x;
}

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

class __undefined;

template <typename _Tp> struct __get_first_arg {
using type = __undefined;
};

template <template <typename, typename...> class _SomeTemplate, typename _Tp,
typename... _Types>
struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
using type = _Tp;
};

template <typename _Tp, typename _Up> struct __replace_first_arg {};

template <template <typename, typename...> class _SomeTemplate, typename _Up,
typename _Tp, typename... _Types>
struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
using type = _SomeTemplate<_Up, _Types...>;
};
template <typename _Ptr, typename = void>
struct __ptr_traits_elem : __get_first_arg<_Ptr> {};

template <typename _Ptr>
struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>> {
using type = typename _Ptr::element_type;
};

template <typename _Ptr>
using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;

template <typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
struct __ptr_traits_ptr_to {
using pointer = _Ptr;
using element_type = _Elt;

static pointer pointer_to(element_type &__e)

{
return pointer::pointer_to(__e);
}
};

template <typename _Ptr, typename _Elt>
struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {};

template <typename _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
using pointer = _Tp *;
using element_type = _Tp;

static pointer pointer_to(element_type &__r) noexcept {
return std::addressof(__r);
}
};

template <typename _Ptr, typename _Elt>
struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt> {
private:
template <typename _Tp, typename = void> struct __difference {
using type = ptrdiff_t;
};

template <typename _Tp>

struct __difference<_Tp, __void_t<typename _Tp::difference_type>>

{
using type = typename _Tp::difference_type;
};

template <typename _Tp, typename _Up, typename = void>
struct __rebind : __replace_first_arg<_Tp, _Up> {};

template <typename _Tp, typename _Up>

struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>

{
using type = typename _Tp::template rebind<_Up>;
};

public:
using pointer = _Ptr;

using element_type = _Elt;

using difference_type = typename __difference<_Ptr>::type;

template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
};

template <typename _Ptr> struct __ptr_traits_impl<_Ptr, __undefined> {};

template <typename _Ptr>
struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {};
template <typename _Tp>
struct pointer_traits<_Tp *> : __ptr_traits_ptr_to<_Tp *, _Tp> {

typedef _Tp *pointer;

typedef _Tp element_type;

typedef ptrdiff_t difference_type;

template <typename _Up> using rebind = _Up *;
};

template <typename _Ptr, typename _Tp>
using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

template <typename _Tp> constexpr _Tp *__to_address(_Tp * __ptr) noexcept {
static_assert(!std::is_function<_Tp>::value, "not a function pointer");
return __ptr;
}

template <typename _Ptr>
constexpr typename std::pointer_traits<_Ptr>::element_type *__to_address(
const _Ptr &__ptr) {
return std::__to_address(__ptr.operator->());
}

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <typename _Iterator>
class reverse_iterator
: public iterator<typename iterator_traits<_Iterator>::iterator_category,
typename iterator_traits<_Iterator>::value_type,
typename iterator_traits<_Iterator>::difference_type,
typename iterator_traits<_Iterator>::pointer,
typename iterator_traits<_Iterator>::reference> {
template <typename _Iter> friend class reverse_iterator;

protected:
_Iterator current;

typedef iterator_traits<_Iterator> __traits_type;

public:
typedef _Iterator iterator_type;
typedef typename __traits_type::pointer pointer;

typedef typename __traits_type::difference_type difference_type;
typedef typename __traits_type::reference reference;
constexpr reverse_iterator() noexcept(noexcept(_Iterator())) : current() {}

explicit constexpr reverse_iterator(iterator_type __x) noexcept(
noexcept(_Iterator(__x)))
: current(__x) {}

constexpr reverse_iterator(const reverse_iterator &__x) noexcept(
noexcept(_Iterator(__x.current)))
: current(__x.current) {}

reverse_iterator &operator=(const reverse_iterator &) = default;

template <typename _Iter>

constexpr reverse_iterator(const reverse_iterator<_Iter> &__x) noexcept(
noexcept(_Iterator(__x.current)))
: current(__x.current) {}

template <typename _Iter>

constexpr reverse_iterator &
operator=(const reverse_iterator<_Iter> &__x) noexcept(
noexcept(current = __x.current)) {
current = __x.current;
return *this;
}

[[__nodiscard__]] constexpr iterator_type base() const
noexcept(noexcept(_Iterator(current))) {
return current;
}
[[__nodiscard__]] constexpr reference operator*() const {
_Iterator __tmp = current;
return *--__tmp;
}

[[__nodiscard__]] constexpr pointer operator->() const

{

_Iterator __tmp = current;
--__tmp;
return _S_to_pointer(__tmp);
}

constexpr reverse_iterator &operator++() {
--current;
return *this;
}

constexpr reverse_iterator operator++(int) {
reverse_iterator __tmp = *this;
--current;
return __tmp;
}

constexpr reverse_iterator &operator--() {
++current;
return *this;
}

constexpr reverse_iterator operator--(int) {
reverse_iterator __tmp = *this;
++current;
return __tmp;
}

[[__nodiscard__]] constexpr reverse_iterator
operator+(difference_type __n) const {
return reverse_iterator(current - __n);
}

constexpr reverse_iterator &operator+=(difference_type __n) {
current -= __n;
return *this;
}

[[__nodiscard__]] constexpr reverse_iterator
operator-(difference_type __n) const {
return reverse_iterator(current + __n);
}

constexpr reverse_iterator &operator-=(difference_type __n) {
current += __n;
return *this;
}

[[__nodiscard__]] constexpr reference
operator[](difference_type __n) const {
return *(*this + __n);
}

private:
template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p) {
return __p;
}

template <typename _Tp> static constexpr pointer _S_to_pointer(_Tp __t) {
return __t.operator->();
}
};
template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator==(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return __x.base() == __y.base();
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator<(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return __y.base() < __x.base();
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator!=(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return !(__x == __y);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator>(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return __y < __x;
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator<=(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return !(__y < __x);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator>=(
const reverse_iterator<_Iterator> &__x,
const reverse_iterator<_Iterator> &__y) {
return !(__x < __y);
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator==(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() == __y.base();
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator<(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() > __y.base();
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator!=(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() != __y.base();
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator>(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() < __y.base();
}

template <typename _IteratorL, typename _IteratorR>
inline constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() >= __y.base();
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator>=(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y) {
return __x.base() <= __y.base();
}
template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr auto operator-(
const reverse_iterator<_IteratorL> &__x,
const reverse_iterator<_IteratorR> &__y)
->decltype(__y.base() - __x.base()) {
return __y.base() - __x.base();
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr reverse_iterator<_Iterator> operator+(
typename reverse_iterator<_Iterator>::difference_type __n,
const reverse_iterator<_Iterator> &__x) {
return reverse_iterator<_Iterator>(__x.base() - __n);
}

template <typename _Iterator>
inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(
_Iterator __i) {
return reverse_iterator<_Iterator>(__i);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr reverse_iterator<_Iterator>
make_reverse_iterator(_Iterator __i) {
return reverse_iterator<_Iterator>(__i);
}
template <typename _Iterator>

auto __niter_base(reverse_iterator<_Iterator> __it)
->decltype(__make_reverse_iterator(__niter_base(__it.base()))) {
return __make_reverse_iterator(__niter_base(__it.base()));
}

template <typename _Iterator>
struct __is_move_iterator<reverse_iterator<_Iterator>>
: __is_move_iterator<_Iterator> {};

template <typename _Iterator>

auto __miter_base(reverse_iterator<_Iterator> __it)
->decltype(__make_reverse_iterator(__miter_base(__it.base()))) {
return __make_reverse_iterator(__miter_base(__it.base()));
}
template <typename _Container>
class back_insert_iterator
: public iterator<output_iterator_tag, void, void, void, void> {
protected:
_Container *container;

public:
typedef _Container container_type;

explicit back_insert_iterator(_Container &__x)
: container(std::__addressof(__x)) {}

back_insert_iterator &
operator=(const typename _Container::value_type &__value) {
container->push_back(__value);
return *this;
}

back_insert_iterator &operator=(typename _Container::value_type &&__value) {
container->push_back(std::move(__value));
return *this;
}

[[__nodiscard__]] back_insert_iterator &operator*() { return *this; }

back_insert_iterator &operator++() { return *this; }

back_insert_iterator operator++(int) { return *this; }
};
template <typename _Container>
[[__nodiscard__]] inline back_insert_iterator<_Container> back_inserter(
_Container & __x) {
return back_insert_iterator<_Container>(__x);
}
template <typename _Container>
class front_insert_iterator
: public iterator<output_iterator_tag, void, void, void, void> {
protected:
_Container *container;

public:
typedef _Container container_type;

explicit front_insert_iterator(_Container &__x)
: container(std::__addressof(__x)) {}

front_insert_iterator &
operator=(const typename _Container::value_type &__value) {
container->push_front(__value);
return *this;
}

front_insert_iterator &
operator=(typename _Container::value_type &&__value) {
container->push_front(std::move(__value));
return *this;
}

[[__nodiscard__]] front_insert_iterator &operator*() { return *this; }

front_insert_iterator &operator++() { return *this; }

front_insert_iterator operator++(int) { return *this; }
};
template <typename _Container>
[[__nodiscard__]] inline front_insert_iterator<_Container> front_inserter(
_Container & __x) {
return front_insert_iterator<_Container>(__x);
}
template <typename _Container>
class insert_iterator
: public iterator<output_iterator_tag, void, void, void, void> {

typedef typename _Container::iterator _Iter;

protected:
_Container *container;
_Iter iter;

public:
typedef _Container container_type;

insert_iterator(_Container &__x, _Iter __i)
: container(std::__addressof(__x)), iter(__i) {}

insert_iterator &operator=(const typename _Container::value_type &__value) {
iter = container->insert(iter, __value);
++iter;
return *this;
}

insert_iterator &operator=(typename _Container::value_type &&__value) {
iter = container->insert(iter, std::move(__value));
++iter;
return *this;
}

[[__nodiscard__]] insert_iterator &operator*() { return *this; }

insert_iterator &operator++() { return *this; }

insert_iterator &operator++(int) { return *this; }
};

#pragma GCC diagnostic pop
template <typename _Container>
[[__nodiscard__]] inline insert_iterator<_Container> inserter(
_Container & __x, typename _Container::iterator __i) {
return insert_iterator<_Container>(__x, __i);
}

} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

template <typename _Iterator, typename _Container> class __normal_iterator {
protected:
_Iterator _M_current;

typedef std::iterator_traits<_Iterator> __traits_type;

template <typename _Iter>
using __convertible_from =
std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;

public:
typedef _Iterator iterator_type;
typedef typename __traits_type::iterator_category iterator_category;
typedef typename __traits_type::value_type value_type;
typedef typename __traits_type::difference_type difference_type;
typedef typename __traits_type::reference reference;
typedef typename __traits_type::pointer pointer;

constexpr __normal_iterator() noexcept : _M_current(_Iterator()) {}

explicit __normal_iterator(const _Iterator &__i) noexcept
: _M_current(__i) {}

template <typename _Iter, typename = __convertible_from<_Iter>>

__normal_iterator(const __normal_iterator<_Iter, _Container> &__i) noexcept
: _M_current(__i.base()) {}

reference operator*() const noexcept { return *_M_current; }

pointer operator->() const noexcept { return _M_current; }

__normal_iterator &operator++() noexcept {
++_M_current;
return *this;
}

__normal_iterator operator++(int) noexcept {
return __normal_iterator(_M_current++);
}

__normal_iterator &operator--() noexcept {
--_M_current;
return *this;
}

__normal_iterator operator--(int) noexcept {
return __normal_iterator(_M_current--);
}

reference operator[](difference_type __n) const noexcept {
return _M_current[__n];
}

__normal_iterator &operator+=(difference_type __n) noexcept {
_M_current += __n;
return *this;
}

__normal_iterator operator+(difference_type __n) const noexcept {
return __normal_iterator(_M_current + __n);
}

__normal_iterator &operator-=(difference_type __n) noexcept {
_M_current -= __n;
return *this;
}

__normal_iterator operator-(difference_type __n) const noexcept {
return __normal_iterator(_M_current - __n);
}

const _Iterator &base() const noexcept { return _M_current; }
};
template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator==(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() == __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator==(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() == __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator!=(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() != __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator!=(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() != __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator<(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() < __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator<(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() < __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator>(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() > __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator>(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() > __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator<=(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() <= __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator<=(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() <= __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>
[[__nodiscard__]] inline bool operator>=(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept {
return __lhs.base() >= __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline bool operator>=(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() >= __rhs.base();
}

template <typename _IteratorL, typename _IteratorR, typename _Container>

[[__nodiscard__]] inline auto operator-(
const __normal_iterator<_IteratorL, _Container> &__lhs,
const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
-> decltype(__lhs.base() - __rhs.base())

{
return __lhs.base() - __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline
typename __normal_iterator<_Iterator, _Container>::difference_type
operator-(
const __normal_iterator<_Iterator, _Container> &__lhs,
const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
return __lhs.base() - __rhs.base();
}

template <typename _Iterator, typename _Container>
[[__nodiscard__]] inline __normal_iterator<_Iterator, _Container> operator+(
typename __normal_iterator<_Iterator, _Container>::difference_type __n,
const __normal_iterator<_Iterator, _Container> &__i) noexcept {
return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
}

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

template <typename _Iterator, typename _Container>

_Iterator __niter_base(
__gnu_cxx::__normal_iterator<_Iterator, _Container>
__it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
return __it.base();
}

template <typename _Iterator, typename _Container>
constexpr auto __to_address(
const __gnu_cxx::__normal_iterator<_Iterator, _Container> &__it) noexcept
-> decltype(std::__to_address(__it.base())) {
return std::__to_address(__it.base());
}
namespace __detail {}
template <typename _Iterator>
class move_iterator

{
_Iterator _M_current;

using __traits_type = iterator_traits<_Iterator>;

using __base_ref = typename __traits_type::reference;

template <typename _Iter2> friend class move_iterator;

public:
using iterator_type = _Iterator;
typedef typename __traits_type::iterator_category iterator_category;
typedef typename __traits_type::value_type value_type;
typedef typename __traits_type::difference_type difference_type;

typedef _Iterator pointer;

using reference =
__conditional_t<is_reference<__base_ref>::value,
typename remove_reference<__base_ref>::type &&,
__base_ref>;

constexpr move_iterator() : _M_current() {}

explicit constexpr move_iterator(iterator_type __i)
: _M_current(std::move(__i)) {}

template <typename _Iter>

constexpr move_iterator(const move_iterator<_Iter> &__i)
: _M_current(__i._M_current) {}

template <typename _Iter>

constexpr move_iterator &operator=(const move_iterator<_Iter> &__i) {
_M_current = __i._M_current;
return *this;
}

[[__nodiscard__]] constexpr iterator_type base() const {
return _M_current;
}
[[__nodiscard__]] constexpr reference operator*() const

{
return static_cast<reference>(*_M_current);
}

[[__nodiscard__]] constexpr pointer operator->() const {
return _M_current;
}

constexpr move_iterator &operator++() {
++_M_current;
return *this;
}

constexpr move_iterator operator++(int) {
move_iterator __tmp = *this;
++_M_current;
return __tmp;
}

constexpr move_iterator &operator--() {
--_M_current;
return *this;
}

constexpr move_iterator operator--(int) {
move_iterator __tmp = *this;
--_M_current;
return __tmp;
}

[[__nodiscard__]] constexpr move_iterator
operator+(difference_type __n) const {
return move_iterator(_M_current + __n);
}

constexpr move_iterator &operator+=(difference_type __n) {
_M_current += __n;
return *this;
}

[[__nodiscard__]] constexpr move_iterator
operator-(difference_type __n) const {
return move_iterator(_M_current - __n);
}

constexpr move_iterator &operator-=(difference_type __n) {
_M_current -= __n;
return *this;
}

[[__nodiscard__]] constexpr reference operator[](difference_type __n) const

{
return std::move(_M_current[__n]);
}
};

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator==(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)

{
return __x.base() == __y.base();
}
template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator!=(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y) {
return !(__x == __y);
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator<(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)

{
return __x.base() < __y.base();
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator<=(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)

{
return !(__y < __x);
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator>(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)

{
return __y < __x;
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr bool operator>=(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)

{
return !(__x < __y);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator==(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return __x.base() == __y.base();
}
template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator!=(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return !(__x == __y);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator<(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return __x.base() < __y.base();
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator<=(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return !(__y < __x);
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator>(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return __y < __x;
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr bool operator>=(
const move_iterator<_Iterator> &__x,
const move_iterator<_Iterator> &__y) {
return !(__x < __y);
}

template <typename _IteratorL, typename _IteratorR>
[[__nodiscard__]] inline constexpr auto operator-(
const move_iterator<_IteratorL> &__x,
const move_iterator<_IteratorR> &__y)
->decltype(__x.base() - __y.base()) {
return __x.base() - __y.base();
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr move_iterator<_Iterator> operator+(
typename move_iterator<_Iterator>::difference_type __n,
const move_iterator<_Iterator> &__x) {
return __x + __n;
}

template <typename _Iterator>
[[__nodiscard__]] inline constexpr move_iterator<_Iterator>
make_move_iterator(_Iterator __i) {
return move_iterator<_Iterator>(std::move(__i));
}

template <typename _Iterator,
typename _ReturnType = __conditional_t<
__move_if_noexcept_cond<
typename iterator_traits<_Iterator>::value_type>::value,
_Iterator, move_iterator<_Iterator>>>
inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i) {
return _ReturnType(__i);
}

template <typename _Tp,
typename _ReturnType =
__conditional_t<__move_if_noexcept_cond<_Tp>::value,
const _Tp *, move_iterator<_Tp *>>>
inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp * __i) {
return _ReturnType(__i);
}
template <typename _Iterator>

auto __niter_base(move_iterator<_Iterator> __it)
->decltype(make_move_iterator(__niter_base(__it.base()))) {
return make_move_iterator(__niter_base(__it.base()));
}

template <typename _Iterator>
struct __is_move_iterator<move_iterator<_Iterator>> {
enum { __value = 1 };
typedef __true_type __type;
};

template <typename _Iterator>

auto __miter_base(move_iterator<_Iterator> __it)
->decltype(__miter_base(__it.base())) {
return __miter_base(__it.base());
}
template <typename _InputIterator>
using __iter_key_t = remove_const_t<
typename iterator_traits<_InputIterator>::value_type::first_type>;

template <typename _InputIterator>
using __iter_val_t =
typename iterator_traits<_InputIterator>::value_type::second_type;

template <typename _T1, typename _T2> struct pair;

template <typename _InputIterator>
using __iter_to_alloc_t = pair<add_const_t<__iter_key_t<_InputIterator>>,
__iter_val_t<_InputIterator>>;

} // namespace std

namespace std {
namespace __debug {}
} // namespace std

namespace __gnu_debug {
using namespace std::__debug;

template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
} // namespace __gnu_debug

namespace __gnu_cxx {
namespace __ops {
struct _Iter_less_iter {
template <typename _Iterator1, typename _Iterator2>
constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
return *__it1 < *__it2;
}
};

constexpr inline _Iter_less_iter __iter_less_iter() {
return _Iter_less_iter();
}

struct _Iter_less_val {

constexpr _Iter_less_val() = default;

explicit _Iter_less_val(_Iter_less_iter) {}

template <typename _Iterator, typename _Value>

bool operator()(_Iterator __it, _Value &__val) const {
return *__it < __val;
}
};

inline _Iter_less_val __iter_less_val() { return _Iter_less_val(); }

inline _Iter_less_val __iter_comp_val(_Iter_less_iter) {
return _Iter_less_val();
}

struct _Val_less_iter {

constexpr _Val_less_iter() = default;

explicit _Val_less_iter(_Iter_less_iter) {}

template <typename _Value, typename _Iterator>

bool operator()(_Value &__val, _Iterator __it) const {
return __val < *__it;
}
};

inline _Val_less_iter __val_less_iter() { return _Val_less_iter(); }

inline _Val_less_iter __val_comp_iter(_Iter_less_iter) {
return _Val_less_iter();
}

struct _Iter_equal_to_iter {
template <typename _Iterator1, typename _Iterator2>

bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
return *__it1 == *__it2;
}
};

inline _Iter_equal_to_iter __iter_equal_to_iter() {
return _Iter_equal_to_iter();
}

struct _Iter_equal_to_val {
template <typename _Iterator, typename _Value>

bool operator()(_Iterator __it, _Value &__val) const {
return *__it == __val;
}
};

inline _Iter_equal_to_val __iter_equal_to_val() { return _Iter_equal_to_val(); }

inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) {
return _Iter_equal_to_val();
}

template <typename _Compare> struct _Iter_comp_iter {
_Compare _M_comp;

explicit constexpr _Iter_comp_iter(_Compare __comp)
: _M_comp(std::move(__comp)) {}

template <typename _Iterator1, typename _Iterator2>
constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) {
return bool(_M_comp(*__it1, *__it2));
}
};

template <typename _Compare>
constexpr inline _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp) {
return _Iter_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Compare> struct _Iter_comp_val {
_Compare _M_comp;

explicit _Iter_comp_val(_Compare __comp) : _M_comp(std::move(__comp)) {}

explicit _Iter_comp_val(const _Iter_comp_iter<_Compare> &__comp)
: _M_comp(__comp._M_comp) {}

explicit _Iter_comp_val(_Iter_comp_iter<_Compare> &&__comp)
: _M_comp(std::move(__comp._M_comp)) {}

template <typename _Iterator, typename _Value>

bool operator()(_Iterator __it, _Value &__val) {
return bool(_M_comp(*__it, __val));
}
};

template <typename _Compare>

inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp) {
return _Iter_comp_val<_Compare>(std::move(__comp));
}

template <typename _Compare>

inline _Iter_comp_val<_Compare>
__iter_comp_val(_Iter_comp_iter<_Compare> __comp) {
return _Iter_comp_val<_Compare>(std::move(__comp));
}

template <typename _Compare> struct _Val_comp_iter {
_Compare _M_comp;

explicit _Val_comp_iter(_Compare __comp) : _M_comp(std::move(__comp)) {}

explicit _Val_comp_iter(const _Iter_comp_iter<_Compare> &__comp)
: _M_comp(__comp._M_comp) {}

explicit _Val_comp_iter(_Iter_comp_iter<_Compare> &&__comp)
: _M_comp(std::move(__comp._M_comp)) {}

template <typename _Value, typename _Iterator>

bool operator()(_Value &__val, _Iterator __it) {
return bool(_M_comp(__val, *__it));
}
};

template <typename _Compare>

inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp) {
return _Val_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Compare>

inline _Val_comp_iter<_Compare>
__val_comp_iter(_Iter_comp_iter<_Compare> __comp) {
return _Val_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Value> struct _Iter_equals_val {
_Value &_M_value;

explicit _Iter_equals_val(_Value &__value) : _M_value(__value) {}

template <typename _Iterator>

bool operator()(_Iterator __it) {
return *__it == _M_value;
}
};

template <typename _Value>

inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val) {
return _Iter_equals_val<_Value>(__val);
}

template <typename _Iterator1> struct _Iter_equals_iter {
_Iterator1 _M_it1;

explicit _Iter_equals_iter(_Iterator1 __it1) : _M_it1(__it1) {}

template <typename _Iterator2>

bool operator()(_Iterator2 __it2) {
return *__it2 == *_M_it1;
}
};

template <typename _Iterator>

inline _Iter_equals_iter<_Iterator> __iter_comp_iter(_Iter_equal_to_iter,
_Iterator __it) {
return _Iter_equals_iter<_Iterator>(__it);
}

template <typename _Predicate> struct _Iter_pred {
_Predicate _M_pred;

explicit _Iter_pred(_Predicate __pred) : _M_pred(std::move(__pred)) {}

template <typename _Iterator>

bool operator()(_Iterator __it) {
return bool(_M_pred(*__it));
}
};

template <typename _Predicate>

inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred) {
return _Iter_pred<_Predicate>(std::move(__pred));
}

template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
_Compare _M_comp;
_Value &_M_value;

_Iter_comp_to_val(_Compare __comp, _Value &__value)
: _M_comp(std::move(__comp)), _M_value(__value) {}

template <typename _Iterator>

bool operator()(_Iterator __it) {
return bool(_M_comp(*__it, _M_value));
}
};

template <typename _Compare, typename _Value>
_Iter_comp_to_val<_Compare, _Value>

__iter_comp_val(_Compare __comp, _Value &__val) {
return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
}

template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
_Compare _M_comp;
_Iterator1 _M_it1;

_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
: _M_comp(std::move(__comp)), _M_it1(__it1) {}

template <typename _Iterator2>

bool operator()(_Iterator2 __it2) {
return bool(_M_comp(*__it2, *_M_it1));
}
};

template <typename _Compare, typename _Iterator>

inline _Iter_comp_to_iter<_Compare, _Iterator>
__iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it) {
return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp),
__it);
}

template <typename _Predicate> struct _Iter_negate {
_Predicate _M_pred;

explicit _Iter_negate(_Predicate __pred) : _M_pred(std::move(__pred)) {}

template <typename _Iterator>

bool operator()(_Iterator __it) {
return !bool(_M_pred(*__it));
}
};

template <typename _Predicate>

inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred) {
return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
}

} // namespace __ops
} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp, typename _Up>
constexpr inline int __memcmp(const _Tp *__first1, const _Up *__first2,
size_t __num) {

static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) {

swap(*__a, *__b);
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

_ForwardIterator2 swap_ranges(_ForwardIterator1 __first1,
_ForwardIterator1 __last1,
_ForwardIterator2 __first2) {

;

for (; __first1 != __last1; ++__first1, (void)++__first2)
std::iter_swap(__first1, __first2);
return __first2;
}
template <typename _Tp>
constexpr inline const _Tp &min(const _Tp &__a, const _Tp &__b) {

if (__b < __a)
return __b;
return __a;
}
template <typename _Tp>
constexpr inline const _Tp &max(const _Tp &__a, const _Tp &__b) {

if (__a < __b)
return __b;
return __a;
}
template <typename _Tp, typename _Compare>
constexpr inline const _Tp &min(const _Tp &__a, const _Tp &__b,
_Compare __comp) {

if (__comp(__b, __a))
return __b;
return __a;
}
template <typename _Tp, typename _Compare>
constexpr inline const _Tp &max(const _Tp &__a, const _Tp &__b,
_Compare __comp) {

if (__comp(__a, __b))
return __b;
return __a;
}

template <typename _Iterator>

inline _Iterator __niter_base(_Iterator __it) noexcept(
std::is_nothrow_copy_constructible<_Iterator>::value) {
return __it;
}

template <typename _Ite, typename _Seq>
_Ite __niter_base(
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
std::random_access_iterator_tag> &);

template <typename _From, typename _To>

inline _From __niter_wrap(_From __from, _To __res) {
return __from + (__res - std::__niter_base(__from));
}

template <typename _Iterator>

inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res) {
return __res;
}

template <bool _IsMove, bool _IsSimple, typename _Category>
struct __copy_move {
template <typename _II, typename _OI>

static _OI __copy_m(_II __first, _II __last, _OI __result) {
for (; __first != __last; ++__result, (void)++__first)
*__result = *__first;
return __result;
}
};

template <typename _Category> struct __copy_move<true, false, _Category> {
template <typename _II, typename _OI>

static _OI __copy_m(_II __first, _II __last, _OI __result) {
for (; __first != __last; ++__result, (void)++__first)
*__result = std::move(*__first);
return __result;
}
};

template <> struct __copy_move<false, false, random_access_iterator_tag> {
template <typename _II, typename _OI>

static _OI __copy_m(_II __first, _II __last, _OI __result) {
typedef typename iterator_traits<_II>::difference_type _Distance;
for (_Distance __n = __last - __first; __n > 0; --__n) {
*__result = *__first;
++__first;
++__result;
}
return __result;
}
};

template <> struct __copy_move<true, false, random_access_iterator_tag> {
template <typename _II, typename _OI>

static _OI __copy_m(_II __first, _II __last, _OI __result) {
typedef typename iterator_traits<_II>::difference_type _Distance;
for (_Distance __n = __last - __first; __n > 0; --__n) {
*__result = std::move(*__first);
++__first;
++__result;
}
return __result;
}
};

template <bool _IsMove>
struct __copy_move<_IsMove, true, random_access_iterator_tag> {
template <typename _Tp>

static _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result) {

using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>,
is_copy_assignable<_Tp>>;

static_assert(__assignable::value, "type must be assignable");

const ptrdiff_t _Num = __last - __first;
if (_Num)
__builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
return __result + _Num;
}
};

template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;

struct _Bit_iterator;

template <typename _CharT> struct char_traits;

template <typename _CharT, typename _Traits> class istreambuf_iterator;

template <typename _CharT, typename _Traits> class ostreambuf_iterator;

template <bool _IsMove, typename _CharT>
typename __gnu_cxx::__enable_if<
__is_char<_CharT>::__value,
ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
__copy_move_a2(_CharT *, _CharT *,
ostreambuf_iterator<_CharT, char_traits<_CharT>>);

template <bool _IsMove, typename _CharT>
typename __gnu_cxx::__enable_if<
__is_char<_CharT>::__value,
ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
__copy_move_a2(const _CharT *, const _CharT *,
ostreambuf_iterator<_CharT, char_traits<_CharT>>);

template <bool _IsMove, typename _CharT>
typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
__copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);

template <bool _IsMove, typename _CharT>
typename __gnu_cxx::__enable_if<
__is_char<_CharT>::__value,
std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
__copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
istreambuf_iterator<_CharT, char_traits<_CharT>>,
std::_Deque_iterator<_CharT, _CharT &, _CharT *>);

template <bool _IsMove, typename _II, typename _OI>

inline _OI __copy_move_a2(_II __first, _II __last, _OI __result) {
typedef typename iterator_traits<_II>::iterator_category _Category;

return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
_Category>::__copy_m(__first, __last, __result);
}

template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr,
typename _OI>
_OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);

template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr,
typename _OTp>
std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(
std::_Deque_iterator<_ITp, _IRef, _IPtr>,
std::_Deque_iterator<_ITp, _IRef, _IPtr>,
std::_Deque_iterator<_OTp, _OTp &, _OTp *>);

template <bool _IsMove, typename _II, typename _Tp>
typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::
__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);

template <bool _IsMove, typename _II, typename _OI>

inline _OI __copy_move_a1(_II __first, _II __last, _OI __result) {
return std::__copy_move_a2<_IsMove>(__first, __last, __result);
}

template <bool _IsMove, typename _II, typename _OI>

inline _OI __copy_move_a(_II __first, _II __last, _OI __result) {
return std::__niter_wrap(
__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
std::__niter_base(__last),
std::__niter_base(__result)));
}

template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat,
typename _OI>
_OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
_OI);

template <bool _IsMove, typename _II, typename _Ite, typename _Seq,
typename _Cat>
__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(
_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);

template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat,
typename _OIte, typename _OSeq, typename _OCat>
::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(
const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);

template <typename _InputIterator, typename _Size, typename _OutputIterator>

_OutputIterator __copy_n_a(_InputIterator __first, _Size __n,
_OutputIterator __result, bool) {
if (__n > 0) {
while (true) {
*__result = *__first;
++__result;
if (--__n > 0)
++__first;
else
break;
}
}
return __result;
}

template <typename _CharT, typename _Size>
typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
__copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, _CharT *,
bool);

template <typename _CharT, typename _Size>
typename __gnu_cxx::__enable_if<
__is_char<_CharT>::__value,
std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
__copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size,
std::_Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
template <typename _II, typename _OI>

inline _OI copy(_II __first, _II __last, _OI __result) {

;

return std::__copy_move_a<__is_move_iterator<_II>::__value>(
std::__miter_base(__first), std::__miter_base(__last), __result);
}
template <typename _II, typename _OI>

inline _OI move(_II __first, _II __last, _OI __result) {

;

return std::__copy_move_a<true>(std::__miter_base(__first),
std::__miter_base(__last), __result);
}

template <bool _IsMove, bool _IsSimple, typename _Category>
struct __copy_move_backward {
template <typename _BI1, typename _BI2>

static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
while (__first != __last)
*--__result = *--__last;
return __result;
}
};

template <typename _Category>
struct __copy_move_backward<true, false, _Category> {
template <typename _BI1, typename _BI2>

static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
while (__first != __last)
*--__result = std::move(*--__last);
return __result;
}
};

template <>
struct __copy_move_backward<false, false, random_access_iterator_tag> {
template <typename _BI1, typename _BI2>

static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
typename iterator_traits<_BI1>::difference_type __n = __last - __first;
for (; __n > 0; --__n)
*--__result = *--__last;
return __result;
}
};

template <>
struct __copy_move_backward<true, false, random_access_iterator_tag> {
template <typename _BI1, typename _BI2>

static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) {
typename iterator_traits<_BI1>::difference_type __n = __last - __first;
for (; __n > 0; --__n)
*--__result = std::move(*--__last);
return __result;
}
};

template <bool _IsMove>
struct __copy_move_backward<_IsMove, true, random_access_iterator_tag> {
template <typename _Tp>

static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last,
_Tp *__result) {

using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>,
is_copy_assignable<_Tp>>;

static_assert(__assignable::value, "type must be assignable");

const ptrdiff_t _Num = __last - __first;
if (_Num)
__builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
return __result - _Num;
}
};

template <bool _IsMove, typename _BI1, typename _BI2>

inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last,
_BI2 __result) {
typedef typename iterator_traits<_BI1>::iterator_category _Category;

return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value,
_Category>::__copy_move_b(__first, __last,
__result);
}

template <bool _IsMove, typename _BI1, typename _BI2>

inline _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last,
_BI2 __result) {
return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
}

template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr,
typename _OI>
_OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);

template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr,
typename _OTp>
std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(
std::_Deque_iterator<_ITp, _IRef, _IPtr>,
std::_Deque_iterator<_ITp, _IRef, _IPtr>,
std::_Deque_iterator<_OTp, _OTp &, _OTp *>);

template <bool _IsMove, typename _II, typename _Tp>
typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::
__type __copy_move_backward_a1(_II, _II,
std::_Deque_iterator<_Tp, _Tp &, _Tp *>);

template <bool _IsMove, typename _II, typename _OI>

inline _OI __copy_move_backward_a(_II __first, _II __last, _OI __result) {
return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(
std::__niter_base(__first),
std::__niter_base(__last),
std::__niter_base(__result)));
}

template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat,
typename _OI>
_OI __copy_move_backward_a(
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);

template <bool _IsMove, typename _II, typename _Ite, typename _Seq,
typename _Cat>
__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(
_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);

template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat,
typename _OIte, typename _OSeq, typename _OCat>
::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(
const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
template <typename _BI1, typename _BI2>

inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {

;

return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(
std::__miter_base(__first), std::__miter_base(__last), __result);
}
template <typename _BI1, typename _BI2>

inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result) {

;

return std::__copy_move_backward_a<true>(
std::__miter_base(__first), std::__miter_base(__last), __result);
}

template <typename _ForwardIterator, typename _Tp>

inline
typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
__fill_a1(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__value) {
for (; __first != __last; ++__first)
*__first = __value;
}

template <typename _ForwardIterator, typename _Tp>

inline
typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
__fill_a1(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__value) {
const _Tp __tmp = __value;
for (; __first != __last; ++__first)
*__first = __tmp;
}

template <typename _Tp>

inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
__fill_a1(_Tp * __first, _Tp * __last, const _Tp &__c) {
const _Tp __tmp = __c;
if (const size_t __len = __last - __first)
__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
}

template <typename _Ite, typename _Cont, typename _Tp>

inline void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
const _Tp &__value) {
std::__fill_a1(__first.base(), __last.base(), __value);
}

template <typename _Tp, typename _VTp>
void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &,
const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);

void __fill_a1(std::_Bit_iterator, std::_Bit_iterator, const bool &);

template <typename _FIte, typename _Tp>

inline void __fill_a(_FIte __first, _FIte __last, const _Tp &__value) {
std::__fill_a1(__first, __last, __value);
}

template <typename _Ite, typename _Seq, typename _Cat, typename _Tp>
void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
const _Tp &);
template <typename _ForwardIterator, typename _Tp>

inline void fill(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__value) {

;

std::__fill_a(__first, __last, __value);
}

inline constexpr int __size_to_integer(int __n) { return __n; }
inline constexpr unsigned __size_to_integer(unsigned __n) { return __n; }
inline constexpr long __size_to_integer(long __n) { return __n; }
inline constexpr unsigned long __size_to_integer(unsigned long __n) {
return __n;
}
inline constexpr long long __size_to_integer(long long __n) { return __n; }
inline constexpr unsigned long long __size_to_integer(
unsigned long long __n) {
return __n;
}

__extension__ inline constexpr __int128 __size_to_integer(__int128 __n) {
return __n;
}
__extension__ inline constexpr unsigned __int128 __size_to_integer(
unsigned __int128 __n) {
return __n;
}
inline constexpr long long __size_to_integer(float __n) {
return (long long)__n;
}
inline constexpr long long __size_to_integer(double __n) {
return (long long)__n;
}
inline constexpr long long __size_to_integer(long double __n) {
return (long long)__n;
}

__extension__ inline constexpr long long __size_to_integer(__float128 __n) {
return (long long)__n;
}

template <typename _OutputIterator, typename _Size, typename _Tp>

inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value,
_OutputIterator>::__type
__fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
for (; __n > 0; --__n, (void)++__first)
*__first = __value;
return __first;
}

template <typename _OutputIterator, typename _Size, typename _Tp>

inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value,
_OutputIterator>::__type
__fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
const _Tp __tmp = __value;
for (; __n > 0; --__n, (void)++__first)
*__first = __tmp;
return __first;
}

template <typename _Ite, typename _Seq, typename _Cat, typename _Size,
typename _Tp>
::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(
const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n,
const _Tp &__value, std::input_iterator_tag);

template <typename _OutputIterator, typename _Size, typename _Tp>

inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
const _Tp &__value,
std::output_iterator_tag) {

static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

return __fill_n_a1(__first, __n, __value);
}

template <typename _OutputIterator, typename _Size, typename _Tp>

inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
const _Tp &__value,
std::input_iterator_tag) {

static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

return __fill_n_a1(__first, __n, __value);
}

template <typename _OutputIterator, typename _Size, typename _Tp>

inline _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n,
const _Tp &__value,
std::random_access_iterator_tag) {

static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

if (__n <= 0)
return __first;

;

std::__fill_a(__first, __first + __n, __value);
return __first + __n;
}
template <typename _OI, typename _Size, typename _Tp>

inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value) {

return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
std::__iterator_category(__first));
}

template <bool _BoolType> struct __equal {
template <typename _II1, typename _II2>

static bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
for (; __first1 != __last1; ++__first1, (void)++__first2)
if (!(*__first1 == *__first2))
return false;
return true;
}
};

template <> struct __equal<true> {
template <typename _Tp>

static bool equal(const _Tp *__first1, const _Tp *__last1,
const _Tp *__first2) {
if (const size_t __len = (__last1 - __first1))
return !std::__memcmp(__first1, __first2, __len);
return true;
}
};

template <typename _Tp, typename _Ref, typename _Ptr, typename _II>
typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
bool>::__type
__equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);

template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2,
typename _Ref2, typename _Ptr2>
bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

template <typename _II, typename _Tp, typename _Ref, typename _Ptr>
typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
bool>::__type
__equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);

template <typename _II1, typename _II2>

inline bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2) {
typedef typename iterator_traits<_II1>::value_type _ValueType1;
const bool __simple = ((__is_integer<_ValueType1>::__value ||
__is_pointer<_ValueType1>::__value) &&
__memcmpable<_II1, _II2>::__value);
return std::__equal<__simple>::equal(__first1, __last1, __first2);
}

template <typename _II1, typename _II2>

inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) {
return std::__equal_aux1(std::__niter_base(__first1),
std::__niter_base(__last1),
std::__niter_base(__first2));
}

template <typename _II1, typename _Seq1, typename _Cat1, typename _II2>
bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
_II2);

template <typename _II1, typename _II2, typename _Seq2, typename _Cat2>
bool __equal_aux(_II1, _II1,
const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);

template <typename _II1, typename _Seq1, typename _Cat1, typename _II2,
typename _Seq2, typename _Cat2>
bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);

template <typename, typename> struct __lc_rai {
template <typename _II1, typename _II2>

static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2) {
return __last1;
}

template <typename _II>

static bool __cnd2(_II __first, _II __last) {
return __first != __last;
}
};

template <>
struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag> {
template <typename _RAI1, typename _RAI2>

static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2,
_RAI2 __last2) {
const typename iterator_traits<_RAI1>::difference_type __diff1 =
__last1 - __first1;
const typename iterator_traits<_RAI2>::difference_type __diff2 =
__last2 - __first2;
return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
}

template <typename _RAI> static bool __cnd2(_RAI, _RAI) { return true; }
};

template <typename _II1, typename _II2, typename _Compare>

bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
_II2 __first2, _II2 __last2,
_Compare __comp) {
typedef typename iterator_traits<_II1>::iterator_category _Category1;
typedef typename iterator_traits<_II2>::iterator_category _Category2;
typedef std::__lc_rai<_Category1, _Category2> __rai_type;

__last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
++__first1, (void)++__first2) {
if (__comp(__first1, __first2))
return true;
if (__comp(__first2, __first1))
return false;
}
return __first1 == __last1 && __first2 != __last2;
}

template <bool _BoolType> struct __lexicographical_compare {
template <typename _II1, typename _II2>

static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
using __gnu_cxx::__ops::__iter_less_iter;
return std::__lexicographical_compare_impl(__first1, __last1, __first2,
__last2, __iter_less_iter());
}

template <typename _II1, typename _II2>

static int __3way(_II1 __first1, _II1 __last1, _II2 __first2,
_II2 __last2) {
while (__first1 != __last1) {
if (__first2 == __last2)
return +1;
if (*__first1 < *__first2)
return -1;
if (*__first2 < *__first1)
return +1;
++__first1;
++__first2;
}
return int(__first2 == __last2) - 1;
}
};

template <> struct __lexicographical_compare<true> {
template <typename _Tp, typename _Up>

static bool __lc(const _Tp *__first1, const _Tp *__last1,
const _Up *__first2, const _Up *__last2) {
return __3way(__first1, __last1, __first2, __last2) < 0;
}

template <typename _Tp, typename _Up>

static ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1,
const _Up *__first2, const _Up *__last2) {
const size_t __len1 = __last1 - __first1;
const size_t __len2 = __last2 - __first2;
if (const size_t __len = std::min(__len1, __len2))
if (int __result = std::__memcmp(__first1, __first2, __len))
return __result;
return ptrdiff_t(__len1 - __len2);
}
};

template <typename _II1, typename _II2>

inline bool __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
_II2 __first2, _II2 __last2) {
typedef typename iterator_traits<_II1>::value_type _ValueType1;
typedef typename iterator_traits<_II2>::value_type _ValueType2;
const bool __simple =
(__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value &&
__is_pointer<_II1>::__value && __is_pointer<_II2>::__value

);

return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
__first2, __last2);
}

template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2>
bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
_Tp2 *, _Tp2 *);

template <typename _Tp1, typename _Tp2, typename _Ref2, typename _Ptr2>
bool __lexicographical_compare_aux1(_Tp1 *, _Tp1 *,
std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2,
typename _Ref2, typename _Ptr2>
bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

template <typename _II1, typename _II2>

inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
_II2 __first2, _II2 __last2) {
return std::__lexicographical_compare_aux1(
std::__niter_base(__first1), std::__niter_base(__last1),
std::__niter_base(__first2), std::__niter_base(__last2));
}

template <typename _Iter1, typename _Seq1, typename _Cat1, typename _II2>
bool __lexicographical_compare_aux(
const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2, _II2);

template <typename _II1, typename _Iter2, typename _Seq2, typename _Cat2>
bool __lexicographical_compare_aux(
_II1, _II1, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);

template <typename _Iter1, typename _Seq1, typename _Cat1, typename _Iter2,
typename _Seq2, typename _Cat2>
bool __lexicographical_compare_aux(
const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);

template <typename _ForwardIterator, typename _Tp, typename _Compare>

_ForwardIterator __lower_bound(_ForwardIterator __first,
_ForwardIterator __last, const _Tp &__val,
_Compare __comp) {
typedef typename iterator_traits<_ForwardIterator>::difference_type
_DistanceType;

_DistanceType __len = std::distance(__first, __last);

while (__len > 0) {
_DistanceType __half = __len >> 1;
_ForwardIterator __middle = __first;
std::advance(__middle, __half);
if (__comp(__middle, __val)) {
__first = __middle;
++__first;
__len = __len - __half - 1;
} else
__len = __half;
}
return __first;
}
template <typename _ForwardIterator, typename _Tp>

inline _ForwardIterator lower_bound(
_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

;

return std::__lower_bound(__first, __last, __val,
__gnu_cxx::__ops::__iter_less_val());
}

inline constexpr int __lg(int __n) {
return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
}

inline constexpr unsigned __lg(unsigned __n) {
return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
}

inline constexpr long __lg(long __n) {
return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
}

inline constexpr unsigned long __lg(unsigned long __n) {
return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
}

inline constexpr long long __lg(long long __n) {
return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
}

inline constexpr unsigned long long __lg(unsigned long long __n) {
return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
}

template <typename _II1, typename _II2>

inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {

;

return std::__equal_aux(__first1, __last1, __first2);
}
template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>

inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2,
_BinaryPredicate __binary_pred) {

;

for (; __first1 != __last1; ++__first1, (void)++__first2)
if (!bool(__binary_pred(*__first1, *__first2)))
return false;
return true;
}

template <typename _II1, typename _II2>

inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2,
_II2 __last2) {
using _RATag = random_access_iterator_tag;
using _Cat1 = typename iterator_traits<_II1>::iterator_category;
using _Cat2 = typename iterator_traits<_II2>::iterator_category;
using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
if (_RAIters()) {
auto __d1 = std::distance(__first1, __last1);
auto __d2 = std::distance(__first2, __last2);
if (__d1 != __d2)
return false;
return std::equal(__first1, __last1, __first2);
}

for (; __first1 != __last1 && __first2 != __last2;
++__first1, (void)++__first2)
if (!(*__first1 == *__first2))
return false;
return __first1 == __last1 && __first2 == __last2;
}

template <typename _II1, typename _II2, typename _BinaryPredicate>

inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
_BinaryPredicate __binary_pred) {
using _RATag = random_access_iterator_tag;
using _Cat1 = typename iterator_traits<_II1>::iterator_category;
using _Cat2 = typename iterator_traits<_II2>::iterator_category;
using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
if (_RAIters()) {
auto __d1 = std::distance(__first1, __last1);
auto __d2 = std::distance(__first2, __last2);
if (__d1 != __d2)
return false;
return std::equal(__first1, __last1, __first2, __binary_pred);
}

for (; __first1 != __last1 && __first2 != __last2;
++__first1, (void)++__first2)
if (!bool(__binary_pred(*__first1, *__first2)))
return false;
return __first1 == __last1 && __first2 == __last2;
}
template <typename _II1, typename _II2>

inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {

;
;

return std::__equal4(__first1, __last1, __first2, __last2);
}
template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>

inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2,
_IIter2 __last2, _BinaryPredicate __binary_pred) {

;
;

return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
}
template <typename _II1, typename _II2>

inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
_II2 __first2, _II2 __last2) {

;
;

return std::__lexicographical_compare_aux(__first1, __last1, __first2,
__last2);
}
template <typename _II1, typename _II2, typename _Compare>

inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
_II2 __first2, _II2 __last2,
_Compare __comp) {

;
;

return std::__lexicographical_compare_impl(
__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _InputIterator1, typename _InputIterator2,
typename _BinaryPredicate>

pair<_InputIterator1, _InputIterator2> __mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _BinaryPredicate __binary_pred) {
while (__first1 != __last1 && __binary_pred(__first1, __first2)) {
++__first1;
++__first2;
}
return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}
template <typename _InputIterator1, typename _InputIterator2>

inline pair<_InputIterator1, _InputIterator2> mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2) {

;

return std::__mismatch(__first1, __last1, __first2,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _BinaryPredicate>

inline pair<_InputIterator1, _InputIterator2> mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _BinaryPredicate __binary_pred) {

;

return std::__mismatch(__first1, __last1, __first2,
__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _BinaryPredicate>

pair<_InputIterator1, _InputIterator2> __mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_BinaryPredicate __binary_pred) {
while (__first1 != __last1 && __first2 != __last2 &&
__binary_pred(__first1, __first2)) {
++__first1;
++__first2;
}
return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}
template <typename _InputIterator1, typename _InputIterator2>

inline pair<_InputIterator1, _InputIterator2> mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2) {

;
;

return std::__mismatch(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _BinaryPredicate>

inline pair<_InputIterator1, _InputIterator2> mismatch(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_BinaryPredicate __binary_pred) {

;
;

return std::__mismatch(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
}

template <typename _InputIterator, typename _Predicate>

inline _InputIterator __find_if(_InputIterator __first, _InputIterator __last,
_Predicate __pred, input_iterator_tag) {
while (__first != __last && !__pred(__first))
++__first;
return __first;
}

template <typename _RandomAccessIterator, typename _Predicate>

_RandomAccessIterator __find_if(
_RandomAccessIterator __first, _RandomAccessIterator __last,
_Predicate __pred, random_access_iterator_tag) {
typename iterator_traits<_RandomAccessIterator>::difference_type
__trip_count = (__last - __first) >> 2;

for (; __trip_count > 0; --__trip_count) {
if (__pred(__first))
return __first;
++__first;

if (__pred(__first))
return __first;
++__first;

if (__pred(__first))
return __first;
++__first;

if (__pred(__first))
return __first;
++__first;
}

switch (__last - __first) {
case 3:
if (__pred(__first))
return __first;
++__first;

case 2:
if (__pred(__first))
return __first;
++__first;

case 1:
if (__pred(__first))
return __first;
++__first;

case 0:
default:
return __last;
}
}

template <typename _Iterator, typename _Predicate>

inline _Iterator __find_if(_Iterator __first, _Iterator __last,
_Predicate __pred) {
return __find_if(__first, __last, __pred,
std::__iterator_category(__first));
}

template <typename _InputIterator, typename _Predicate>

typename iterator_traits<_InputIterator>::difference_type __count_if(
_InputIterator __first, _InputIterator __last, _Predicate __pred) {
typename iterator_traits<_InputIterator>::difference_type __n = 0;
for (; __first != __last; ++__first)
if (__pred(__first))
++__n;
return __n;
}

template <typename _ForwardIterator, typename _Predicate>

_ForwardIterator __remove_if(_ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred) {
__first = std::__find_if(__first, __last, __pred);
if (__first == __last)
return __first;
_ForwardIterator __result = __first;
++__first;
for (; __first != __last; ++__first)
if (!__pred(__first)) {
*__result = std::move(*__first);
++__result;
}
return __result;
}

template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _BinaryPredicate __pred) {

for (; __first1 != __last1; ++__first1, (void)++__first2)
if (!__pred(__first1, __first2))
break;

if (__first1 == __last1)
return true;

_ForwardIterator2 __last2 = __first2;
std::advance(__last2, std::distance(__first1, __last1));
for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
if (__scan !=
std::__find_if(__first1, __scan,
__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
continue;

auto __matches =
std::__count_if(__first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
if (0 == __matches || std::__count_if(__scan, __last1,
__gnu_cxx::__ops::__iter_comp_iter(
__pred, __scan)) != __matches)
return false;
}
return true;
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

inline bool is_permutation(_ForwardIterator1 __first1,
_ForwardIterator1 __last1,
_ForwardIterator2 __first2) {

;

return std::__is_permutation(__first1, __last1, __first2,
__gnu_cxx::__ops::__iter_equal_to_iter());
}

} // namespace std

#pragma GCC visibility push(default)

namespace std {

template <class _E> class initializer_list {
public:
typedef _E value_type;
typedef const _E &reference;
typedef const _E &const_reference;
typedef size_t size_type;
typedef const _E *iterator;
typedef const _E *const_iterator;

private:
iterator _M_array;
size_type _M_len;

constexpr initializer_list(const_iterator __a, size_type __l)
: _M_array(__a), _M_len(__l) {}

public:
constexpr initializer_list() noexcept : _M_array(0), _M_len(0) {}

constexpr size_type size() const noexcept { return _M_len; }

constexpr const_iterator begin() const noexcept { return _M_array; }

constexpr const_iterator end() const noexcept { return begin() + size(); }
};

template <class _Tp>
constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept {
return __ils.begin();
}

template <class _Tp>
constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept {
return __ils.end();
}
} // namespace std

#pragma GCC visibility pop

namespace std __attribute__((__visibility__("default"))) {

template <typename _IIter, typename _Predicate>

bool all_of(_IIter, _IIter, _Predicate);

template <typename _IIter, typename _Predicate>

bool any_of(_IIter, _IIter, _Predicate);

template <typename _FIter, typename _Tp>

bool binary_search(_FIter, _FIter, const _Tp &);

template <typename _FIter, typename _Tp, typename _Compare>

bool binary_search(_FIter, _FIter, const _Tp &, _Compare);

template <typename _Tp>
constexpr const _Tp &clamp(const _Tp &, const _Tp &, const _Tp &);

template <typename _Tp, typename _Compare>
constexpr const _Tp &clamp(const _Tp &, const _Tp &, const _Tp &, _Compare);

template <typename _IIter, typename _OIter>

_OIter copy(_IIter, _IIter, _OIter);

template <typename _BIter1, typename _BIter2>

_BIter2 copy_backward(_BIter1, _BIter1, _BIter2);

template <typename _IIter, typename _OIter, typename _Predicate>

_OIter copy_if(_IIter, _IIter, _OIter, _Predicate);

template <typename _IIter, typename _Size, typename _OIter>

_OIter copy_n(_IIter, _Size, _OIter);

template <typename _FIter, typename _Tp>

pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &);

template <typename _FIter, typename _Tp, typename _Compare>

pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &, _Compare);

template <typename _FIter, typename _Tp>

void fill(_FIter, _FIter, const _Tp &);

template <typename _OIter, typename _Size, typename _Tp>

_OIter fill_n(_OIter, _Size, const _Tp &);

template <typename _FIter1, typename _FIter2>

_FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2);

template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>

_FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

template <typename _IIter, typename _Predicate>

_IIter find_if_not(_IIter, _IIter, _Predicate);

template <typename _IIter1, typename _IIter2>

bool includes(_IIter1, _IIter1, _IIter2, _IIter2);

template <typename _IIter1, typename _IIter2, typename _Compare>

bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

template <typename _BIter> void inplace_merge(_BIter, _BIter, _BIter);

template <typename _BIter, typename _Compare>
void inplace_merge(_BIter, _BIter, _BIter, _Compare);

template <typename _RAIter>

bool is_heap(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

bool is_heap(_RAIter, _RAIter, _Compare);

template <typename _RAIter>

_RAIter is_heap_until(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

_RAIter is_heap_until(_RAIter, _RAIter, _Compare);

template <typename _IIter, typename _Predicate>

bool is_partitioned(_IIter, _IIter, _Predicate);

template <typename _FIter1, typename _FIter2>

bool is_permutation(_FIter1, _FIter1, _FIter2);

template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>

bool is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

template <typename _FIter>

bool is_sorted(_FIter, _FIter);

template <typename _FIter, typename _Compare>

bool is_sorted(_FIter, _FIter, _Compare);

template <typename _FIter>

_FIter is_sorted_until(_FIter, _FIter);

template <typename _FIter, typename _Compare>

_FIter is_sorted_until(_FIter, _FIter, _Compare);

template <typename _FIter1, typename _FIter2>

void iter_swap(_FIter1, _FIter2);

template <typename _FIter, typename _Tp>

_FIter lower_bound(_FIter, _FIter, const _Tp &);

template <typename _FIter, typename _Tp, typename _Compare>

_FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare);

template <typename _RAIter>

void make_heap(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void make_heap(_RAIter, _RAIter, _Compare);

template <typename _Tp> constexpr const _Tp &max(const _Tp &, const _Tp &);

template <typename _Tp, typename _Compare>
constexpr const _Tp &max(const _Tp &, const _Tp &, _Compare);

template <typename _Tp> constexpr const _Tp &min(const _Tp &, const _Tp &);

template <typename _Tp, typename _Compare>
constexpr const _Tp &min(const _Tp &, const _Tp &, _Compare);

template <typename _Tp>
constexpr pair<const _Tp &, const _Tp &> minmax(const _Tp &, const _Tp &);

template <typename _Tp, typename _Compare>
constexpr pair<const _Tp &, const _Tp &> minmax(const _Tp &, const _Tp &,
_Compare);

template <typename _FIter>
constexpr pair<_FIter, _FIter> minmax_element(_FIter, _FIter);

template <typename _FIter, typename _Compare>
constexpr pair<_FIter, _FIter> minmax_element(_FIter, _FIter, _Compare);

template <typename _Tp> constexpr _Tp min(initializer_list<_Tp>);

template <typename _Tp, typename _Compare>
constexpr _Tp min(initializer_list<_Tp>, _Compare);

template <typename _Tp> constexpr _Tp max(initializer_list<_Tp>);

template <typename _Tp, typename _Compare>
constexpr _Tp max(initializer_list<_Tp>, _Compare);

template <typename _Tp>
constexpr pair<_Tp, _Tp> minmax(initializer_list<_Tp>);

template <typename _Tp, typename _Compare>
constexpr pair<_Tp, _Tp> minmax(initializer_list<_Tp>, _Compare);

template <typename _BIter>

bool next_permutation(_BIter, _BIter);

template <typename _BIter, typename _Compare>

bool next_permutation(_BIter, _BIter, _Compare);

template <typename _IIter, typename _Predicate>

bool none_of(_IIter, _IIter, _Predicate);

template <typename _IIter, typename _RAIter>

_RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

template <typename _IIter, typename _RAIter, typename _Compare>

_RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);

template <typename _IIter, typename _OIter1, typename _OIter2,
typename _Predicate>

pair<_OIter1, _OIter2> partition_copy(_IIter, _IIter, _OIter1, _OIter2,
_Predicate);

template <typename _FIter, typename _Predicate>

_FIter partition_point(_FIter, _FIter, _Predicate);

template <typename _RAIter>

void pop_heap(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void pop_heap(_RAIter, _RAIter, _Compare);

template <typename _BIter>

bool prev_permutation(_BIter, _BIter);

template <typename _BIter, typename _Compare>

bool prev_permutation(_BIter, _BIter, _Compare);

template <typename _RAIter>

void push_heap(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void push_heap(_RAIter, _RAIter, _Compare);

template <typename _FIter, typename _Tp>

_FIter remove(_FIter, _FIter, const _Tp &);

template <typename _FIter, typename _Predicate>

_FIter remove_if(_FIter, _FIter, _Predicate);

template <typename _IIter, typename _OIter, typename _Tp>

_OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &);

template <typename _IIter, typename _OIter, typename _Predicate>

_OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate);

template <typename _IIter, typename _OIter, typename _Tp>

_OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &, const _Tp &);

template <typename _Iter, typename _OIter, typename _Predicate, typename _Tp>

_OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp &);

template <typename _BIter>

void reverse(_BIter, _BIter);

template <typename _BIter, typename _OIter>

_OIter reverse_copy(_BIter, _BIter, _OIter);

inline namespace _V2 {
template <typename _FIter>

_FIter rotate(_FIter, _FIter, _FIter);
}

template <typename _FIter, typename _OIter>

_OIter rotate_copy(_FIter, _FIter, _FIter, _OIter);
template <typename _RAIter, typename _UGenerator>
void shuffle(_RAIter, _RAIter, _UGenerator &&);

template <typename _RAIter>

void sort_heap(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void sort_heap(_RAIter, _RAIter, _Compare);

template <typename _BIter, typename _Predicate>
_BIter stable_partition(_BIter, _BIter, _Predicate);
template <typename _FIter1, typename _FIter2>

_FIter2 swap_ranges(_FIter1, _FIter1, _FIter2);

template <typename _FIter>

_FIter unique(_FIter, _FIter);

template <typename _FIter, typename _BinaryPredicate>

_FIter unique(_FIter, _FIter, _BinaryPredicate);

template <typename _FIter, typename _Tp>

_FIter upper_bound(_FIter, _FIter, const _Tp &);

template <typename _FIter, typename _Tp, typename _Compare>

_FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare);

template <typename _FIter>

_FIter adjacent_find(_FIter, _FIter);

template <typename _FIter, typename _BinaryPredicate>

_FIter adjacent_find(_FIter, _FIter, _BinaryPredicate);

template <typename _IIter, typename _Tp>

typename iterator_traits<_IIter>::difference_type count(_IIter, _IIter,
const _Tp &);

template <typename _IIter, typename _Predicate>

typename iterator_traits<_IIter>::difference_type count_if(_IIter, _IIter,
_Predicate);

template <typename _IIter1, typename _IIter2>

bool equal(_IIter1, _IIter1, _IIter2);

template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>

bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

template <typename _IIter, typename _Tp>

_IIter find(_IIter, _IIter, const _Tp &);

template <typename _FIter1, typename _FIter2>

_FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>

_FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

template <typename _IIter, typename _Predicate>

_IIter find_if(_IIter, _IIter, _Predicate);

template <typename _IIter, typename _Funct>

_Funct for_each(_IIter, _IIter, _Funct);

template <typename _FIter, typename _Generator>

void generate(_FIter, _FIter, _Generator);

template <typename _OIter, typename _Size, typename _Generator>

_OIter generate_n(_OIter, _Size, _Generator);

template <typename _IIter1, typename _IIter2>

bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

template <typename _IIter1, typename _IIter2, typename _Compare>

bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

template <typename _FIter> constexpr _FIter max_element(_FIter, _FIter);

template <typename _FIter, typename _Compare>
constexpr _FIter max_element(_FIter, _FIter, _Compare);

template <typename _IIter1, typename _IIter2, typename _OIter>

_OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _Compare>

_OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

template <typename _FIter> constexpr _FIter min_element(_FIter, _FIter);

template <typename _FIter, typename _Compare>
constexpr _FIter min_element(_FIter, _FIter, _Compare);

template <typename _IIter1, typename _IIter2>

pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2);

template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>

pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

template <typename _RAIter>

void nth_element(_RAIter, _RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void nth_element(_RAIter, _RAIter, _RAIter, _Compare);

template <typename _RAIter>

void partial_sort(_RAIter, _RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

template <typename _BIter, typename _Predicate>

_BIter partition(_BIter, _BIter, _Predicate);

template <typename _RAIter> void random_shuffle(_RAIter, _RAIter);

template <typename _RAIter, typename _Generator>
void random_shuffle(_RAIter, _RAIter,

_Generator &&);

template <typename _FIter, typename _Tp>

void replace(_FIter, _FIter, const _Tp &, const _Tp &);

template <typename _FIter, typename _Predicate, typename _Tp>

void replace_if(_FIter, _FIter, _Predicate, const _Tp &);

template <typename _FIter1, typename _FIter2>

_FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2);

template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>

_FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

template <typename _FIter, typename _Size, typename _Tp>

_FIter search_n(_FIter, _FIter, _Size, const _Tp &);

template <typename _FIter, typename _Size, typename _Tp,
typename _BinaryPredicate>

_FIter search_n(_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate);

template <typename _IIter1, typename _IIter2, typename _OIter>

_OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _Compare>

_OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

template <typename _IIter1, typename _IIter2, typename _OIter>

_OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _Compare>

_OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

template <typename _IIter1, typename _IIter2, typename _OIter>

_OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _Compare>

_OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,
_Compare);

template <typename _IIter1, typename _IIter2, typename _OIter>

_OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _Compare>

_OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

template <typename _RAIter>

void sort(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>

void sort(_RAIter, _RAIter, _Compare);

template <typename _RAIter> void stable_sort(_RAIter, _RAIter);

template <typename _RAIter, typename _Compare>
void stable_sort(_RAIter, _RAIter, _Compare);

template <typename _IIter, typename _OIter, typename _UnaryOperation>

_OIter transform(_IIter, _IIter, _OIter, _UnaryOperation);

template <typename _IIter1, typename _IIter2, typename _OIter,
typename _BinaryOperation>

_OIter transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

template <typename _IIter, typename _OIter>

_OIter unique_copy(_IIter, _IIter, _OIter);

template <typename _IIter, typename _OIter, typename _BinaryPredicate>

_OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

template <typename _RandomAccessIterator, typename _Distance,
typename _Compare>

_Distance __is_heap_until(_RandomAccessIterator __first, _Distance __n,
_Compare & __comp) {
_Distance __parent = 0;
for (_Distance __child = 1; __child < __n; ++__child) {
if (__comp(__first + __parent, __first + __child))
return __child;
if ((__child & 1) == 0)
++__parent;
}
return __n;
}

template <typename _RandomAccessIterator, typename _Distance>

inline bool __is_heap(_RandomAccessIterator __first, _Distance __n) {
__gnu_cxx::__ops::_Iter_less_iter __comp;
return std::__is_heap_until(__first, __n, __comp) == __n;
}

template <typename _RandomAccessIterator, typename _Compare,
typename _Distance>

inline bool __is_heap(_RandomAccessIterator __first, _Compare __comp,
_Distance __n) {
typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
return std::__is_heap_until(__first, __n, __cmp) == __n;
}

template <typename _RandomAccessIterator>

inline bool __is_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {
return std::__is_heap(__first, std::distance(__first, __last));
}

template <typename _RandomAccessIterator, typename _Compare>

inline bool __is_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
return std::__is_heap(__first, std::move(__comp),
std::distance(__first, __last));
}

template <typename _RandomAccessIterator, typename _Distance, typename _Tp,
typename _Compare>

void __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
_Distance __topIndex, _Tp __value, _Compare & __comp) {
_Distance __parent = (__holeIndex - 1) / 2;
while (__holeIndex > __topIndex && __comp(__first + __parent, __value)) {
*(__first + __holeIndex) = std::move(*(__first + __parent));
__holeIndex = __parent;
__parent = (__holeIndex - 1) / 2;
}
*(__first + __holeIndex) = std::move(__value);
}
template <typename _RandomAccessIterator>

inline void push_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;

;
;
;

__gnu_cxx::__ops::_Iter_less_val __comp;
_ValueType __value = std::move(*(__last - 1));
std::__push_heap(__first, _DistanceType((__last - __first) - 1),
_DistanceType(0), std::move(__value), __comp);
}
template <typename _RandomAccessIterator, typename _Compare>

inline void push_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;

;
;
;

__decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp))) __cmp(
std::move(__comp));
_ValueType __value = std::move(*(__last - 1));
std::__push_heap(__first, _DistanceType((__last - __first) - 1),
_DistanceType(0), std::move(__value), __cmp);
}

template <typename _RandomAccessIterator, typename _Distance, typename _Tp,
typename _Compare>

void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
_Distance __len, _Tp __value, _Compare __comp) {
const _Distance __topIndex = __holeIndex;
_Distance __secondChild = __holeIndex;
while (__secondChild < (__len - 1) / 2) {
__secondChild = 2 * (__secondChild + 1);
if (__comp(__first + __secondChild, __first + (__secondChild - 1)))
__secondChild--;
*(__first + __holeIndex) = std::move(*(__first + __secondChild));
__holeIndex = __secondChild;
}
if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2) {
__secondChild = 2 * (__secondChild + 1);
*(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));
__holeIndex = __secondChild - 1;
}
__decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp))) __cmp(
std::move(__comp));
std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value),
__cmp);
}

template <typename _RandomAccessIterator, typename _Compare>

inline void __pop_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last,
_RandomAccessIterator __result, _Compare & __comp) {
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;

_ValueType __value = std::move(*__result);
*__result = std::move(*__first);
std::__adjust_heap(__first, _DistanceType(0),
_DistanceType(__last - __first), std::move(__value),
__comp);
}
template <typename _RandomAccessIterator>

inline void pop_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;
;
;

if (__last - __first > 1) {
--__last;
__gnu_cxx::__ops::_Iter_less_iter __comp;
std::__pop_heap(__first, __last, __last, __comp);
}
}
template <typename _RandomAccessIterator, typename _Compare>

inline void pop_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {

;
;
;
;

if (__last - __first > 1) {
typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
--__last;
std::__pop_heap(__first, __last, __last, __cmp);
}
}

template <typename _RandomAccessIterator, typename _Compare>

void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
_Compare & __comp) {
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;

if (__last - __first < 2)
return;

const _DistanceType __len = __last - __first;
_DistanceType __parent = (__len - 2) / 2;
while (true) {
_ValueType __value = std::move(*(__first + __parent));
std::__adjust_heap(__first, __parent, __len, std::move(__value), __comp);
if (__parent == 0)
return;
__parent--;
}
}
template <typename _RandomAccessIterator>

inline void make_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;

__gnu_cxx::__ops::_Iter_less_iter __comp;
std::__make_heap(__first, __last, __comp);
}
template <typename _RandomAccessIterator, typename _Compare>

inline void make_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {

;
;

typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
std::__make_heap(__first, __last, __cmp);
}

template <typename _RandomAccessIterator, typename _Compare>

void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
_Compare & __comp) {
while (__last - __first > 1) {
--__last;
std::__pop_heap(__first, __last, __last, __comp);
}
}
template <typename _RandomAccessIterator>

inline void sort_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;
;

__gnu_cxx::__ops::_Iter_less_iter __comp;
std::__sort_heap(__first, __last, __comp);
}
template <typename _RandomAccessIterator, typename _Compare>

inline void sort_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {

;
;
;

typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
std::__sort_heap(__first, __last, __cmp);
}
template <typename _RandomAccessIterator>

inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;

__gnu_cxx::__ops::_Iter_less_iter __comp;
return __first + std::__is_heap_until(
__first, std::distance(__first, __last), __comp);
}
template <typename _RandomAccessIterator, typename _Compare>

inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first,
_RandomAccessIterator __last,
_Compare __comp) {

;
;

typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
return __first +
std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
}
template <typename _RandomAccessIterator>

inline bool is_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last) {
return std::is_heap_until(__first, __last) == __last;
}
template <typename _RandomAccessIterator, typename _Compare>

inline bool is_heap(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {

;
;

const auto __dist = std::distance(__first, __last);
typedef __decltype(__comp) _Cmp;
__gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
return std::__is_heap_until(__first, __dist, __cmp) == __dist;
}

} // namespace std

#pragma GCC visibility push(default)

extern "C++" {

namespace std {
class exception {
public:
exception() noexcept {}
virtual ~exception() noexcept;

exception(const exception &) = default;
exception &operator=(const exception &) = default;
exception(exception &&) = default;
exception &operator=(exception &&) = default;

virtual const char *what() const noexcept;
};

} // namespace std
}

#pragma GCC visibility pop

#pragma GCC visibility push(default)


namespace std {

template <typename _Tp>
[[nodiscard]] constexpr _Tp *launder(_Tp *__p) noexcept {
return __builtin_launder(__p);
}

template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete;
template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args......) noexcept(_NE)) = delete;

void launder(void *) = delete;
void launder(const void *) = delete;
void launder(volatile void *) = delete;
void launder(const volatile void *) = delete;

inline constexpr size_t hardware_destructive_interference_size = 64;
inline constexpr size_t hardware_constructive_interference_size = 64;

} // namespace std
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp> inline void destroy_at(_Tp * __location) {
if constexpr (201703L > 201703L && is_array_v<_Tp>) {
for (auto &__x : *__location)
std::destroy_at(std::__addressof(__x));
} else
__location->~_Tp();
}
template <typename _Tp, typename... _Args>

inline void _Construct(_Tp * __p, _Args && ...__args) {
::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
}
template <typename _T1> inline void _Construct_novalue(_T1 * __p) {
::new ((void *)__p) _T1;
}

template <typename _ForwardIterator>
void _Destroy(_ForwardIterator __first, _ForwardIterator __last);

template <typename _Tp> constexpr inline void _Destroy(_Tp * __pointer) {

__pointer->~_Tp();
}

template <bool> struct _Destroy_aux {
template <typename _ForwardIterator>
static void __destroy(_ForwardIterator __first, _ForwardIterator __last) {
for (; __first != __last; ++__first)
std::_Destroy(std::__addressof(*__first));
}
};

template <> struct _Destroy_aux<true> {
template <typename _ForwardIterator>
static void __destroy(_ForwardIterator, _ForwardIterator) {}
};

template <typename _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;

static_assert(is_destructible<_Value_type>::value,
"value type is destructible");

std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first,
__last);
}

template <bool> struct _Destroy_n_aux {
template <typename _ForwardIterator, typename _Size>
static _ForwardIterator __destroy_n(_ForwardIterator __first,
_Size __count) {
for (; __count > 0; (void)++__first, --__count)
std::_Destroy(std::__addressof(*__first));
return __first;
}
};

template <> struct _Destroy_n_aux<true> {
template <typename _ForwardIterator, typename _Size>
static _ForwardIterator __destroy_n(_ForwardIterator __first,
_Size __count) {
std::advance(__first, __count);
return __first;
}
};

template <typename _ForwardIterator, typename _Size>
inline _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count) {
typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;

static_assert(is_destructible<_Value_type>::value,
"value type is destructible");

return std::_Destroy_n_aux<__has_trivial_destructor(
_Value_type)>::__destroy_n(__first, __count);
}

template <typename _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {
std::_Destroy(__first, __last);
}

template <typename _ForwardIterator, typename _Size>
inline _ForwardIterator destroy_n(_ForwardIterator __first, _Size __count) {
return std::_Destroy_n(__first, __count);
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp>
inline void __return_temporary_buffer(_Tp *__p, size_t __len
__attribute__((__unused__))) {

::operator delete(__p, __len * sizeof(_Tp));
}
} // namespace __detail
template <typename _Tp>
[[__deprecated__]] pair<_Tp *, ptrdiff_t> get_temporary_buffer(
ptrdiff_t __len) noexcept {
const ptrdiff_t __max =
__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
if (__len > __max)
__len = __max;

while (__len > 0) {
_Tp *__tmp =
static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow));
if (__tmp != 0)
return std::pair<_Tp *, ptrdiff_t>(__tmp, __len);
__len = __len == 1 ? 0 : ((__len + 1) / 2);
}
return std::pair<_Tp *, ptrdiff_t>(static_cast<_Tp *>(0), 0);
}
template <typename _Tp> inline void return_temporary_buffer(_Tp * __p) {
::operator delete(__p);
}

template <typename _ForwardIterator, typename _Tp> class _Temporary_buffer {

public:
typedef _Tp value_type;
typedef value_type *pointer;
typedef pointer iterator;
typedef ptrdiff_t size_type;

protected:
size_type _M_original_len;
size_type _M_len;
pointer _M_buffer;

public:
size_type size() const { return _M_len; }

size_type requested_size() const { return _M_original_len; }

iterator begin() { return _M_buffer; }

iterator end() { return _M_buffer + _M_len; }

_Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

~_Temporary_buffer() {
std::_Destroy(_M_buffer, _M_buffer + _M_len);
std::__detail::__return_temporary_buffer(_M_buffer, _M_len);
}

private:
_Temporary_buffer(const _Temporary_buffer &);

void operator=(const _Temporary_buffer &);
};

template <bool> struct __uninitialized_construct_buf_dispatch {
template <typename _Pointer, typename _ForwardIterator>
static void __ucr(_Pointer __first, _Pointer __last,
_ForwardIterator __seed) {
if (__first == __last)
return;

_Pointer __cur = __first;
try {
std::_Construct(std::__addressof(*__first), std::move(*__seed));
_Pointer __prev = __cur;
++__cur;
for (; __cur != __last; ++__cur, ++__prev)
std::_Construct(std::__addressof(*__cur), std::move(*__prev));
*__seed = std::move(*__prev);
} catch (...) {
std::_Destroy(__first, __cur);
throw;
}
}
};

template <> struct __uninitialized_construct_buf_dispatch<true> {
template <typename _Pointer, typename _ForwardIterator>
static void __ucr(_Pointer, _Pointer, _ForwardIterator) {}
};
template <typename _Pointer, typename _ForwardIterator>
inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
_ForwardIterator __seed) {
typedef typename std::iterator_traits<_Pointer>::value_type _ValueType;

std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(
_ValueType)>::__ucr(__first, __last, __seed);
}

template <typename _ForwardIterator, typename _Tp>
_Temporary_buffer<_ForwardIterator, _Tp>::_Temporary_buffer(
_ForwardIterator __seed, size_type __original_len)
: _M_original_len(__original_len), _M_len(0), _M_buffer(0) {
std::pair<pointer, size_type> __p(
std::get_temporary_buffer<value_type>(_M_original_len));

if (__p.first) {
try {
std::__uninitialized_construct_buf(__p.first, __p.first + __p.second,
__seed);
_M_buffer = __p.first;
_M_len = __p.second;
} catch (...) {
std::__detail::__return_temporary_buffer(__p.first, __p.second);
throw;
}
}
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __detail {

template <typename _Tp> constexpr bool _Power_of_2(_Tp __x) {
return ((__x - 1) & __x) == 0;
}
} // namespace __detail

template <typename _IntType = int> class uniform_int_distribution {
static_assert(std::is_integral<_IntType>::value,
"template argument must be an integral type");

public:
typedef _IntType result_type;

struct param_type {
typedef uniform_int_distribution<_IntType> distribution_type;

param_type() : param_type(0) {}

explicit param_type(
_IntType __a, _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
: _M_a(__a), _M_b(__b) {
do {
if (std::__is_constant_evaluated() && !bool(_M_a <= _M_b))
__builtin_unreachable();
} while (false);
}

result_type a() const { return _M_a; }

result_type b() const { return _M_b; }

friend bool operator==(const param_type &__p1, const param_type &__p2) {
return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
}

friend bool operator!=(const param_type &__p1, const param_type &__p2) {
return !(__p1 == __p2);
}

private:
_IntType _M_a;
_IntType _M_b;
};

public:
uniform_int_distribution() : uniform_int_distribution(0) {}

explicit uniform_int_distribution(
_IntType __a, _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
: _M_param(__a, __b) {}

explicit uniform_int_distribution(const param_type &__p) : _M_param(__p) {}

void reset() {}

result_type a() const { return _M_param.a(); }

result_type b() const { return _M_param.b(); }

param_type param() const { return _M_param; }

void param(const param_type &__param) { _M_param = __param; }

result_type min() const { return this->a(); }

result_type max() const { return this->b(); }

template <typename _UniformRandomBitGenerator>
result_type operator()(_UniformRandomBitGenerator &__urng) {
return this->operator()(__urng, _M_param);
}

template <typename _UniformRandomBitGenerator>
result_type operator()(_UniformRandomBitGenerator &__urng,
const param_type &__p);

template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
void __generate(_ForwardIterator __f, _ForwardIterator __t,
_UniformRandomBitGenerator &__urng) {
this->__generate(__f, __t, __urng, _M_param);
}

template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
void __generate(_ForwardIterator __f, _ForwardIterator __t,
_UniformRandomBitGenerator &__urng, const param_type &__p) {
this->__generate_impl(__f, __t, __urng, __p);
}

template <typename _UniformRandomBitGenerator>
void __generate(result_type *__f, result_type *__t,
_UniformRandomBitGenerator &__urng, const param_type &__p) {
this->__generate_impl(__f, __t, __urng, __p);
}

friend bool operator==(const uniform_int_distribution &__d1,
const uniform_int_distribution &__d2) {
return __d1._M_param == __d2._M_param;
}

private:
template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
void __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
_UniformRandomBitGenerator &__urng,
const param_type &__p);

param_type _M_param;

template <typename _Wp, typename _Urbg, typename _Up>
static _Up _S_nd(_Urbg &__g, _Up __range) {
using _Up_traits = __gnu_cxx::__int_traits<_Up>;
using _Wp_traits = __gnu_cxx::__int_traits<_Wp>;
static_assert(!_Up_traits::__is_signed, "U must be unsigned");
static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
"W must be twice as wide as U");

_Wp __product = _Wp(__g()) * _Wp(__range);
_Up __low = _Up(__product);
if (__low < __range) {
_Up __threshold = -__range % __range;
while (__low < __threshold) {
__product = _Wp(__g()) * _Wp(__range);
__low = _Up(__product);
}
}
return __product >> _Up_traits::__digits;
}
};

template <typename _IntType>
template <typename _UniformRandomBitGenerator>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(
_UniformRandomBitGenerator &__urng, const param_type &__param) {
typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
typedef typename make_unsigned<result_type>::type __utype;
typedef typename common_type<_Gresult_type, __utype>::type __uctype;

constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
static_assert(__urngmin < __urngmax,
"Uniform random bit generator must define min() < max()");
constexpr __uctype __urngrange = __urngmax - __urngmin;

const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());

__uctype __ret;
if (__urngrange > __urange) {

const __uctype __uerange = __urange + 1;

if constexpr (__urngrange == 0xffffffffffffffffUL) {

long unsigned int __u64erange = __uerange;
__ret = __extension__ _S_nd<unsigned __int128>(__urng, __u64erange);
} else

if constexpr (__urngrange == 0xffffffffU) {

unsigned int __u32erange = __uerange;
__ret = _S_nd<long unsigned int>(__urng, __u32erange);
} else

{

const __uctype __scaling = __urngrange / __uerange;
const __uctype __past = __uerange * __scaling;
do
__ret = __uctype(__urng()) - __urngmin;
while (__ret >= __past);
__ret /= __scaling;
}
} else if (__urngrange < __urange) {
__uctype __tmp;
do {
const __uctype __uerngrange = __urngrange + 1;
__tmp =
(__uerngrange * operator()(__urng,
param_type(0, __urange / __uerngrange)));
__ret = __tmp + (__uctype(__urng()) - __urngmin);
} while (__ret > __urange || __ret < __tmp);
} else
__ret = __uctype(__urng()) - __urngmin;

return __ret + __param.a();
}

template <typename _IntType>
template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
void uniform_int_distribution<_IntType>::__generate_impl(
_ForwardIterator __f, _ForwardIterator __t,
_UniformRandomBitGenerator & __urng, const param_type &__param) {

typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
typedef typename make_unsigned<result_type>::type __utype;
typedef typename common_type<_Gresult_type, __utype>::type __uctype;

static_assert(__urng.min() < __urng.max(),
"Uniform random bit generator must define min() < max()");

constexpr __uctype __urngmin = __urng.min();
constexpr __uctype __urngmax = __urng.max();
constexpr __uctype __urngrange = __urngmax - __urngmin;
const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());

__uctype __ret;

if (__urngrange > __urange) {
if (__detail::_Power_of_2(__urngrange + 1) &&
__detail::_Power_of_2(__urange + 1)) {
while (__f != __t) {
__ret = __uctype(__urng()) - __urngmin;
*__f++ = (__ret & __urange) + __param.a();
}
} else {

const __uctype __uerange = __urange + 1;
const __uctype __scaling = __urngrange / __uerange;
const __uctype __past = __uerange * __scaling;
while (__f != __t) {
do
__ret = __uctype(__urng()) - __urngmin;
while (__ret >= __past);
*__f++ = __ret / __scaling + __param.a();
}
}
} else if (__urngrange < __urange) {
__uctype __tmp;
while (__f != __t) {
do {
constexpr __uctype __uerngrange = __urngrange + 1;
__tmp = (__uerngrange * operator()(
__urng,
param_type(0, __urange / __uerngrange)));
__ret = __tmp + (__uctype(__urng()) - __urngmin);
} while (__ret > __urange || __ret < __tmp);
*__f++ = __ret;
}
} else
while (__f != __t)
*__f++ = __uctype(__urng()) - __urngmin + __param.a();
}

} // namespace std

typedef long unsigned int size_t;

extern "C" {

typedef _Complex float __cfloat128 __attribute__((__mode__(__TC__)));
typedef __float128 _Float128;
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;

typedef struct {
int quot;
int rem;
} div_t;

typedef struct {
long int quot;
long int rem;
} ldiv_t;

__extension__ typedef struct {
long long int quot;
long long int rem;
} lldiv_t;
extern size_t __ctype_get_mb_cur_max(void) noexcept(true);

extern double atof(const char *__nptr) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

extern int atoi(const char *__nptr) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

extern long int atol(const char *__nptr) noexcept(true)
__attribute__((__pure__)) __attribute__((__nonnull__(1)));

__extension__ extern long long int atoll(const char *__nptr) noexcept(true)
__attribute__((__pure__)) __attribute__((__nonnull__(1)));

extern double strtod(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern float strtof(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern long double strtold(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));
extern _Float32 strtof32(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern _Float64 strtof64(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern _Float128 strtof128(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern _Float32x strtof32x(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));

extern _Float64x strtof64x(const char *__restrict __nptr,
char **__restrict __endptr) noexcept(true)
__attribute__((__nonnull__(1)));
extern long int strtol(const char *__restrict __nptr,
char **__restrict __endptr, int __base) noexcept(true)
__attribute__((__nonnull__(1)));

extern unsigned long int strtoul(const char *__restrict __nptr,
char **__restrict __endptr,
int __base) noexcept(true)
__attribute__((__nonnull__(1)));

__extension__ extern long long int strtoq(const char *__restrict __nptr,
char **__restrict __endptr,
int __base) noexcept(true)
__attribute__((__nonnull__(1)));

__extension__ extern unsigned long long int
strtouq(const char *__restrict __nptr, char **__restrict __endptr,
int __base) noexcept(true) __attribute__((__nonnull__(1)));

__extension__ extern long long int strtoll(const char *__restrict __nptr,
char **__restrict __endptr,
int __base) noexcept(true)
__attribute__((__nonnull__(1)));

__extension__ extern unsigned long long int
strtoull(const char *__restrict __nptr, char **__restrict __endptr,
int __base) noexcept(true) __attribute__((__nonnull__(1)));

extern int strfromd(char *__dest, size_t __size, const char *__format,
double __f) noexcept(true) __attribute__((__nonnull__(3)));

extern int strfromf(char *__dest, size_t __size, const char *__format,
float __f) noexcept(true) __attribute__((__nonnull__(3)));

extern int strfroml(char *__dest, size_t __size, const char *__format,
long double __f) noexcept(true)
__attribute__((__nonnull__(3)));
extern int strfromf32(char *__dest, size_t __size, const char *__format,
_Float32 __f) noexcept(true)
__attribute__((__nonnull__(3)));

extern int strfromf64(char *__dest, size_t __size, const char *__format,
_Float64 __f) noexcept(true)
__attribute__((__nonnull__(3)));

extern int strfromf128(char *__dest, size_t __size, const char *__format,
_Float128 __f) noexcept(true)
__attribute__((__nonnull__(3)));

extern int strfromf32x(char *__dest, size_t __size, const char *__format,
_Float32x __f) noexcept(true)
__attribute__((__nonnull__(3)));

extern int strfromf64x(char *__dest, size_t __size, const char *__format,
_Float64x __f) noexcept(true)
__attribute__((__nonnull__(3)));
struct __locale_struct {

struct __locale_data *__locales[13];

const unsigned short int *__ctype_b;
const int *__ctype_tolower;
const int *__ctype_toupper;

const char *__names[13];
};

typedef struct __locale_struct *__locale_t;

typedef __locale_t locale_t;

extern long int strtol_l(const char *__restrict __nptr,
char **__restrict __endptr, int __base,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 4)));

extern unsigned long int strtoul_l(const char *__restrict __nptr,
char **__restrict __endptr, int __base,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 4)));

__extension__ extern long long int
strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base,
locale_t __loc) noexcept(true) __attribute__((__nonnull__(1, 4)));

__extension__ extern unsigned long long int
strtoull_l(const char *__restrict __nptr, char **__restrict __endptr,
int __base, locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 4)));

extern double strtod_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern long double strtold_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));
extern _Float32 strtof32_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern _Float64 strtof64_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern _Float128 strtof128_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern _Float32x strtof32x_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));

extern _Float64x strtof64x_l(const char *__restrict __nptr,
char **__restrict __endptr,
locale_t __loc) noexcept(true)
__attribute__((__nonnull__(1, 3)));
extern char *l64a(long int __n) noexcept(true);

extern long int a64l(const char *__s) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

extern "C" {

typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;

typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;

typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;

typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct {
int __val[2];
} __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;

typedef int __clockid_t;

typedef void *__timer_t;

typedef long int __blksize_t;

typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __fsword_t;

typedef long int __ssize_t;

typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;

typedef __off64_t __loff_t;
typedef char *__caddr_t;

typedef long int __intptr_t;

typedef unsigned int __socklen_t;

typedef int __sig_atomic_t;

typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;

typedef __loff_t loff_t;

typedef __ino_t ino_t;

typedef __ino64_t ino64_t;

typedef __dev_t dev_t;

typedef __gid_t gid_t;

typedef __mode_t mode_t;

typedef __nlink_t nlink_t;

typedef __uid_t uid_t;

typedef __off_t off_t;

typedef __off64_t off64_t;

typedef __pid_t pid_t;

typedef __id_t id_t;

typedef __ssize_t ssize_t;

typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;

typedef __key_t key_t;

typedef __clock_t clock_t;

typedef __clockid_t clockid_t;
typedef __time_t time_t;

typedef __timer_t timer_t;

typedef __useconds_t useconds_t;

typedef __suseconds_t suseconds_t;

typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;

typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;

typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef int register_t __attribute__((__mode__(__word__)));
static __inline __uint16_t __bswap_16(__uint16_t __bsx) {

return __builtin_bswap16(__bsx);
}

static __inline __uint32_t __bswap_32(__uint32_t __bsx) {

return __builtin_bswap32(__bsx);
}
__extension__ static __inline __uint64_t __bswap_64(__uint64_t __bsx) {

return __builtin_bswap64(__bsx);
}
static __inline __uint16_t __uint16_identity(__uint16_t __x) { return __x; }

static __inline __uint32_t __uint32_identity(__uint32_t __x) { return __x; }

static __inline __uint64_t __uint64_identity(__uint64_t __x) { return __x; }

typedef struct {
unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];
} __sigset_t;

typedef __sigset_t sigset_t;

struct timeval {

__time_t tv_sec;
__suseconds_t tv_usec;
};

struct timespec {

__time_t tv_sec;

__syscall_slong_t tv_nsec;
};
typedef long int __fd_mask;
typedef struct {

__fd_mask fds_bits[1024 / (8 * (int)sizeof(__fd_mask))];

} fd_set;

typedef __fd_mask fd_mask;
extern "C" {
extern int select(int __nfds, fd_set *__restrict __readfds,
fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,
struct timeval *__restrict __timeout);
extern int pselect(int __nfds, fd_set *__restrict __readfds,
fd_set *__restrict __writefds,
fd_set *__restrict __exceptfds,
const struct timespec *__restrict __timeout,
const __sigset_t *__restrict __sigmask);
}

typedef __blksize_t blksize_t;

typedef __blkcnt_t blkcnt_t;

typedef __fsblkcnt_t fsblkcnt_t;

typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;

typedef union {
__extension__ unsigned long long int __value64;
struct {
unsigned int __low;
unsigned int __high;
} __value32;
} __atomic_wide_counter;

typedef struct __pthread_internal_list {
struct __pthread_internal_list *__prev;
struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist {
struct __pthread_internal_slist *__next;
} __pthread_slist_t;
struct __pthread_mutex_s {
int __lock;
unsigned int __count;
int __owner;

unsigned int __nusers;

int __kind;

short __spins;
short __elision;
__pthread_list_t __list;
};
struct __pthread_rwlock_arch_t {
unsigned int __readers;
unsigned int __writers;
unsigned int __wrphase_futex;
unsigned int __writers_futex;
unsigned int __pad3;
unsigned int __pad4;

int __cur_writer;
int __shared;
signed char __rwelision;

unsigned char __pad1[7];

unsigned long int __pad2;

unsigned int __flags;
};

struct __pthread_cond_s {
__atomic_wide_counter __wseq;
__atomic_wide_counter __g1_start;
unsigned int __g_refs[2];
unsigned int __g_size[2];
unsigned int __g1_orig_size;
unsigned int __wrefs;
unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct {
int __data;
} __once_flag;

typedef unsigned long int pthread_t;

typedef union {
char __size[4];
int __align;
} pthread_mutexattr_t;

typedef union {
char __size[4];
int __align;
} pthread_condattr_t;

typedef unsigned int pthread_key_t;

typedef int pthread_once_t;

union pthread_attr_t {
char __size[56];
long int __align;
};

typedef union pthread_attr_t pthread_attr_t;

typedef union {
struct __pthread_mutex_s __data;
char __size[40];
long int __align;
} pthread_mutex_t;

typedef union {
struct __pthread_cond_s __data;
char __size[48];
__extension__ long long int __align;
} pthread_cond_t;

typedef union {
struct __pthread_rwlock_arch_t __data;
char __size[56];
long int __align;
} pthread_rwlock_t;

typedef union {
char __size[8];
long int __align;
} pthread_rwlockattr_t;

typedef volatile int pthread_spinlock_t;

typedef union {
char __size[32];
long int __align;
} pthread_barrier_t;

typedef union {
char __size[4];
int __align;
} pthread_barrierattr_t;
}

extern long int random(void) noexcept(true);

extern void srandom(unsigned int __seed) noexcept(true);

extern char *initstate(unsigned int __seed, char *__statebuf,
size_t __statelen) noexcept(true)
__attribute__((__nonnull__(2)));

extern char *setstate(char *__statebuf) noexcept(true)
__attribute__((__nonnull__(1)));

struct random_data {
int32_t *fptr;
int32_t *rptr;
int32_t *state;
int rand_type;
int rand_deg;
int rand_sep;
int32_t *end_ptr;
};

extern int random_r(struct random_data *__restrict __buf,
int32_t *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int srandom_r(unsigned int __seed,
struct random_data *__buf) noexcept(true)
__attribute__((__nonnull__(2)));

extern int initstate_r(unsigned int __seed, char *__restrict __statebuf,
size_t __statelen,
struct random_data *__restrict __buf) noexcept(true)
__attribute__((__nonnull__(2, 4)));

extern int setstate_r(char *__restrict __statebuf,
struct random_data *__restrict __buf) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int rand(void) noexcept(true);

extern void srand(unsigned int __seed) noexcept(true);

extern int rand_r(unsigned int *__seed) noexcept(true);

extern double drand48(void) noexcept(true);
extern double erand48(unsigned short int __xsubi[3]) noexcept(true)
__attribute__((__nonnull__(1)));

extern long int lrand48(void) noexcept(true);
extern long int nrand48(unsigned short int __xsubi[3]) noexcept(true)
__attribute__((__nonnull__(1)));

extern long int mrand48(void) noexcept(true);
extern long int jrand48(unsigned short int __xsubi[3]) noexcept(true)
__attribute__((__nonnull__(1)));

extern void srand48(long int __seedval) noexcept(true);
extern unsigned short int *
seed48(unsigned short int __seed16v[3]) noexcept(true)
__attribute__((__nonnull__(1)));
extern void lcong48(unsigned short int __param[7]) noexcept(true)
__attribute__((__nonnull__(1)));

struct drand48_data {
unsigned short int __x[3];
unsigned short int __old_x[3];
unsigned short int __c;
unsigned short int __init;
__extension__ unsigned long long int __a;
};

extern int drand48_r(struct drand48_data *__restrict __buffer,
double *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));
extern int erand48_r(unsigned short int __xsubi[3],
struct drand48_data *__restrict __buffer,
double *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int lrand48_r(struct drand48_data *__restrict __buffer,
long int *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));
extern int nrand48_r(unsigned short int __xsubi[3],
struct drand48_data *__restrict __buffer,
long int *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int mrand48_r(struct drand48_data *__restrict __buffer,
long int *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));
extern int jrand48_r(unsigned short int __xsubi[3],
struct drand48_data *__restrict __buffer,
long int *__restrict __result) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int srand48_r(long int __seedval,
struct drand48_data *__buffer) noexcept(true)
__attribute__((__nonnull__(2)));

extern int seed48_r(unsigned short int __seed16v[3],
struct drand48_data *__buffer) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int lcong48_r(unsigned short int __param[7],
struct drand48_data *__buffer) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern __uint32_t arc4random(void) noexcept(true);

extern void arc4random_buf(void *__buf, size_t __size) noexcept(true)
__attribute__((__nonnull__(1)));

extern __uint32_t arc4random_uniform(__uint32_t __upper_bound) noexcept(true);

extern void *realloc(void *__ptr, size_t __size) noexcept(true)
__attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(2)));

extern void free(void *__ptr) noexcept(true);

extern void *reallocarray(void *__ptr, size_t __nmemb,
size_t __size) noexcept(true)
__attribute__((__warn_unused_result__))
__attribute__((__alloc_size__(2, 3)))
__attribute__((__malloc__(__builtin_free, 1)));

extern void *reallocarray(void *__ptr, size_t __nmemb,
size_t __size) noexcept(true)

extern "C" {


extern "C++" int
at_quick_exit(void (*__func)(void)) noexcept(true) __asm("at_quick_exit")
__attribute__((__nonnull__(1)));
extern int on_exit(void (*__func)(int __status, void *__arg),
void *__arg) noexcept(true) __attribute__((__nonnull__(1)));

extern void exit(int __status) noexcept(true) __attribute__((__noreturn__));

extern void quick_exit(int __status) noexcept(true)
__attribute__((__noreturn__));

extern void _Exit(int __status) noexcept(true) __attribute__((__noreturn__));

extern char *getenv(const char *__name) noexcept(true)
__attribute__((__nonnull__(1)));

extern char *secure_getenv(const char *__name) noexcept(true)
__attribute__((__nonnull__(1)));

extern int putenv(char *__string) noexcept(true)
__attribute__((__nonnull__(1)));

extern int setenv(const char *__name, const char *__value,
int __replace) noexcept(true) __attribute__((__nonnull__(2)));

extern int unsetenv(const char *__name) noexcept(true)
__attribute__((__nonnull__(1)));

extern int clearenv(void) noexcept(true);
extern char *mktemp(char *__template) noexcept(true)
__attribute__((__nonnull__(1)));
extern int mkstemp(char *__template) __attribute__((__nonnull__(1)));
extern int mkstemp64(char *__template) __attribute__((__nonnull__(1)));
extern int mkstemps(char *__template, int __suffixlen)
__attribute__((__nonnull__(1)));
extern int mkstemps64(char *__template, int __suffixlen)
__attribute__((__nonnull__(1)));
extern char *mkdtemp(char *__template) noexcept(true)
__attribute__((__nonnull__(1)));
extern int mkostemp(char *__template, int __flags)
__attribute__((__nonnull__(1)));
extern int mkostemp64(char *__template, int __flags)
__attribute__((__nonnull__(1)));
extern int mkostemps(char *__template, int __suffixlen, int __flags)
__attribute__((__nonnull__(1)));
extern int mkostemps64(char *__template, int __suffixlen, int __flags)
__attribute__((__nonnull__(1)));
extern int system(const char *__command);

extern char *canonicalize_file_name(const char *__name) noexcept(true)
__attribute__((__nonnull__(1))) __attribute__((__malloc__))
__attribute__((__malloc__(__builtin_free, 1)));
extern char *realpath(const char *__restrict __name,
char *__restrict __resolved) noexcept(true);

typedef int (*__compar_fn_t)(const void *, const void *);

typedef __compar_fn_t comparison_fn_t;

typedef int (*__compar_d_fn_t)(const void *, const void *, void *);

extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
size_t __size, __compar_fn_t __compar)
__attribute__((__nonnull__(1, 2, 5)));

extern void qsort(void *__base, size_t __nmemb, size_t __size,
__compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));

extern void qsort_r(void *__base, size_t __nmemb, size_t __size,
__compar_d_fn_t __compar, void *__arg)
__attribute__((__nonnull__(1, 4)));

extern int abs(int __x) noexcept(true) __attribute__((__const__));
extern long int labs(long int __x) noexcept(true) __attribute__((__const__));

__extension__ extern long long int llabs(long long int __x) noexcept(true)
__attribute__((__const__));

extern div_t div(int __numer, int __denom) noexcept(true)
__attribute__((__const__));
extern ldiv_t ldiv(long int __numer, long int __denom) noexcept(true)
__attribute__((__const__));

__extension__ extern lldiv_t lldiv(long long int __numer,
long long int __denom) noexcept(true)
__attribute__((__const__));
extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign) noexcept(true)
__attribute__((__nonnull__(3, 4)));

extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign) noexcept(true)
__attribute__((__nonnull__(3, 4)));

extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(true)
__attribute__((__nonnull__(3)));

extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign) noexcept(true)
__attribute__((__nonnull__(3, 4)));
extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign) noexcept(true)
__attribute__((__nonnull__(3, 4)));
extern char *qgcvt(long double __value, int __ndigit,
char *__buf) noexcept(true) __attribute__((__nonnull__(3)));

extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign, char *__restrict __buf,
size_t __len) noexcept(true)
__attribute__((__nonnull__(3, 4, 5)));
extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign, char *__restrict __buf,
size_t __len) noexcept(true)
__attribute__((__nonnull__(3, 4, 5)));

extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign, char *__restrict __buf,
size_t __len) noexcept(true)
__attribute__((__nonnull__(3, 4, 5)));
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt,
int *__restrict __sign, char *__restrict __buf,
size_t __len) noexcept(true)
__attribute__((__nonnull__(3, 4, 5)));

extern int mblen(const char *__s, size_t __n) noexcept(true);

extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s,
size_t __n) noexcept(true);

extern int wctomb(char *__s, wchar_t __wchar) noexcept(true);

extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s,
size_t __n) noexcept(true)
__attribute__((__access__(__read_only__, 2)));

extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs,
size_t __n) noexcept(true)
__attribute__((__access__(__write_only__, 1, 3)))
__attribute__((__access__(__read_only__, 2)));

extern int rpmatch(const char *__response) noexcept(true)
__attribute__((__nonnull__(1)));
extern int getsubopt(char **__restrict __optionp,
char *const *__restrict __tokens,
char **__restrict __valuep) noexcept(true)
__attribute__((__nonnull__(1, 2, 3)));

extern int posix_openpt(int __oflag);

extern int grantpt(int __fd) noexcept(true);

extern int unlockpt(int __fd) noexcept(true);

extern char *ptsname(int __fd) noexcept(true);

extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true)
__attribute__((__nonnull__(2)))
__attribute__((__access__(__write_only__, 2, 3)));

extern int getpt(void);

extern int getloadavg(double __loadavg[], int __nelem) noexcept(true)
__attribute__((__nonnull__(1)));
}

extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

using ::abs;

inline long abs(long __i) { return __builtin_labs(__i); }

inline long long abs(long long __x) { return __builtin_llabs(__x); }
inline constexpr double abs(double __x) { return __builtin_fabs(__x); }

inline constexpr float abs(float __x) { return __builtin_fabsf(__x); }

inline constexpr long double abs(long double __x) {
return __builtin_fabsl(__x);
}

__extension__ inline constexpr __int128 abs(__int128 __x) {
return __x >= 0 ? __x : -__x;
}
__extension__ inline constexpr __float128 abs(__float128 __x) {
return __x < 0 ? -__x : __x;
}

} // namespace std
}
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

using ::div_t;
using ::ldiv_t;

using ::abort;

using ::aligned_alloc;

using ::atexit;

using ::at_quick_exit;

using ::atof;
using ::atoi;
using ::atol;
using ::bsearch;
using ::calloc;
using ::div;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::malloc;

using ::mblen;
using ::mbstowcs;
using ::mbtowc;

using ::qsort;

using ::quick_exit;

using ::rand;
using ::realloc;
using ::srand;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;

using ::wcstombs;
using ::wctomb;

inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); }

} // namespace std
namespace __gnu_cxx __attribute__((__visibility__("default"))) {

using ::lldiv_t;

using ::_Exit;

using ::llabs;

inline lldiv_t div(long long __n, long long __d) {
lldiv_t __q;
__q.quot = __n / __d;
__q.rem = __n % __d;
return __q;
}

using ::atoll;
using ::lldiv;
using ::strtoll;
using ::strtoull;

using ::strtof;
using ::strtold;

} // namespace __gnu_cxx

namespace std {

using ::__gnu_cxx::lldiv_t;

using ::__gnu_cxx::_Exit;

using ::__gnu_cxx::div;
using ::__gnu_cxx::llabs;
using ::__gnu_cxx::lldiv;

using ::__gnu_cxx::atoll;
using ::__gnu_cxx::strtof;
using ::__gnu_cxx::strtold;
using ::__gnu_cxx::strtoll;
using ::__gnu_cxx::strtoull;
} // namespace std
}

namespace std __attribute__((__visibility__("default"))) {

template <typename _Iterator, typename _Compare>

void __move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b,
_Iterator __c, _Compare __comp) {
if (__comp(__a, __b)) {
if (__comp(__b, __c))
std::iter_swap(__result, __b);
else if (__comp(__a, __c))
std::iter_swap(__result, __c);
else
std::iter_swap(__result, __a);
} else if (__comp(__a, __c))
std::iter_swap(__result, __a);
else if (__comp(__b, __c))
std::iter_swap(__result, __c);
else
std::iter_swap(__result, __b);
}

template <typename _InputIterator, typename _Predicate>

inline _InputIterator __find_if_not(
_InputIterator __first, _InputIterator __last, _Predicate __pred) {
return std::__find_if(__first, __last, __gnu_cxx::__ops::__negate(__pred),
std::__iterator_category(__first));
}

template <typename _InputIterator, typename _Predicate, typename _Distance>

_InputIterator __find_if_not_n(_InputIterator __first, _Distance & __len,
_Predicate __pred) {
for (; __len; --__len, (void)++__first)
if (!__pred(__first))
break;
return __first;
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

_ForwardIterator1 __search(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
_BinaryPredicate __predicate) {

if (__first1 == __last1 || __first2 == __last2)
return __first1;

_ForwardIterator2 __p1(__first2);
if (++__p1 == __last2)
return std::__find_if(
__first1, __last1,
__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

_ForwardIterator1 __current = __first1;

for (;;) {
__first1 = std::__find_if(
__first1, __last1,
__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

if (__first1 == __last1)
return __last1;

_ForwardIterator2 __p = __p1;
__current = __first1;
if (++__current == __last1)
return __last1;

while (__predicate(__current, __p)) {
if (++__p == __last2)
return __first1;
if (++__current == __last1)
return __last1;
}
++__first1;
}
return __first1;
}

template <typename _ForwardIterator, typename _Integer,
typename _UnaryPredicate>

_ForwardIterator __search_n_aux(
_ForwardIterator __first, _ForwardIterator __last, _Integer __count,
_UnaryPredicate __unary_pred, std::forward_iterator_tag) {
__first = std::__find_if(__first, __last, __unary_pred);
while (__first != __last) {
typename iterator_traits<_ForwardIterator>::difference_type __n = __count;
_ForwardIterator __i = __first;
++__i;
while (__i != __last && __n != 1 && __unary_pred(__i)) {
++__i;
--__n;
}
if (__n == 1)
return __first;
if (__i == __last)
return __last;
__first = std::__find_if(++__i, __last, __unary_pred);
}
return __last;
}

template <typename _RandomAccessIter, typename _Integer,
typename _UnaryPredicate>

_RandomAccessIter __search_n_aux(
_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count,
_UnaryPredicate __unary_pred, std::random_access_iterator_tag) {
typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
_DistanceType;

_DistanceType __tailSize = __last - __first;
_DistanceType __remainder = __count;

while (__remainder <= __tailSize) {
__first += __remainder;
__tailSize -= __remainder;

_RandomAccessIter __backTrack = __first;
while (__unary_pred(--__backTrack)) {
if (--__remainder == 0)
return (__first - __count);
}
__remainder = __count + 1 - (__first - __backTrack);
}
return __last;
}

template <typename _ForwardIterator, typename _Integer,
typename _UnaryPredicate>

_ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last,
_Integer __count, _UnaryPredicate __unary_pred) {
if (__count <= 0)
return __first;

if (__count == 1)
return std::__find_if(__first, __last, __unary_pred);

return std::__search_n_aux(__first, __last, __count, __unary_pred,
std::__iterator_category(__first));
}

template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

_ForwardIterator1 __find_end(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
forward_iterator_tag, forward_iterator_tag, _BinaryPredicate __comp) {
if (__first2 == __last2)
return __last1;

_ForwardIterator1 __result = __last1;
while (1) {
_ForwardIterator1 __new_result =
std::__search(__first1, __last1, __first2, __last2, __comp);
if (__new_result == __last1)
return __result;
else {
__result = __new_result;
__first1 = __new_result;
++__first1;
}
}
}

template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
typename _BinaryPredicate>

_BidirectionalIterator1 __find_end(
_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
_BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
bidirectional_iterator_tag, bidirectional_iterator_tag,
_BinaryPredicate __comp) {

typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

_RevIterator1 __rlast1(__first1);
_RevIterator2 __rlast2(__first2);
_RevIterator1 __rresult =
std::__search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2),
__rlast2, __comp);

if (__rresult == __rlast1)
return __last1;
else {
_BidirectionalIterator1 __result = __rresult.base();
std::advance(__result, -std::distance(__first2, __last2));
return __result;
}
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

inline _ForwardIterator1 find_end(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2) {

;
;

return std::__find_end(__first1, __last1, __first2, __last2,
std::__iterator_category(__first1),
std::__iterator_category(__first2),
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

inline _ForwardIterator1 find_end(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
_BinaryPredicate __comp) {

;
;

return std::__find_end(__first1, __last1, __first2, __last2,
std::__iterator_category(__first1),
std::__iterator_category(__first2),
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _InputIterator, typename _Predicate>

inline bool all_of(_InputIterator __first, _InputIterator __last,
_Predicate __pred) {
return __last == std::find_if_not(__first, __last, __pred);
}
template <typename _InputIterator, typename _Predicate>

inline bool none_of(_InputIterator __first, _InputIterator __last,
_Predicate __pred) {
return __last == std::find_if(__first, __last, __pred);
}
template <typename _InputIterator, typename _Predicate>

inline bool any_of(_InputIterator __first, _InputIterator __last,
_Predicate __pred) {
return !std::none_of(__first, __last, __pred);
}
template <typename _InputIterator, typename _Predicate>

inline _InputIterator find_if_not(_InputIterator __first,
_InputIterator __last, _Predicate __pred) {

;
return std::__find_if_not(__first, __last,
__gnu_cxx::__ops::__pred_iter(__pred));
}
template <typename _InputIterator, typename _Predicate>

inline bool is_partitioned(_InputIterator __first, _InputIterator __last,
_Predicate __pred) {
__first = std::find_if_not(__first, __last, __pred);
if (__first == __last)
return true;
++__first;
return std::none_of(__first, __last, __pred);
}
template <typename _ForwardIterator, typename _Predicate>

_ForwardIterator partition_point(_ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred) {

;

typedef typename iterator_traits<_ForwardIterator>::difference_type
_DistanceType;

_DistanceType __len = std::distance(__first, __last);

while (__len > 0) {
_DistanceType __half = __len >> 1;
_ForwardIterator __middle = __first;
std::advance(__middle, __half);
if (__pred(*__middle)) {
__first = __middle;
++__first;
__len = __len - __half - 1;
} else
__len = __half;
}
return __first;
}

template <typename _InputIterator, typename _OutputIterator,
typename _Predicate>

_OutputIterator __remove_copy_if(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_Predicate __pred) {
for (; __first != __last; ++__first)
if (!__pred(__first)) {
*__result = *__first;
++__result;
}
return __result;
}
template <typename _InputIterator, typename _OutputIterator, typename _Tp>

inline _OutputIterator remove_copy(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
const _Tp &__value) {

;

return std::__remove_copy_if(__first, __last, __result,
__gnu_cxx::__ops::__iter_equals_val(__value));
}
template <typename _InputIterator, typename _OutputIterator,
typename _Predicate>

inline _OutputIterator remove_copy_if(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_Predicate __pred) {

;

return std::__remove_copy_if(__first, __last, __result,
__gnu_cxx::__ops::__pred_iter(__pred));
}
template <typename _InputIterator, typename _OutputIterator,
typename _Predicate>

_OutputIterator copy_if(_InputIterator __first, _InputIterator __last,
_OutputIterator __result, _Predicate __pred) {

;

for (; __first != __last; ++__first)
if (__pred(*__first)) {
*__result = *__first;
++__result;
}
return __result;
}

template <typename _InputIterator, typename _Size, typename _OutputIterator>

_OutputIterator __copy_n(_InputIterator __first, _Size __n,
_OutputIterator __result, input_iterator_tag) {
return std::__niter_wrap(
__result, __copy_n_a(__first, __n, std::__niter_base(__result), true));
}

template <typename _RandomAccessIterator, typename _Size,
typename _OutputIterator>

inline _OutputIterator __copy_n(_RandomAccessIterator __first, _Size __n,
_OutputIterator __result,
random_access_iterator_tag) {
return std::copy(__first, __first + __n, __result);
}
template <typename _InputIterator, typename _Size, typename _OutputIterator>

inline _OutputIterator copy_n(_InputIterator __first, _Size __n,
_OutputIterator __result) {

const auto __n2 = std::__size_to_integer(__n);
if (__n2 <= 0)
return __result;

;
;

return std::__copy_n(__first, __n2, __result,
std::__iterator_category(__first));
}
template <typename _InputIterator, typename _OutputIterator1,
typename _OutputIterator2, typename _Predicate>

pair<_OutputIterator1, _OutputIterator2> partition_copy(
_InputIterator __first, _InputIterator __last,
_OutputIterator1 __out_true, _OutputIterator2 __out_false,
_Predicate __pred) {

;

for (; __first != __last; ++__first)
if (__pred(*__first)) {
*__out_true = *__first;
++__out_true;
} else {
*__out_false = *__first;
++__out_false;
}

return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}
template <typename _ForwardIterator, typename _Tp>

inline _ForwardIterator remove(_ForwardIterator __first,
_ForwardIterator __last, const _Tp &__value) {

;

return std::__remove_if(__first, __last,
__gnu_cxx::__ops::__iter_equals_val(__value));
}
template <typename _ForwardIterator, typename _Predicate>

inline _ForwardIterator remove_if(
_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

;

return std::__remove_if(__first, __last,
__gnu_cxx::__ops::__pred_iter(__pred));
}

template <typename _ForwardIterator, typename _BinaryPredicate>

_ForwardIterator __adjacent_find(_ForwardIterator __first,
_ForwardIterator __last,
_BinaryPredicate __binary_pred) {
if (__first == __last)
return __last;
_ForwardIterator __next = __first;
while (++__next != __last) {
if (__binary_pred(__first, __next))
return __first;
__first = __next;
}
return __last;
}

template <typename _ForwardIterator, typename _BinaryPredicate>

_ForwardIterator __unique(_ForwardIterator __first, _ForwardIterator __last,
_BinaryPredicate __binary_pred) {

__first = std::__adjacent_find(__first, __last, __binary_pred);
if (__first == __last)
return __last;

_ForwardIterator __dest = __first;
++__first;
while (++__first != __last)
if (!__binary_pred(__dest, __first))
*++__dest = std::move(*__first);
return ++__dest;
}
template <typename _ForwardIterator>

inline _ForwardIterator unique(_ForwardIterator __first,
_ForwardIterator __last) {

;

return std::__unique(__first, __last,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _ForwardIterator, typename _BinaryPredicate>

inline _ForwardIterator unique(_ForwardIterator __first,
_ForwardIterator __last,
_BinaryPredicate __binary_pred) {

;

return std::__unique(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
}

template <typename _ForwardIterator, typename _OutputIterator,
typename _BinaryPredicate>

_OutputIterator __unique_copy(
_ForwardIterator __first, _ForwardIterator __last,
_OutputIterator __result, _BinaryPredicate __binary_pred,
forward_iterator_tag, output_iterator_tag) {

_ForwardIterator __next = __first;
*__result = *__first;
while (++__next != __last)
if (!__binary_pred(__first, __next)) {
__first = __next;
*++__result = *__first;
}
return ++__result;
}

template <typename _InputIterator, typename _OutputIterator,
typename _BinaryPredicate>

_OutputIterator __unique_copy(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag) {

typename iterator_traits<_InputIterator>::value_type __value = *__first;
__decltype(__gnu_cxx::__ops::__iter_comp_val(
__binary_pred)) __rebound_pred =
__gnu_cxx::__ops::__iter_comp_val(__binary_pred);
*__result = __value;
while (++__first != __last)
if (!__rebound_pred(__first, __value)) {
__value = *__first;
*++__result = __value;
}
return ++__result;
}

template <typename _InputIterator, typename _ForwardIterator,
typename _BinaryPredicate>

_ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last,
_ForwardIterator __result,
_BinaryPredicate __binary_pred,
input_iterator_tag, forward_iterator_tag) {

*__result = *__first;
while (++__first != __last)
if (!__binary_pred(__result, __first))
*++__result = *__first;
return ++__result;
}

template <typename _BidirectionalIterator>

void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
bidirectional_iterator_tag) {
while (true)
if (__first == __last || __first == --__last)
return;
else {
std::iter_swap(__first, __last);
++__first;
}
}

template <typename _RandomAccessIterator>

void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
random_access_iterator_tag) {
if (__first == __last)
return;
--__last;
while (__first < __last) {
std::iter_swap(__first, __last);
++__first;
--__last;
}
}
template <typename _BidirectionalIterator>

inline void reverse(_BidirectionalIterator __first,
_BidirectionalIterator __last) {

;
std::__reverse(__first, __last, std::__iterator_category(__first));
}
template <typename _BidirectionalIterator, typename _OutputIterator>

_OutputIterator reverse_copy(_BidirectionalIterator __first,
_BidirectionalIterator __last,
_OutputIterator __result) {

;

while (__first != __last) {
--__last;
*__result = *__last;
++__result;
}
return __result;
}

template <typename _EuclideanRingElement>

_EuclideanRingElement __gcd(_EuclideanRingElement __m,
_EuclideanRingElement __n) {
while (__n != 0) {
_EuclideanRingElement __t = __m % __n;
__m = __n;
__n = __t;
}
return __m;
}

inline namespace _V2 {

template <typename _ForwardIterator>

_ForwardIterator __rotate(_ForwardIterator __first, _ForwardIterator __middle,
_ForwardIterator __last, forward_iterator_tag) {
if (__first == __middle)
return __last;
else if (__last == __middle)
return __first;

_ForwardIterator __first2 = __middle;
do {
std::iter_swap(__first, __first2);
++__first;
++__first2;
if (__first == __middle)
__middle = __first2;
} while (__first2 != __last);

_ForwardIterator __ret = __first;

__first2 = __middle;

while (__first2 != __last) {
std::iter_swap(__first, __first2);
++__first;
++__first2;
if (__first == __middle)
__middle = __first2;
else if (__first2 == __last)
__first2 = __middle;
}
return __ret;
}

template <typename _BidirectionalIterator>

_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle,
_BidirectionalIterator __last, bidirectional_iterator_tag) {

if (__first == __middle)
return __last;
else if (__last == __middle)
return __first;

std::__reverse(__first, __middle, bidirectional_iterator_tag());
std::__reverse(__middle, __last, bidirectional_iterator_tag());

while (__first != __middle && __middle != __last) {
std::iter_swap(__first, --__last);
++__first;
}

if (__first == __middle) {
std::__reverse(__middle, __last, bidirectional_iterator_tag());
return __last;
} else {
std::__reverse(__first, __middle, bidirectional_iterator_tag());
return __first;
}
}

template <typename _RandomAccessIterator>

_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle,
_RandomAccessIterator __last, random_access_iterator_tag) {

if (__first == __middle)
return __last;
else if (__last == __middle)
return __first;

typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_Distance;
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;

_Distance __n = __last - __first;
_Distance __k = __middle - __first;

if (__k == __n - __k) {
std::swap_ranges(__first, __middle, __middle);
return __middle;
}

_RandomAccessIterator __p = __first;
_RandomAccessIterator __ret = __first + (__last - __middle);

for (;;) {
if (__k < __n - __k) {
if (__is_pod(_ValueType) && __k == 1) {
_ValueType __t = std::move(*__p);
std::move(__p + 1, __p + __n, __p);
*(__p + __n - 1) = std::move(__t);
return __ret;
}
_RandomAccessIterator __q = __p + __k;
for (_Distance __i = 0; __i < __n - __k; ++__i) {
std::iter_swap(__p, __q);
++__p;
++__q;
}
__n %= __k;
if (__n == 0)
return __ret;
std::swap(__n, __k);
__k = __n - __k;
} else {
__k = __n - __k;
if (__is_pod(_ValueType) && __k == 1) {
_ValueType __t = std::move(*(__p + __n - 1));
std::move_backward(__p, __p + __n - 1, __p + __n);
*__p = std::move(__t);
return __ret;
}
_RandomAccessIterator __q = __p + __n;
__p = __q - __k;
for (_Distance __i = 0; __i < __n - __k; ++__i) {
--__p;
--__q;
std::iter_swap(__p, __q);
}
__n %= __k;
if (__n == 0)
return __ret;
std::swap(__n, __k);
}
}
}
template <typename _ForwardIterator>

inline _ForwardIterator rotate(_ForwardIterator __first,
_ForwardIterator __middle,
_ForwardIterator __last) {

;
;

return std::__rotate(__first, __middle, __last,
std::__iterator_category(__first));
}

} // namespace _V2
template <typename _ForwardIterator, typename _OutputIterator>

inline _OutputIterator rotate_copy(
_ForwardIterator __first, _ForwardIterator __middle,
_ForwardIterator __last, _OutputIterator __result) {

;
;

return std::copy(__first, __middle, std::copy(__middle, __last, __result));
}

template <typename _ForwardIterator, typename _Predicate>

_ForwardIterator __partition(_ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred,
forward_iterator_tag) {
if (__first == __last)
return __first;

while (__pred(*__first))
if (++__first == __last)
return __first;

_ForwardIterator __next = __first;

while (++__next != __last)
if (__pred(*__next)) {
std::iter_swap(__first, __next);
++__first;
}

return __first;
}

template <typename _BidirectionalIterator, typename _Predicate>

_BidirectionalIterator __partition(
_BidirectionalIterator __first, _BidirectionalIterator __last,
_Predicate __pred, bidirectional_iterator_tag) {
while (true) {
while (true)
if (__first == __last)
return __first;
else if (__pred(*__first))
++__first;
else
break;
--__last;
while (true)
if (__first == __last)
return __first;
else if (!bool(__pred(*__last)))
--__last;
else
break;
std::iter_swap(__first, __last);
++__first;
}
}
template <typename _ForwardIterator, typename _Pointer, typename _Predicate,
typename _Distance>
_ForwardIterator __stable_partition_adaptive(
_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
_Distance __len, _Pointer __buffer, _Distance __buffer_size) {
if (__len == 1)
return __first;

if (__len <= __buffer_size) {
_ForwardIterator __result1 = __first;
_Pointer __result2 = __buffer;

*__result2 = std::move(*__first);
++__result2;
++__first;
for (; __first != __last; ++__first)
if (__pred(__first)) {
*__result1 = std::move(*__first);
++__result1;
} else {
*__result2 = std::move(*__first);
++__result2;
}

std::move(__buffer, __result2, __result1);
return __result1;
}

_ForwardIterator __middle = __first;
std::advance(__middle, __len / 2);
_ForwardIterator __left_split = std::__stable_partition_adaptive(
__first, __middle, __pred, __len / 2, __buffer, __buffer_size);

_Distance __right_len = __len - __len / 2;
_ForwardIterator __right_split =
std::__find_if_not_n(__middle, __right_len, __pred);

if (__right_len)
__right_split = std::__stable_partition_adaptive(
__right_split, __last, __pred, __right_len, __buffer, __buffer_size);

return std::rotate(__left_split, __middle, __right_split);
}

template <typename _ForwardIterator, typename _Predicate>
_ForwardIterator __stable_partition(
_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
__first = std::__find_if_not(__first, __last, __pred);

if (__first == __last)
return __first;

typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
typedef typename iterator_traits<_ForwardIterator>::difference_type
_DistanceType;

_Temporary_buffer<_ForwardIterator, _ValueType> __buf(
__first, std::distance(__first, __last));
return std::__stable_partition_adaptive(
__first, __last, __pred, _DistanceType(__buf.requested_size()),
__buf.begin(), _DistanceType(__buf.size()));
}
template <typename _ForwardIterator, typename _Predicate>
inline _ForwardIterator stable_partition(
_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

;

return std::__stable_partition(__first, __last,
__gnu_cxx::__ops::__pred_iter(__pred));
}

template <typename _RandomAccessIterator, typename _Compare>

void __heap_select(_RandomAccessIterator __first,
_RandomAccessIterator __middle,
_RandomAccessIterator __last, _Compare __comp) {
std::__make_heap(__first, __middle, __comp);
for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
if (__comp(__i, __first))
std::__pop_heap(__first, __middle, __i, __comp);
}

template <typename _InputIterator, typename _RandomAccessIterator,
typename _Compare>

_RandomAccessIterator __partial_sort_copy(
_InputIterator __first, _InputIterator __last,
_RandomAccessIterator __result_first, _RandomAccessIterator __result_last,
_Compare __comp) {
typedef
typename iterator_traits<_InputIterator>::value_type _InputValueType;
typedef iterator_traits<_RandomAccessIterator> _RItTraits;
typedef typename _RItTraits::difference_type _DistanceType;

if (__result_first == __result_last)
return __result_last;
_RandomAccessIterator __result_real_last = __result_first;
while (__first != __last && __result_real_last != __result_last) {
*__result_real_last = *__first;
++__result_real_last;
++__first;
}

std::__make_heap(__result_first, __result_real_last, __comp);
while (__first != __last) {
if (__comp(__first, __result_first))
std::__adjust_heap(__result_first, _DistanceType(0),
_DistanceType(__result_real_last - __result_first),
_InputValueType(*__first), __comp);
++__first;
}
std::__sort_heap(__result_first, __result_real_last, __comp);
return __result_real_last;
}
template <typename _InputIterator, typename _RandomAccessIterator>

inline _RandomAccessIterator partial_sort_copy(
_InputIterator __first, _InputIterator __last,
_RandomAccessIterator __result_first,
_RandomAccessIterator __result_last) {

;
;
;

return std::__partial_sort_copy(__first, __last, __result_first,
__result_last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator, typename _RandomAccessIterator,
typename _Compare>

inline _RandomAccessIterator partial_sort_copy(
_InputIterator __first, _InputIterator __last,
_RandomAccessIterator __result_first, _RandomAccessIterator __result_last,
_Compare __comp) {

;
;
;

return std::__partial_sort_copy(__first, __last, __result_first,
__result_last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _RandomAccessIterator, typename _Compare>

void __unguarded_linear_insert(_RandomAccessIterator __last,
_Compare __comp) {
typename iterator_traits<_RandomAccessIterator>::value_type __val =
std::move(*__last);
_RandomAccessIterator __next = __last;
--__next;
while (__comp(__val, __next)) {
*__last = std::move(*__next);
__last = __next;
--__next;
}
*__last = std::move(__val);
}

template <typename _RandomAccessIterator, typename _Compare>

void __insertion_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
if (__first == __last)
return;

for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
if (__comp(__i, __first)) {
typename iterator_traits<_RandomAccessIterator>::value_type __val =
std::move(*__i);
std::move_backward(__first, __i, __i + 1);
*__first = std::move(__val);
} else
std::__unguarded_linear_insert(
__i, __gnu_cxx::__ops::__val_comp_iter(__comp));
}
}

template <typename _RandomAccessIterator, typename _Compare>

inline void __unguarded_insertion_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last,
_Compare __comp) {
for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
std::__unguarded_linear_insert(__i,
__gnu_cxx::__ops::__val_comp_iter(__comp));
}

enum { _S_threshold = 16 };

template <typename _RandomAccessIterator, typename _Compare>

void __final_insertion_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
if (__last - __first > int(_S_threshold)) {
std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
__comp);
} else
std::__insertion_sort(__first, __last, __comp);
}

template <typename _RandomAccessIterator, typename _Compare>

_RandomAccessIterator __unguarded_partition(
_RandomAccessIterator __first, _RandomAccessIterator __last,
_RandomAccessIterator __pivot, _Compare __comp) {
while (true) {
while (__comp(__first, __pivot))
++__first;
--__last;
while (__comp(__pivot, __last))
--__last;
if (!(__first < __last))
return __first;
std::iter_swap(__first, __last);
++__first;
}
}

template <typename _RandomAccessIterator, typename _Compare>

inline _RandomAccessIterator __unguarded_partition_pivot(
_RandomAccessIterator __first, _RandomAccessIterator __last,
_Compare __comp) {
_RandomAccessIterator __mid = __first + (__last - __first) / 2;
std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
__comp);
return std::__unguarded_partition(__first + 1, __last, __first, __comp);
}

template <typename _RandomAccessIterator, typename _Compare>

inline void __partial_sort(_RandomAccessIterator __first,
_RandomAccessIterator __middle,
_RandomAccessIterator __last, _Compare __comp) {
std::__heap_select(__first, __middle, __last, __comp);
std::__sort_heap(__first, __middle, __comp);
}

template <typename _RandomAccessIterator, typename _Size, typename _Compare>

void __introsort_loop(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Size __depth_limit,
_Compare __comp) {
while (__last - __first > int(_S_threshold)) {
if (__depth_limit == 0) {
std::__partial_sort(__first, __last, __last, __comp);
return;
}
--__depth_limit;
_RandomAccessIterator __cut =
std::__unguarded_partition_pivot(__first, __last, __comp);
std::__introsort_loop(__cut, __last, __depth_limit, __comp);
__last = __cut;
}
}

template <typename _RandomAccessIterator, typename _Compare>

inline void __sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
if (__first != __last) {
std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2,
__comp);
std::__final_insertion_sort(__first, __last, __comp);
}
}

template <typename _RandomAccessIterator, typename _Size, typename _Compare>

void __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
_RandomAccessIterator __last, _Size __depth_limit,
_Compare __comp) {
while (__last - __first > 3) {
if (__depth_limit == 0) {
std::__heap_select(__first, __nth + 1, __last, __comp);

std::iter_swap(__first, __nth);
return;
}
--__depth_limit;
_RandomAccessIterator __cut =
std::__unguarded_partition_pivot(__first, __last, __comp);
if (__cut <= __nth)
__first = __cut;
else
__last = __cut;
}
std::__insertion_sort(__first, __last, __comp);
}
template <typename _ForwardIterator, typename _Tp, typename _Compare>

inline _ForwardIterator lower_bound(_ForwardIterator __first,
_ForwardIterator __last, const _Tp &__val,
_Compare __comp) {

;

return std::__lower_bound(__first, __last, __val,
__gnu_cxx::__ops::__iter_comp_val(__comp));
}

template <typename _ForwardIterator, typename _Tp, typename _Compare>

_ForwardIterator __upper_bound(_ForwardIterator __first,
_ForwardIterator __last, const _Tp &__val,
_Compare __comp) {
typedef typename iterator_traits<_ForwardIterator>::difference_type
_DistanceType;

_DistanceType __len = std::distance(__first, __last);

while (__len > 0) {
_DistanceType __half = __len >> 1;
_ForwardIterator __middle = __first;
std::advance(__middle, __half);
if (__comp(__val, __middle))
__len = __half;
else {
__first = __middle;
++__first;
__len = __len - __half - 1;
}
}
return __first;
}
template <typename _ForwardIterator, typename _Tp>

inline _ForwardIterator upper_bound(
_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

;

return std::__upper_bound(__first, __last, __val,
__gnu_cxx::__ops::__val_less_iter());
}
template <typename _ForwardIterator, typename _Tp, typename _Compare>

inline _ForwardIterator upper_bound(_ForwardIterator __first,
_ForwardIterator __last, const _Tp &__val,
_Compare __comp) {

;

return std::__upper_bound(__first, __last, __val,
__gnu_cxx::__ops::__val_comp_iter(__comp));
}

template <typename _ForwardIterator, typename _Tp, typename _CompareItTp,
typename _CompareTpIt>

pair<_ForwardIterator, _ForwardIterator> __equal_range(
_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
_CompareItTp __comp_it_val, _CompareTpIt __comp_val_it) {
typedef typename iterator_traits<_ForwardIterator>::difference_type
_DistanceType;

_DistanceType __len = std::distance(__first, __last);

while (__len > 0) {
_DistanceType __half = __len >> 1;
_ForwardIterator __middle = __first;
std::advance(__middle, __half);
if (__comp_it_val(__middle, __val)) {
__first = __middle;
++__first;
__len = __len - __half - 1;
} else if (__comp_val_it(__val, __middle))
__len = __half;
else {
_ForwardIterator __left =
std::__lower_bound(__first, __middle, __val, __comp_it_val);
std::advance(__first, __len);
_ForwardIterator __right =
std::__upper_bound(++__middle, __first, __val, __comp_val_it);
return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
}
}
return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}
template <typename _ForwardIterator, typename _Tp>

inline pair<_ForwardIterator, _ForwardIterator> equal_range(
_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

;
;

return std::__equal_range(__first, __last, __val,
__gnu_cxx::__ops::__iter_less_val(),
__gnu_cxx::__ops::__val_less_iter());
}
template <typename _ForwardIterator, typename _Tp, typename _Compare>

inline pair<_ForwardIterator, _ForwardIterator> equal_range(
_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
_Compare __comp) {

;

;

return std::__equal_range(__first, __last, __val,
__gnu_cxx::__ops::__iter_comp_val(__comp),
__gnu_cxx::__ops::__val_comp_iter(__comp));
}
template <typename _ForwardIterator, typename _Tp>

bool binary_search(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__val) {

;
;

_ForwardIterator __i = std::__lower_bound(
__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
return __i != __last && !(__val < *__i);
}
template <typename _ForwardIterator, typename _Tp, typename _Compare>

bool binary_search(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__val, _Compare __comp) {

;

;

_ForwardIterator __i = std::__lower_bound(
__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp));
return __i != __last && !bool(__comp(__val, *__i));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>
void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2) {
if (__comp(__first2, __first1)) {
*__result = std::move(*__first2);
++__first2;
} else {
*__result = std::move(*__first1);
++__first1;
}
++__result;
}
if (__first1 != __last1)
std::move(__first1, __last1, __result);
}

template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
typename _BidirectionalIterator3, typename _Compare>
void __move_merge_adaptive_backward(
_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
_BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
_BidirectionalIterator3 __result, _Compare __comp) {
if (__first1 == __last1) {
std::move_backward(__first2, __last2, __result);
return;
} else if (__first2 == __last2)
return;

--__last1;
--__last2;
while (true) {
if (__comp(__last2, __last1)) {
*--__result = std::move(*__last1);
if (__first1 == __last1) {
std::move_backward(__first2, ++__last2, __result);
return;
}
--__last1;
} else {
*--__result = std::move(*__last2);
if (__first2 == __last2)
return;
--__last2;
}
}
}

template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
typename _Distance>
_BidirectionalIterator1 __rotate_adaptive(
_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle,
_BidirectionalIterator1 __last, _Distance __len1, _Distance __len2,
_BidirectionalIterator2 __buffer, _Distance __buffer_size) {
_BidirectionalIterator2 __buffer_end;
if (__len1 > __len2 && __len2 <= __buffer_size) {
if (__len2) {
__buffer_end = std::move(__middle, __last, __buffer);
std::move_backward(__first, __middle, __last);
return std::move(__buffer, __buffer_end, __first);
} else
return __first;
} else if (__len1 <= __buffer_size) {
if (__len1) {
__buffer_end = std::move(__first, __middle, __buffer);
std::move(__middle, __last, __first);
return std::move_backward(__buffer, __buffer_end, __last);
} else
return __last;
} else
return std::rotate(__first, __middle, __last);
}

template <typename _BidirectionalIterator, typename _Distance,
typename _Pointer, typename _Compare>
void __merge_adaptive(
_BidirectionalIterator __first, _BidirectionalIterator __middle,
_BidirectionalIterator __last, _Distance __len1, _Distance __len2,
_Pointer __buffer, _Distance __buffer_size, _Compare __comp) {
if (__len1 <= __len2 && __len1 <= __buffer_size) {
_Pointer __buffer_end = std::move(__first, __middle, __buffer);
std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
__first, __comp);
} else if (__len2 <= __buffer_size) {
_Pointer __buffer_end = std::move(__middle, __last, __buffer);
std::__move_merge_adaptive_backward(__first, __middle, __buffer,
__buffer_end, __last, __comp);
} else {
_BidirectionalIterator __first_cut = __first;
_BidirectionalIterator __second_cut = __middle;
_Distance __len11 = 0;
_Distance __len22 = 0;
if (__len1 > __len2) {
__len11 = __len1 / 2;
std::advance(__first_cut, __len11);
__second_cut =
std::__lower_bound(__middle, __last, *__first_cut,
__gnu_cxx::__ops::__iter_comp_val(__comp));
__len22 = std::distance(__middle, __second_cut);
} else {
__len22 = __len2 / 2;
std::advance(__second_cut, __len22);
__first_cut =
std::__upper_bound(__first, __middle, *__second_cut,
__gnu_cxx::__ops::__val_comp_iter(__comp));
__len11 = std::distance(__first, __first_cut);
}

_BidirectionalIterator __new_middle = std::__rotate_adaptive(
__first_cut, __middle, __second_cut, __len1 - __len11, __len22,
__buffer, __buffer_size);
std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
__len22, __buffer, __buffer_size, __comp);
std::__merge_adaptive(__new_middle, __second_cut, __last,
__len1 - __len11, __len2 - __len22, __buffer,
__buffer_size, __comp);
}
}

template <typename _BidirectionalIterator, typename _Distance,
typename _Compare>
void __merge_without_buffer(_BidirectionalIterator __first,
_BidirectionalIterator __middle,
_BidirectionalIterator __last, _Distance __len1,
_Distance __len2, _Compare __comp) {
if (__len1 == 0 || __len2 == 0)
return;

if (__len1 + __len2 == 2) {
if (__comp(__middle, __first))
std::iter_swap(__first, __middle);
return;
}

_BidirectionalIterator __first_cut = __first;
_BidirectionalIterator __second_cut = __middle;
_Distance __len11 = 0;
_Distance __len22 = 0;
if (__len1 > __len2) {
__len11 = __len1 / 2;
std::advance(__first_cut, __len11);
__second_cut =
std::__lower_bound(__middle, __last, *__first_cut,
__gnu_cxx::__ops::__iter_comp_val(__comp));
__len22 = std::distance(__middle, __second_cut);
} else {
__len22 = __len2 / 2;
std::advance(__second_cut, __len22);
__first_cut =
std::__upper_bound(__first, __middle, *__second_cut,
__gnu_cxx::__ops::__val_comp_iter(__comp));
__len11 = std::distance(__first, __first_cut);
}

_BidirectionalIterator __new_middle =
std::rotate(__first_cut, __middle, __second_cut);
std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11,
__len22, __comp);
std::__merge_without_buffer(__new_middle, __second_cut, __last,
__len1 - __len11, __len2 - __len22, __comp);
}

template <typename _BidirectionalIterator, typename _Compare>
void __inplace_merge(_BidirectionalIterator __first,
_BidirectionalIterator __middle,
_BidirectionalIterator __last, _Compare __comp) {
typedef
typename iterator_traits<_BidirectionalIterator>::value_type _ValueType;
typedef typename iterator_traits<_BidirectionalIterator>::difference_type
_DistanceType;
typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;

if (__first == __middle || __middle == __last)
return;

const _DistanceType __len1 = std::distance(__first, __middle);
const _DistanceType __len2 = std::distance(__middle, __last);

_TmpBuf __buf(__first, std::min(__len1, __len2));

if (__buf.begin() == 0)
std::__merge_without_buffer(__first, __middle, __last, __len1, __len2,
__comp);
else
std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
__buf.begin(), _DistanceType(__buf.size()), __comp);
}
template <typename _BidirectionalIterator>
inline void inplace_merge(_BidirectionalIterator __first,
_BidirectionalIterator __middle,
_BidirectionalIterator __last) {

;
;
;

std::__inplace_merge(__first, __middle, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _BidirectionalIterator, typename _Compare>
inline void inplace_merge(_BidirectionalIterator __first,
_BidirectionalIterator __middle,
_BidirectionalIterator __last, _Compare __comp) {

;
;
;

std::__inplace_merge(__first, __middle, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator, typename _OutputIterator,
typename _Compare>
_OutputIterator __move_merge(_InputIterator __first1, _InputIterator __last1,
_InputIterator __first2, _InputIterator __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2) {
if (__comp(__first2, __first1)) {
*__result = std::move(*__first2);
++__first2;
} else {
*__result = std::move(*__first1);
++__first1;
}
++__result;
}
return std::move(__first2, __last2, std::move(__first1, __last1, __result))

;
}

template <typename _RandomAccessIterator1, typename _RandomAccessIterator2,
typename _Distance, typename _Compare>
void __merge_sort_loop(
_RandomAccessIterator1 __first, _RandomAccessIterator1 __last,
_RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp) {
const _Distance __two_step = 2 * __step_size;

while (__last - __first >= __two_step) {
__result = std::__move_merge(__first, __first + __step_size,
__first + __step_size, __first + __two_step,
__result, __comp);
__first += __two_step;
}
__step_size = std::min(_Distance(__last - __first), __step_size);

std::__move_merge(__first, __first + __step_size, __first + __step_size,
__last, __result, __comp);
}

template <typename _RandomAccessIterator, typename _Distance,
typename _Compare>

void __chunk_insertion_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last,
_Distance __chunk_size, _Compare __comp) {
while (__last - __first >= __chunk_size) {
std::__insertion_sort(__first, __first + __chunk_size, __comp);
__first += __chunk_size;
}
std::__insertion_sort(__first, __last, __comp);
}

enum { _S_chunk_size = 7 };

template <typename _RandomAccessIterator, typename _Pointer,
typename _Compare>
void __merge_sort_with_buffer(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Pointer __buffer,
_Compare __comp) {
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_Distance;

const _Distance __len = __last - __first;
const _Pointer __buffer_last = __buffer + __len;

_Distance __step_size = _S_chunk_size;
std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

while (__step_size < __len) {
std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
__step_size *= 2;
std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size,
__comp);
__step_size *= 2;
}
}

template <typename _RandomAccessIterator, typename _Pointer,
typename _Distance, typename _Compare>
void __stable_sort_adaptive(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Pointer __buffer,
_Distance __buffer_size, _Compare __comp) {
const _Distance __len = (__last - __first + 1) / 2;
const _RandomAccessIterator __middle = __first + __len;
if (__len > __buffer_size) {
std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
__comp);
std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
__comp);
} else {
std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
}

std::__merge_adaptive(
__first, __middle, __last, _Distance(__middle - __first),
_Distance(__last - __middle), __buffer, __buffer_size, __comp);
}

template <typename _RandomAccessIterator, typename _Compare>
void __inplace_stable_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
if (__last - __first < 15) {
std::__insertion_sort(__first, __last, __comp);
return;
}
_RandomAccessIterator __middle = __first + (__last - __first) / 2;
std::__inplace_stable_sort(__first, __middle, __comp);
std::__inplace_stable_sort(__middle, __last, __comp);
std::__merge_without_buffer(__first, __middle, __last, __middle - __first,
__last - __middle, __comp);
}
template <typename _InputIterator1, typename _InputIterator2,
typename _Compare>

bool __includes(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_Compare __comp) {
while (__first1 != __last1 && __first2 != __last2) {
if (__comp(__first2, __first1))
return false;
if (!__comp(__first1, __first2))
++__first2;
++__first1;
}

return __first2 == __last2;
}
template <typename _InputIterator1, typename _InputIterator2>

inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2) {

;
;
;
;

return std::__includes(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _Compare>

inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_Compare __comp) {

;
;
;
;

return std::__includes(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _BidirectionalIterator, typename _Compare>

bool __next_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last, _Compare __comp) {
if (__first == __last)
return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)
return false;
__i = __last;
--__i;

for (;;) {
_BidirectionalIterator __ii = __i;
--__i;
if (__comp(__i, __ii)) {
_BidirectionalIterator __j = __last;
while (!__comp(__i, --__j)) {
}
std::iter_swap(__i, __j);
std::__reverse(__ii, __last, std::__iterator_category(__first));
return true;
}
if (__i == __first) {
std::__reverse(__first, __last, std::__iterator_category(__first));
return false;
}
}
}
template <typename _BidirectionalIterator>

inline bool next_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last) {

;
;

return std::__next_permutation(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _BidirectionalIterator, typename _Compare>

inline bool next_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last, _Compare __comp) {

;
;

return std::__next_permutation(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _BidirectionalIterator, typename _Compare>

bool __prev_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last, _Compare __comp) {
if (__first == __last)
return false;
_BidirectionalIterator __i = __first;
++__i;
if (__i == __last)
return false;
__i = __last;
--__i;

for (;;) {
_BidirectionalIterator __ii = __i;
--__i;
if (__comp(__ii, __i)) {
_BidirectionalIterator __j = __last;
while (!__comp(--__j, __i)) {
}
std::iter_swap(__i, __j);
std::__reverse(__ii, __last, std::__iterator_category(__first));
return true;
}
if (__i == __first) {
std::__reverse(__first, __last, std::__iterator_category(__first));
return false;
}
}
}
template <typename _BidirectionalIterator>

inline bool prev_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last) {

;
;

return std::__prev_permutation(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _BidirectionalIterator, typename _Compare>

inline bool prev_permutation(_BidirectionalIterator __first,
_BidirectionalIterator __last, _Compare __comp) {

;
;

return std::__prev_permutation(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator, typename _OutputIterator,
typename _Predicate, typename _Tp>

_OutputIterator __replace_copy_if(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_Predicate __pred, const _Tp &__new_value) {
for (; __first != __last; ++__first, (void)++__result)
if (__pred(__first))
*__result = __new_value;
else
*__result = *__first;
return __result;
}
template <typename _InputIterator, typename _OutputIterator, typename _Tp>

inline _OutputIterator replace_copy(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
const _Tp &__old_value, const _Tp &__new_value) {

;

return std::__replace_copy_if(
__first, __last, __result,
__gnu_cxx::__ops::__iter_equals_val(__old_value), __new_value);
}
template <typename _InputIterator, typename _OutputIterator,
typename _Predicate, typename _Tp>

inline _OutputIterator replace_copy_if(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_Predicate __pred, const _Tp &__new_value) {

;

return std::__replace_copy_if(__first, __last, __result,
__gnu_cxx::__ops::__pred_iter(__pred),
__new_value);
}
template <typename _ForwardIterator>

inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last) {
return std::is_sorted_until(__first, __last) == __last;
}
template <typename _ForwardIterator, typename _Compare>

inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last,
_Compare __comp) {
return std::is_sorted_until(__first, __last, __comp) == __last;
}

template <typename _ForwardIterator, typename _Compare>

_ForwardIterator __is_sorted_until(_ForwardIterator __first,
_ForwardIterator __last, _Compare __comp) {
if (__first == __last)
return __last;

_ForwardIterator __next = __first;
for (++__next; __next != __last; __first = __next, (void)++__next)
if (__comp(__next, __first))
return __next;
return __next;
}
template <typename _ForwardIterator>

inline _ForwardIterator is_sorted_until(_ForwardIterator __first,
_ForwardIterator __last) {

;
;

return std::__is_sorted_until(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _ForwardIterator, typename _Compare>

inline _ForwardIterator is_sorted_until(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

;
;

return std::__is_sorted_until(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _Tp>
constexpr inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a,
const _Tp &__b) {

return __b < __a ? pair<const _Tp &, const _Tp &>(__b, __a)
: pair<const _Tp &, const _Tp &>(__a, __b);
}
template <typename _Tp, typename _Compare>
constexpr inline pair<const _Tp &, const _Tp &> minmax(
const _Tp &__a, const _Tp &__b, _Compare __comp) {
return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a)
: pair<const _Tp &, const _Tp &>(__a, __b);
}

template <typename _ForwardIterator, typename _Compare>
constexpr pair<_ForwardIterator, _ForwardIterator> __minmax_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
_ForwardIterator __next = __first;
if (__first == __last || ++__next == __last)
return std::make_pair(__first, __first);

_ForwardIterator __min{}, __max{};
if (__comp(__next, __first)) {
__min = __next;
__max = __first;
} else {
__min = __first;
__max = __next;
}

__first = __next;
++__first;

while (__first != __last) {
__next = __first;
if (++__next == __last) {
if (__comp(__first, __min))
__min = __first;
else if (!__comp(__first, __max))
__max = __first;
break;
}

if (__comp(__next, __first)) {
if (__comp(__next, __min))
__min = __next;
if (!__comp(__first, __max))
__max = __first;
} else {
if (__comp(__first, __min))
__min = __first;
if (!__comp(__next, __max))
__max = __next;
}

__first = __next;
++__first;
}

return std::make_pair(__min, __max);
}
template <typename _ForwardIterator>
constexpr inline pair<_ForwardIterator, _ForwardIterator> minmax_element(
_ForwardIterator __first, _ForwardIterator __last) {

;
;

return std::__minmax_element(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _ForwardIterator, typename _Compare>
constexpr inline pair<_ForwardIterator, _ForwardIterator> minmax_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

;
;

return std::__minmax_element(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _Tp>
constexpr inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __l) {
;
pair<const _Tp *, const _Tp *> __p = std::__minmax_element(
__l.begin(), __l.end(), __gnu_cxx::__ops::__iter_less_iter());
return std::make_pair(*__p.first, *__p.second);
}

template <typename _Tp, typename _Compare>
constexpr inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __l,
_Compare __comp) {
;
pair<const _Tp *, const _Tp *> __p = std::__minmax_element(
__l.begin(), __l.end(), __gnu_cxx::__ops::__iter_comp_iter(__comp));
return std::make_pair(*__p.first, *__p.second);
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

inline bool is_permutation(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _BinaryPredicate __pred) {

;

return std::__is_permutation(__first1, __last1, __first2,
__gnu_cxx::__ops::__iter_comp_iter(__pred));
}

template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
_BinaryPredicate __pred) {
using _Cat1 =
typename iterator_traits<_ForwardIterator1>::iterator_category;
using _Cat2 =
typename iterator_traits<_ForwardIterator2>::iterator_category;
using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
if (__ra_iters) {
auto __d1 = std::distance(__first1, __last1);
auto __d2 = std::distance(__first2, __last2);
if (__d1 != __d2)
return false;
}

for (; __first1 != __last1 && __first2 != __last2;
++__first1, (void)++__first2)
if (!__pred(__first1, __first2))
break;

if (__ra_iters) {
if (__first1 == __last1)
return true;
} else {
auto __d1 = std::distance(__first1, __last1);
auto __d2 = std::distance(__first2, __last2);
if (__d1 == 0 && __d2 == 0)
return true;
if (__d1 != __d2)
return false;
}

for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
if (__scan !=
std::__find_if(__first1, __scan,
__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
continue;

auto __matches =
std::__count_if(__first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
if (0 == __matches || std::__count_if(__scan, __last1,
__gnu_cxx::__ops::__iter_comp_iter(
__pred, __scan)) != __matches)
return false;
}
return true;
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

inline bool is_permutation(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2) {
;
;

return std::__is_permutation(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

inline bool is_permutation(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
_BinaryPredicate __pred) {
;
;

return std::__is_permutation(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__pred));
}
template <typename _Tp>
constexpr const _Tp &clamp(const _Tp &__val, const _Tp &__lo,
const _Tp &__hi) {
do {
if (std::__is_constant_evaluated() && !bool(!(__hi < __lo)))
__builtin_unreachable();
} while (false);
return std::min(std::max(__val, __lo), __hi);
}
template <typename _Tp, typename _Compare>
constexpr const _Tp &clamp(const _Tp &__val, const _Tp &__lo, const _Tp &__hi,
_Compare __comp) {
do {
if (std::__is_constant_evaluated() && !bool(!__comp(__hi, __lo)))
__builtin_unreachable();
} while (false);
return std::min(std::max(__val, __lo, __comp), __hi, __comp);
}
template <typename _IntType, typename _UniformRandomBitGenerator>
pair<_IntType, _IntType> __gen_two_uniform_ints(
_IntType __b0, _IntType __b1, _UniformRandomBitGenerator && __g) {
_IntType __x =
uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
return std::make_pair(__x / __b1, __x % __b1);
}
template <typename _RandomAccessIterator,
typename _UniformRandomNumberGenerator>
void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
_UniformRandomNumberGenerator && __g) {

;

if (__first == __last)
return;

typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;

typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
typedef typename __distr_type::param_type __p_type;

typedef typename remove_reference<_UniformRandomNumberGenerator>::type _Gen;
typedef typename common_type<typename _Gen::result_type, __ud_type>::type
__uc_type;

const __uc_type __urngrange = __g.max() - __g.min();
const __uc_type __urange = __uc_type(__last - __first);

if (__urngrange / __urange >= __urange)

{
_RandomAccessIterator __i = __first + 1;

if ((__urange % 2) == 0) {
__distr_type __d{0, 1};
std::iter_swap(__i++, __first + __d(__g));
}

while (__i != __last) {
const __uc_type __swap_range = __uc_type(__i - __first) + 1;

const pair<__uc_type, __uc_type> __pospos =
__gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

std::iter_swap(__i++, __first + __pospos.first);
std::iter_swap(__i++, __first + __pospos.second);
}

return;
}

__distr_type __d;

for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
}

template <typename _InputIterator, typename _Function>

_Function for_each(_InputIterator __first, _InputIterator __last,
_Function __f) {

;
for (; __first != __last; ++__first)
__f(*__first);
return __f;
}
template <typename _InputIterator, typename _Size, typename _Function>

_InputIterator for_each_n(_InputIterator __first, _Size __n, _Function __f) {
auto __n2 = std::__size_to_integer(__n);
using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>) {
if (__n2 <= 0)
return __first;
auto __last = __first + __n2;
std::for_each(__first, __last, std::move(__f));
return __last;
} else {
while (__n2-- > 0) {
__f(*__first);
++__first;
}
return __first;
}
}
template <typename _InputIterator, typename _Tp>

inline _InputIterator find(_InputIterator __first, _InputIterator __last,
const _Tp &__val) {

;
return std::__find_if(__first, __last,
__gnu_cxx::__ops::__iter_equals_val(__val));
}
template <typename _InputIterator, typename _Predicate>

inline _InputIterator find_if(_InputIterator __first, _InputIterator __last,
_Predicate __pred) {

;

return std::__find_if(__first, __last,
__gnu_cxx::__ops::__pred_iter(__pred));
}
template <typename _InputIterator, typename _ForwardIterator>

_InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1,
_ForwardIterator __first2,
_ForwardIterator __last2) {

;
;

for (; __first1 != __last1; ++__first1)
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
if (*__first1 == *__iter)
return __first1;
return __last1;
}
template <typename _InputIterator, typename _ForwardIterator,
typename _BinaryPredicate>

_InputIterator find_first_of(_InputIterator __first1, _InputIterator __last1,
_ForwardIterator __first2,
_ForwardIterator __last2,
_BinaryPredicate __comp) {

;
;

for (; __first1 != __last1; ++__first1)
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
if (__comp(*__first1, *__iter))
return __first1;
return __last1;
}
template <typename _ForwardIterator>

inline _ForwardIterator adjacent_find(_ForwardIterator __first,
_ForwardIterator __last) {

;

return std::__adjacent_find(__first, __last,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _ForwardIterator, typename _BinaryPredicate>

inline _ForwardIterator adjacent_find(_ForwardIterator __first,
_ForwardIterator __last,
_BinaryPredicate __binary_pred) {

;

return std::__adjacent_find(
__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
}
template <typename _InputIterator, typename _Tp>

inline typename iterator_traits<_InputIterator>::difference_type count(
_InputIterator __first, _InputIterator __last, const _Tp &__value) {

;

return std::__count_if(__first, __last,
__gnu_cxx::__ops::__iter_equals_val(__value));
}
template <typename _InputIterator, typename _Predicate>

inline typename iterator_traits<_InputIterator>::difference_type count_if(
_InputIterator __first, _InputIterator __last, _Predicate __pred) {

;

return std::__count_if(__first, __last,
__gnu_cxx::__ops::__pred_iter(__pred));
}
template <typename _ForwardIterator1, typename _ForwardIterator2>

inline _ForwardIterator1 search(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2) {

;
;

return std::__search(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_equal_to_iter());
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
typename _BinaryPredicate>

inline _ForwardIterator1 search(
_ForwardIterator1 __first1, _ForwardIterator1 __last1,
_ForwardIterator2 __first2, _ForwardIterator2 __last2,
_BinaryPredicate __predicate) {

;
;

return std::__search(__first1, __last1, __first2, __last2,
__gnu_cxx::__ops::__iter_comp_iter(__predicate));
}
template <typename _ForwardIterator, typename _Integer, typename _Tp>

inline _ForwardIterator search_n(_ForwardIterator __first,
_ForwardIterator __last, _Integer __count,
const _Tp &__val) {

;

return std::__search_n(__first, __last, __count,
__gnu_cxx::__ops::__iter_equals_val(__val));
}
template <typename _ForwardIterator, typename _Integer, typename _Tp,
typename _BinaryPredicate>

inline _ForwardIterator search_n(
_ForwardIterator __first, _ForwardIterator __last, _Integer __count,
const _Tp &__val, _BinaryPredicate __binary_pred) {

;

return std::__search_n(
__first, __last, __count,
__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
}
template <typename _ForwardIterator, typename _Searcher>

inline _ForwardIterator search(_ForwardIterator __first,
_ForwardIterator __last,
const _Searcher &__searcher) {
return __searcher(__first, __last).first;
}
template <typename _InputIterator, typename _OutputIterator,
typename _UnaryOperation>

_OutputIterator transform(_InputIterator __first, _InputIterator __last,
_OutputIterator __result,
_UnaryOperation __unary_op) {

;

for (; __first != __last; ++__first, (void)++__result)
*__result = __unary_op(*__first);
return __result;
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _BinaryOperation>

_OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _OutputIterator __result,
_BinaryOperation __binary_op) {

;

for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
*__result = __binary_op(*__first1, *__first2);
return __result;
}
template <typename _ForwardIterator, typename _Tp>

void replace(_ForwardIterator __first, _ForwardIterator __last,
const _Tp &__old_value, const _Tp &__new_value) {

;

for (; __first != __last; ++__first)
if (*__first == __old_value)
*__first = __new_value;
}
template <typename _ForwardIterator, typename _Predicate, typename _Tp>

void replace_if(_ForwardIterator __first, _ForwardIterator __last,
_Predicate __pred, const _Tp &__new_value) {

;

for (; __first != __last; ++__first)
if (__pred(*__first))
*__first = __new_value;
}
template <typename _ForwardIterator, typename _Generator>

void generate(_ForwardIterator __first, _ForwardIterator __last,
_Generator __gen) {

;

for (; __first != __last; ++__first)
*__first = __gen();
}
template <typename _OutputIterator, typename _Size, typename _Generator>

_OutputIterator generate_n(_OutputIterator __first, _Size __n,
_Generator __gen) {

typedef __decltype(std::__size_to_integer(__n)) _IntSize;
for (_IntSize __niter = std::__size_to_integer(__n); __niter > 0;
--__niter, (void)++__first)
*__first = __gen();
return __first;
}
template <typename _InputIterator, typename _OutputIterator>

inline _OutputIterator unique_copy(
_InputIterator __first, _InputIterator __last, _OutputIterator __result) {

;

if (__first == __last)
return __result;
return std::__unique_copy(
__first, __last, __result, __gnu_cxx::__ops::__iter_equal_to_iter(),
std::__iterator_category(__first), std::__iterator_category(__result));
}
template <typename _InputIterator, typename _OutputIterator,
typename _BinaryPredicate>

inline _OutputIterator unique_copy(
_InputIterator __first, _InputIterator __last, _OutputIterator __result,
_BinaryPredicate __binary_pred) {

;

if (__first == __last)
return __result;
return std::__unique_copy(__first, __last, __result,
__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
std::__iterator_category(__first),
std::__iterator_category(__result));
}
template <typename _RandomAccessIterator>
__attribute__((__deprecated__("use '"
"std::shuffle"
"' instead"))) inline void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) {

;

if (__first != __last)
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {

_RandomAccessIterator __j =
__first + std::rand() % ((__i - __first) + 1);
if (__i != __j)
std::iter_swap(__i, __j);
}
}
template <typename _RandomAccessIterator, typename _RandomNumberGenerator>
__attribute__((__deprecated__("use '"
"std::shuffle"
"' instead"))) void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

_RandomNumberGenerator && __rand)

{

;

if (__first == __last)
return;
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
_RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
if (__i != __j)
std::iter_swap(__i, __j);
}
}
template <typename _ForwardIterator, typename _Predicate>

inline _ForwardIterator partition(
_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

;

return std::__partition(__first, __last, __pred,
std::__iterator_category(__first));
}
template <typename _RandomAccessIterator>

inline void partial_sort(_RandomAccessIterator __first,
_RandomAccessIterator __middle,
_RandomAccessIterator __last) {

;
;
;

std::__partial_sort(__first, __middle, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _RandomAccessIterator, typename _Compare>

inline void partial_sort(_RandomAccessIterator __first,
_RandomAccessIterator __middle,
_RandomAccessIterator __last, _Compare __comp) {

;
;
;

std::__partial_sort(__first, __middle, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _RandomAccessIterator>

inline void nth_element(_RandomAccessIterator __first,
_RandomAccessIterator __nth,
_RandomAccessIterator __last) {

;
;
;

if (__first == __last || __nth == __last)
return;

std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _RandomAccessIterator, typename _Compare>

inline void nth_element(_RandomAccessIterator __first,
_RandomAccessIterator __nth,
_RandomAccessIterator __last, _Compare __comp) {

;
;
;

if (__first == __last || __nth == __last)
return;

std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}
template <typename _RandomAccessIterator>

inline void sort(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;

std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
}
template <typename _RandomAccessIterator, typename _Compare>

inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
_Compare __comp) {

;
;

std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

_OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2) {
if (__comp(__first2, __first1)) {
*__result = *__first2;
++__first2;
} else {
*__result = *__first1;
++__first1;
}
++__result;
}
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator>

inline _OutputIterator merge(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result) {

;
;
;
;

return std::__merge(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

inline _OutputIterator merge(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {

;
;
;
;

return std::__merge(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _RandomAccessIterator, typename _Compare>
inline void __stable_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {
typedef
typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
typedef typename iterator_traits<_RandomAccessIterator>::difference_type
_DistanceType;
typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;

if (__first == __last)
return;

_TmpBuf __buf(__first, (__last - __first + 1) / 2);

if (__buf.begin() == 0)
std::__inplace_stable_sort(__first, __last, __comp);
else
std::__stable_sort_adaptive(__first, __last, __buf.begin(),
_DistanceType(__buf.size()), __comp);
}
template <typename _RandomAccessIterator>
inline void stable_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last) {

;
;

std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
}
template <typename _RandomAccessIterator, typename _Compare>
inline void stable_sort(_RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp) {

;
;

std::__stable_sort(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

_OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2) {
if (__comp(__first1, __first2)) {
*__result = *__first1;
++__first1;
} else if (__comp(__first2, __first1)) {
*__result = *__first2;
++__first2;
} else {
*__result = *__first1;
++__first1;
++__first2;
}
++__result;
}
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator>

inline _OutputIterator set_union(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result) {

;
;
;
;

return std::__set_union(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

inline _OutputIterator set_union(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {

;
;
;
;

return std::__set_union(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

_OutputIterator __set_intersection(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2)
if (__comp(__first1, __first2))
++__first1;
else if (__comp(__first2, __first1))
++__first2;
else {
*__result = *__first1;
++__first1;
++__first2;
++__result;
}
return __result;
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator>

inline _OutputIterator set_intersection(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result) {

;
;
;
;

return std::__set_intersection(__first1, __last1, __first2, __last2,
__result,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

inline _OutputIterator set_intersection(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {

;
;
;
;

return std::__set_intersection(__first1, __last1, __first2, __last2,
__result,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

_OutputIterator __set_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2)
if (__comp(__first1, __first2)) {
*__result = *__first1;
++__first1;
++__result;
} else if (__comp(__first2, __first1))
++__first2;
else {
++__first1;
++__first2;
}
return std::copy(__first1, __last1, __result);
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator>

inline _OutputIterator set_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result) {

;
;
;
;

return std::__set_difference(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

inline _OutputIterator set_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {

;
;
;
;

return std::__set_difference(__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

_OutputIterator __set_symmetric_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {
while (__first1 != __last1 && __first2 != __last2)
if (__comp(__first1, __first2)) {
*__result = *__first1;
++__first1;
++__result;
} else if (__comp(__first2, __first1)) {
*__result = *__first2;
++__first2;
++__result;
} else {
++__first1;
++__first2;
}
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator>

inline _OutputIterator set_symmetric_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result) {

;
;
;
;

return std::__set_symmetric_difference(
__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _InputIterator1, typename _InputIterator2,
typename _OutputIterator, typename _Compare>

inline _OutputIterator set_symmetric_difference(
_InputIterator1 __first1, _InputIterator1 __last1,
_InputIterator2 __first2, _InputIterator2 __last2,
_OutputIterator __result, _Compare __comp) {

;
;
;
;

return std::__set_symmetric_difference(
__first1, __last1, __first2, __last2, __result,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _ForwardIterator, typename _Compare>
constexpr _ForwardIterator __min_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
if (__first == __last)
return __first;
_ForwardIterator __result = __first;
while (++__first != __last)
if (__comp(__first, __result))
__result = __first;
return __result;
}
template <typename _ForwardIterator>
constexpr _ForwardIterator inline min_element(_ForwardIterator __first,
_ForwardIterator __last) {

;
;

return std::__min_element(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _ForwardIterator, typename _Compare>
constexpr inline _ForwardIterator min_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

;
;

return std::__min_element(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _ForwardIterator, typename _Compare>
constexpr _ForwardIterator __max_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
if (__first == __last)
return __first;
_ForwardIterator __result = __first;
while (++__first != __last)
if (__comp(__result, __first))
__result = __first;
return __result;
}
template <typename _ForwardIterator>
constexpr inline _ForwardIterator max_element(_ForwardIterator __first,
_ForwardIterator __last) {

;
;

return std::__max_element(__first, __last,
__gnu_cxx::__ops::__iter_less_iter());
}
template <typename _ForwardIterator, typename _Compare>
constexpr inline _ForwardIterator max_element(
_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

;
;

return std::__max_element(__first, __last,
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _Tp> constexpr inline _Tp min(initializer_list<_Tp> __l) {
;
return *std::__min_element(__l.begin(), __l.end(),
__gnu_cxx::__ops::__iter_less_iter());
}

template <typename _Tp, typename _Compare>
constexpr inline _Tp min(initializer_list<_Tp> __l, _Compare __comp) {
;
return *std::__min_element(__l.begin(), __l.end(),
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _Tp> constexpr inline _Tp max(initializer_list<_Tp> __l) {
;
return *std::__max_element(__l.begin(), __l.end(),
__gnu_cxx::__ops::__iter_less_iter());
}

template <typename _Tp, typename _Compare>
constexpr inline _Tp max(initializer_list<_Tp> __l, _Compare __comp) {
;
return *std::__max_element(__l.begin(), __l.end(),
__gnu_cxx::__ops::__iter_comp_iter(__comp));
}

template <typename _InputIterator, typename _RandomAccessIterator,
typename _Size, typename _UniformRandomBitGenerator>
_RandomAccessIterator __sample(
_InputIterator __first, _InputIterator __last, input_iterator_tag,
_RandomAccessIterator __out, random_access_iterator_tag, _Size __n,
_UniformRandomBitGenerator && __g) {
using __distrib_type = uniform_int_distribution<_Size>;
using __param_type = typename __distrib_type::param_type;
__distrib_type __d{};
_Size __sample_sz = 0;
while (__first != __last && __sample_sz != __n) {
__out[__sample_sz++] = *__first;
++__first;
}
for (auto __pop_sz = __sample_sz; __first != __last;
++__first, (void)++__pop_sz) {
const auto __k = __d(__g, __param_type{0, __pop_sz});
if (__k < __n)
__out[__k] = *__first;
}
return __out + __sample_sz;
}

template <typename _ForwardIterator, typename _OutputIterator, typename _Cat,
typename _Size, typename _UniformRandomBitGenerator>
_OutputIterator __sample(_ForwardIterator __first, _ForwardIterator __last,
forward_iterator_tag, _OutputIterator __out, _Cat,
_Size __n, _UniformRandomBitGenerator && __g) {
using __distrib_type = uniform_int_distribution<_Size>;
using __param_type = typename __distrib_type::param_type;
using _USize = make_unsigned_t<_Size>;
using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

if (__first == __last)
return __out;

__distrib_type __d{};
_Size __unsampled_sz = std::distance(__first, __last);
__n = std::min(__n, __unsampled_sz);

const __uc_type __urngrange = __g.max() - __g.min();
if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))

{
while (__n != 0 && __unsampled_sz >= 2) {
const pair<_Size, _Size> __p =
__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

--__unsampled_sz;
if (__p.first < __n) {
*__out++ = *__first;
--__n;
}

++__first;

if (__n == 0)
break;

--__unsampled_sz;
if (__p.second < __n) {
*__out++ = *__first;
--__n;
}

++__first;
}
}

for (; __n != 0; ++__first)
if (__d(__g, __param_type{0, --__unsampled_sz}) < __n) {
*__out++ = *__first;
--__n;
}
return __out;
}

template <typename _PopulationIterator, typename _SampleIterator,
typename _Distance, typename _UniformRandomBitGenerator>
_SampleIterator sample(_PopulationIterator __first,
_PopulationIterator __last, _SampleIterator __out,
_Distance __n, _UniformRandomBitGenerator && __g) {
using __pop_cat =
typename std::iterator_traits<_PopulationIterator>::iterator_category;
using __samp_cat =
typename std::iterator_traits<_SampleIterator>::iterator_category;

static_assert(
__or_<is_convertible<__pop_cat, forward_iterator_tag>,
is_convertible<__samp_cat, random_access_iterator_tag>>::value,
"output range must use a RandomAccessIterator when input range"
" does not meet the ForwardIterator requirements");

static_assert(is_integral<_Distance>::value,
"sample size must be an integer type");

typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
return std::__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
std::forward<_UniformRandomBitGenerator>(__g));
}

} // namespace std
namespace __pstl {
namespace execution {
inline namespace v1 {

class sequenced_policy {
public:
static constexpr std::false_type __allow_unsequenced() {
return std::false_type{};
}
static constexpr std::false_type __allow_vector() {
return std::false_type{};
}
static constexpr std::false_type __allow_parallel() {
return std::false_type{};
}
};

class parallel_policy {
public:
static constexpr std::false_type __allow_unsequenced() {
return std::false_type{};
}
static constexpr std::false_type __allow_vector() {
return std::false_type{};
}
static constexpr std::true_type __allow_parallel() {
return std::true_type{};
}
};

class parallel_unsequenced_policy {
public:
static constexpr std::true_type __allow_unsequenced() {
return std::true_type{};
}
static constexpr std::true_type __allow_vector() { return std::true_type{}; }
static constexpr std::true_type __allow_parallel() {
return std::true_type{};
}
};

class unsequenced_policy {
public:
static constexpr std::true_type __allow_unsequenced() {
return std::true_type{};
}
static constexpr std::true_type __allow_vector() { return std::true_type{}; }
static constexpr std::false_type __allow_parallel() {
return std::false_type{};
}
};

constexpr sequenced_policy seq{};
constexpr parallel_policy par{};
constexpr parallel_unsequenced_policy par_unseq{};
constexpr unsequenced_policy unseq{};

template <class _Tp> struct is_execution_policy : std::false_type {};

template <>
struct is_execution_policy<__pstl::execution::sequenced_policy>
: std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::parallel_policy>
: std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::parallel_unsequenced_policy>
: std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::unsequenced_policy>
: std::true_type {};

template <class _Tp>
constexpr bool is_execution_policy_v =
__pstl::execution::is_execution_policy<_Tp>::value;

} // namespace v1
} // namespace execution

namespace __internal {
template <class _ExecPolicy, class _Tp>

using __enable_if_execution_policy =
typename std::enable_if<__pstl::execution::is_execution_policy<
std::__remove_cvref_t<_ExecPolicy>>::value,
_Tp>::type;

}

} // namespace __pstl

namespace std {

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
any_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
all_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
none_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
for_each(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
for_each_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __n,
_Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
find_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
find_if_not(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator,
class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy,
typename iterator_traits<_ForwardIterator>::difference_type>
count(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy,
typename iterator_traits<_ForwardIterator>::difference_type>
count_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __s_first,
_ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
class _Tp, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Size __count, const _Tp &__value,
_BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Size __count, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
copy_n(_ExecutionPolicy &&__exec, _ForwardIterator1 __first, _Size __n,
_ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 result, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
swap_ranges(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
_UnaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator,
class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator __result, _BinaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _UnaryPredicate __pred,
const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, const _Tp &__old_value,
const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
replace_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
_UnaryPredicate __pred, const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
replace_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
const _Tp &__old_value, const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
fill(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
fill_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __count,
const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
generate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
generate_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size count,
_Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
remove_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
_Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
remove_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
remove_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
remove(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator,
class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result,
_BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
reverse(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
_BidirectionalIterator __last);

template <class _ExecutionPolicy, class _BidirectionalIterator,
class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
reverse_copy(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
_BidirectionalIterator __last, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
rotate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __middle, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
rotate_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __middle, _ForwardIterator1 __last,
_ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_partitioned(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
partition(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _BidirectionalIterator,
class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_BidirectionalIterator>
stable_partition(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
_BidirectionalIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator,
class _ForwardIterator1, class _ForwardIterator2,
class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
partition_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _ForwardIterator1 __out_true,
_ForwardIterator2 __out_false, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator2>
move(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
_ForwardIterator1 __last, _ForwardIterator2 __d_first);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __middle, _RandomAccessIterator __last,
_Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __middle, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator,
class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _RandomAccessIterator __d_first,
_RandomAccessIterator __d_last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator,
class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _RandomAccessIterator __d_first,
_RandomAccessIterator __d_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __nth, _RandomAccessIterator __last,
_Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __nth, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
_BidirectionalIterator __middle, _BidirectionalIterator __last,
_Compare __comp);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
_BidirectionalIterator __middle, _BidirectionalIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result,
_Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result,
_Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result,
_Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator result,
_Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
_RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
_ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<
_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
_ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
_ForwardIterator1 __last1, _ForwardIterator2 __first2,
_ForwardIterator2 __last2);

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename> class allocator;

template <> class allocator<void>;

template <typename, typename> struct uses_allocator;

template <typename> struct allocator_traits;

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <class _CharT> struct char_traits;

template <> struct char_traits<char>;

template <> struct char_traits<wchar_t>;

template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;

namespace __cxx11 {

template <typename _CharT, typename _Traits = char_traits<_CharT>,
typename _Alloc = allocator<_CharT>>
class basic_string;

}

typedef basic_string<char> string;

typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;

typedef basic_string<char32_t> u32string;

} // namespace std

typedef __builtin_va_list __gnuc_va_list;

typedef unsigned int wint_t;

typedef struct {
int __count;
union {
unsigned int __wch;
char __wchb[4];
} __value;
} __mbstate_t;

typedef __mbstate_t mbstate_t;

struct _IO_FILE;
typedef struct _IO_FILE __FILE;

struct _IO_FILE;

typedef struct _IO_FILE FILE;
extern "C" {

struct tm;

extern wchar_t *wcscpy(wchar_t *__restrict __dest,
const wchar_t *__restrict __src) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern wchar_t *wcsncpy(wchar_t *__restrict __dest,
const wchar_t *__restrict __src,
size_t __n) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern wchar_t *wcscat(wchar_t *__restrict __dest,
const wchar_t *__restrict __src) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern wchar_t *wcsncat(wchar_t *__restrict __dest,
const wchar_t *__restrict __src,
size_t __n) noexcept(true)
__attribute__((__nonnull__(1, 2)));

extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true)
__attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));

extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2,
size_t __n) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1, 2)));

extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);

extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2,
size_t __n) noexcept(true);

extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2,
locale_t __loc) noexcept(true);

extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n,
locale_t __loc) noexcept(true);

extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);

extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2,
size_t __n) noexcept(true);

extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2,
locale_t __loc) noexcept(true);

extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n,
locale_t __loc) noexcept(true);

extern wchar_t *wcsdup(const wchar_t *__s) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(__builtin_free, 1)));

extern "C++" wchar_t *wcschr(wchar_t *__wcs,
wchar_t __wc) noexcept(true) __asm("wcschr")
__attribute__((__pure__));
extern "C++" const wchar_t *wcschr(const wchar_t *__wcs,
wchar_t __wc) noexcept(true) __asm("wcschr")
__attribute__((__pure__));

extern "C++" wchar_t *wcsrchr(wchar_t *__wcs,
wchar_t __wc) noexcept(true) __asm("wcsrchr")
__attribute__((__pure__));
extern "C++" const wchar_t *
wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __asm("wcsrchr")
__attribute__((__pure__));
extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true)
__attribute__((__pure__));

extern size_t wcscspn(const wchar_t *__wcs,
const wchar_t *__reject) noexcept(true)
__attribute__((__pure__));

extern size_t wcsspn(const wchar_t *__wcs,
const wchar_t *__accept) noexcept(true)
__attribute__((__pure__));

extern "C++" wchar_t *
wcspbrk(wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __asm("wcspbrk")
__attribute__((__pure__));
extern "C++" const wchar_t *
wcspbrk(const wchar_t *__wcs,
const wchar_t *__accept) noexcept(true) __asm("wcspbrk")
__attribute__((__pure__));

extern "C++" wchar_t *
wcsstr(wchar_t *__haystack,
const wchar_t *__needle) noexcept(true) __asm("wcsstr")
__attribute__((__pure__));
extern "C++" const wchar_t *
wcsstr(const wchar_t *__haystack,
const wchar_t *__needle) noexcept(true) __asm("wcsstr")
__attribute__((__pure__));

extern wchar_t *wcstok(wchar_t *__restrict __s,
const wchar_t *__restrict __delim,
wchar_t **__restrict __ptr) noexcept(true);

extern size_t wcslen(const wchar_t *__s) noexcept(true)
__attribute__((__pure__));

extern "C++" wchar_t *
wcswcs(wchar_t *__haystack,
const wchar_t *__needle) noexcept(true) __asm("wcswcs")
__attribute__((__pure__));
extern "C++" const wchar_t *
wcswcs(const wchar_t *__haystack,
const wchar_t *__needle) noexcept(true) __asm("wcswcs")
__attribute__((__pure__));
extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true)
__attribute__((__pure__));

extern "C++" wchar_t *wmemchr(wchar_t *__s, wchar_t __c,
size_t __n) noexcept(true) __asm("wmemchr")
__attribute__((__pure__));
extern "C++" const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c,
size_t __n) noexcept(true) __asm("wmemchr")
__attribute__((__pure__));

extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2,
size_t __n) noexcept(true) __attribute__((__pure__));

extern wchar_t *wmemcpy(wchar_t *__restrict __s1,
const wchar_t *__restrict __s2,
size_t __n) noexcept(true);

extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2,
size_t __n) noexcept(true);

extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);

extern wchar_t *wmempcpy(wchar_t *__restrict __s1,
const wchar_t *__restrict __s2,
size_t __n) noexcept(true);

extern wint_t btowc(int __c) noexcept(true);

extern int wctob(wint_t __c) noexcept(true);

extern int mbsinit(const mbstate_t *__ps) noexcept(true)
__attribute__((__pure__));

extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s,
size_t __n, mbstate_t *__restrict __p) noexcept(true);

extern size_t wcrtomb(char *__restrict __s, wchar_t __wc,
mbstate_t *__restrict __ps) noexcept(true);

extern size_t __mbrlen(const char *__restrict __s, size_t __n,
mbstate_t *__restrict __ps) noexcept(true);
extern size_t mbrlen(const char *__restrict __s, size_t __n,
mbstate_t *__restrict __ps) noexcept(true);
extern size_t mbsrtowcs(wchar_t *__restrict __dst,
const char **__restrict __src, size_t __len,
mbstate_t *__restrict __ps) noexcept(true);

extern size_t wcsrtombs(char *__restrict __dst,
const wchar_t **__restrict __src, size_t __len,
mbstate_t *__restrict __ps) noexcept(true);

extern size_t mbsnrtowcs(wchar_t *__restrict __dst,
const char **__restrict __src, size_t __nmc,
size_t __len,
mbstate_t *__restrict __ps) noexcept(true);

extern size_t wcsnrtombs(char *__restrict __dst,
const wchar_t **__restrict __src, size_t __nwc,
size_t __len,
mbstate_t *__restrict __ps) noexcept(true);

extern int wcwidth(wchar_t __c) noexcept(true);

extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(true);

extern double wcstod(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);

extern float wcstof(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);
extern long double wcstold(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);
extern _Float32 wcstof32(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);

extern _Float64 wcstof64(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);

extern _Float128 wcstof128(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);

extern _Float32x wcstof32x(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);

extern _Float64x wcstof64x(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr) noexcept(true);
extern long int wcstol(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
int __base) noexcept(true);

extern unsigned long int wcstoul(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
int __base) noexcept(true);

__extension__ extern long long int wcstoll(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
int __base) noexcept(true);

__extension__ extern unsigned long long int
wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
int __base) noexcept(true);

__extension__ extern long long int wcstoq(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
int __base) noexcept(true);

__extension__ extern unsigned long long int
wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
int __base) noexcept(true);

extern long int wcstol_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr, int __base,
locale_t __loc) noexcept(true);

extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr, int __base,
locale_t __loc) noexcept(true);

__extension__ extern long long int wcstoll_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
int __base,
locale_t __loc) noexcept(true);

__extension__ extern unsigned long long int
wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
int __base, locale_t __loc) noexcept(true);

extern double wcstod_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern float wcstof_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern long double wcstold_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);
extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern _Float128 wcstof128_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);

extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr,
wchar_t **__restrict __endptr,
locale_t __loc) noexcept(true);
extern wchar_t *wcpcpy(wchar_t *__restrict __dest,
const wchar_t *__restrict __src) noexcept(true);

extern wchar_t *wcpncpy(wchar_t *__restrict __dest,
const wchar_t *__restrict __src,
size_t __n) noexcept(true);
extern __FILE *open_wmemstream(wchar_t **__bufloc,
size_t *__sizeloc) noexcept(true)
__attribute__((__malloc__));

extern int fwide(__FILE *__fp, int __mode) noexcept(true);

extern int fwprintf(__FILE *__restrict __stream,
const wchar_t *__restrict __format, ...);

extern int wprintf(const wchar_t *__restrict __format, ...);

extern int swprintf(wchar_t *__restrict __s, size_t __n,
const wchar_t *__restrict __format, ...) noexcept(true);

extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format,
__gnuc_va_list __arg);

extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);

extern int vswprintf(wchar_t *__restrict __s, size_t __n,
const wchar_t *__restrict __format,
__gnuc_va_list __arg) noexcept(true);

extern int fwscanf(__FILE *__restrict __stream,
const wchar_t *__restrict __format, ...);

extern int wscanf(const wchar_t *__restrict __format, ...);

extern int swscanf(const wchar_t *__restrict __s,
const wchar_t *__restrict __format, ...) noexcept(true);
extern int fwscanf(__FILE *__restrict __stream,
const wchar_t *__restrict __format,
...) __asm__(""
"__isoc99_fwscanf")

;
extern int wscanf(const wchar_t *__restrict __format,
...) __asm__(""
"__isoc99_wscanf")

;
extern int swscanf(const wchar_t *__restrict __s,
const wchar_t *__restrict __format,
...) noexcept(true) __asm__(""
"__isoc99_swscanf")

;
extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format,
__gnuc_va_list __arg);

extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);

extern int vswscanf(const wchar_t *__restrict __s,
const wchar_t *__restrict __format,
__gnuc_va_list __arg) noexcept(true);

extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format,
__gnuc_va_list __arg) __asm__(""
"__isoc99_vfwscanf")

;
extern int vwscanf(const wchar_t *__restrict __format,
__gnuc_va_list __arg) __asm__(""
"__isoc99_vwscanf")

;
extern int
vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format,
__gnuc_va_list __arg) noexcept(true) __asm__(""
"__isoc99_vswscanf")

;
extern wint_t fgetwc(__FILE *__stream);
extern wint_t getwc(__FILE *__stream);

extern wint_t getwchar(void);

extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
extern wint_t putwc(wchar_t __wc, __FILE *__stream);

extern wint_t putwchar(wchar_t __wc);

extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n,
__FILE *__restrict __stream);

extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);

extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
extern wint_t getwc_unlocked(__FILE *__stream);
extern wint_t getwchar_unlocked(void);

extern wint_t fgetwc_unlocked(__FILE *__stream);

extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked(wchar_t __wc);
extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n,
__FILE *__restrict __stream);

extern int fputws_unlocked(const wchar_t *__restrict __ws,
__FILE *__restrict __stream);

extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize,
const wchar_t *__restrict __format,
const struct tm *__restrict __tp) noexcept(true);

extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize,
const wchar_t *__restrict __format,
const struct tm *__restrict __tp,
locale_t __loc) noexcept(true);
}
namespace std {
using ::mbstate_t;
}
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

using ::wint_t;

using ::btowc;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::getwchar;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::putwc;
using ::putwchar;

using ::swprintf;

using ::swscanf;
using ::ungetwc;
using ::vfwprintf;

using ::vfwscanf;

using ::vswprintf;

using ::vswscanf;

using ::vwprintf;

using ::vwscanf;

using ::wcrtomb;
using ::wcscat;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcsrtombs;
using ::wcsspn;
using ::wcstod;

using ::wcstof;

using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wcstok;
using ::wcstol;
using ::wcstoul;
using ::wcsxfrm;
using ::wctob;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;

} // namespace std
}

namespace __gnu_cxx {

using ::wcstold;
using ::wcstoll;
using ::wcstoull;

} // namespace __gnu_cxx

namespace std {
using ::__gnu_cxx::wcstold;
using ::__gnu_cxx::wcstoll;
using ::__gnu_cxx::wcstoull;
} // namespace std
namespace std {

using std::wcstof;

using std::vfwscanf;

using std::vswscanf;

using std::vwscanf;

using std::wcstold;
using std::wcstoll;
using std::wcstoull;

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

typedef long int streamoff;

typedef ptrdiff_t streamsize;
template <typename _StateT> class fpos {
private:
streamoff _M_off;
_StateT _M_state;

public:
fpos() : _M_off(0), _M_state() {}
fpos(streamoff __off) : _M_off(__off), _M_state() {}

fpos(const fpos &) = default;
fpos &operator=(const fpos &) = default;
~fpos() = default;

operator streamoff() const { return _M_off; }

void state(_StateT __st) { _M_state = __st; }

_StateT state() const { return _M_state; }

fpos &operator+=(streamoff __off) {
_M_off += __off;
return *this;
}

fpos &operator-=(streamoff __off) {
_M_off -= __off;
return *this;
}

fpos operator+(streamoff __off) const {
fpos __pos(*this);
__pos += __off;
return __pos;
}

fpos operator-(streamoff __off) const {
fpos __pos(*this);
__pos -= __off;
return __pos;
}

streamoff operator-(const fpos &__other) const {
return _M_off - __other._M_off;
}
};

template <typename _StateT>
inline bool operator==(const fpos<_StateT> &__lhs,
const fpos<_StateT> &__rhs) {
return streamoff(__lhs) == streamoff(__rhs);
}

template <typename _StateT>
inline bool operator!=(const fpos<_StateT> &__lhs,
const fpos<_StateT> &__rhs) {
return streamoff(__lhs) != streamoff(__rhs);
}

typedef fpos<mbstate_t> streampos;

typedef fpos<mbstate_t> wstreampos;
typedef fpos<mbstate_t> u16streampos;

typedef fpos<mbstate_t> u32streampos;

} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstringop-overflow"
#pragma GCC diagnostic ignored "-Wstringop-overread"
#pragma GCC diagnostic ignored "-Warray-bounds"
template <typename _CharT> struct _Char_types {
typedef unsigned long int_type;
typedef std::streampos pos_type;
typedef std::streamoff off_type;
typedef std::mbstate_t state_type;
};
template <typename _CharT> struct char_traits {
typedef _CharT char_type;
typedef typename _Char_types<_CharT>::int_type int_type;
typedef typename _Char_types<_CharT>::pos_type pos_type;
typedef typename _Char_types<_CharT>::off_type off_type;
typedef typename _Char_types<_CharT>::state_type state_type;

static constexpr void assign(char_type &__c1, const char_type &__c2) {

__c1 = __c2;
}

static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
return __c1 == __c2;
}

static constexpr bool lt(const char_type &__c1, const char_type &__c2) {
return __c1 < __c2;
}

static constexpr int compare(const char_type *__s1, const char_type *__s2,
std::size_t __n);

static constexpr std::size_t length(const char_type *__s);

static constexpr const char_type *
find(const char_type *__s, std::size_t __n, const char_type &__a);

static char_type *move(char_type *__s1, const char_type *__s2,
std::size_t __n);

static char_type *copy(char_type *__s1, const char_type *__s2,
std::size_t __n);

static char_type *assign(char_type *__s, std::size_t __n, char_type __a);

static constexpr char_type to_char_type(const int_type &__c) {
return static_cast<char_type>(__c);
}

static constexpr int_type to_int_type(const char_type &__c) {
return static_cast<int_type>(__c);
}

static constexpr bool eq_int_type(const int_type &__c1,
const int_type &__c2) {
return __c1 == __c2;
}

static constexpr int_type eof() { return static_cast<int_type>(-1); }

static constexpr int_type not_eof(const int_type &__c) {
return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
}
};

template <typename _CharT>
constexpr int char_traits<_CharT>::compare(
const char_type *__s1, const char_type *__s2, std::size_t __n) {
for (std::size_t __i = 0; __i < __n; ++__i)
if (lt(__s1[__i], __s2[__i]))
return -1;
else if (lt(__s2[__i], __s1[__i]))
return 1;
return 0;
}

template <typename _CharT>
constexpr std::size_t char_traits<_CharT>::length(const char_type *__p) {
std::size_t __i = 0;
while (!eq(__p[__i], char_type()))
++__i;
return __i;
}

template <typename _CharT>
constexpr const typename char_traits<_CharT>::char_type *
char_traits<_CharT>::find(const char_type *__s, std::size_t __n,
const char_type &__a) {
for (std::size_t __i = 0; __i < __n; ++__i)
if (eq(__s[__i], __a))
return __s + __i;
return 0;
}

template <typename _CharT>

typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(
char_type * __s1, const char_type *__s2, std::size_t __n) {
if (__n == 0)
return __s1;
__builtin_memmove(__s1, __s2, __n * sizeof(char_type));
return __s1;
}

template <typename _CharT>

typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(
char_type * __s1, const char_type *__s2, std::size_t __n) {
__builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
return __s1;
}

template <typename _CharT>

typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(
char_type * __s, std::size_t __n, char_type __a) {
if constexpr (sizeof(_CharT) == 1 && __is_trivial(_CharT)) {
unsigned char __c;
__builtin_memcpy(&__c, __builtin_addressof(__a), 1);
__builtin_memset(__s, __c, __n);
} else {
for (std::size_t __i = 0; __i < __n; ++__i)
__s[__i] = __a;
}
return __s;
}

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

template <typename _CharT>
struct char_traits : public __gnu_cxx::char_traits<_CharT> {};

template <> struct char_traits<char> {
typedef char char_type;
typedef int int_type;
typedef streampos pos_type;
typedef streamoff off_type;
typedef mbstate_t state_type;

static constexpr void assign(char_type &__c1,
const char_type &__c2) noexcept {

__c1 = __c2;
}

static constexpr bool eq(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr bool lt(const char_type &__c1,
const char_type &__c2) noexcept {

return (static_cast<unsigned char>(__c1) <
static_cast<unsigned char>(__c2));
}

static constexpr int compare(const char_type *__s1, const char_type *__s2,
size_t __n) {
if (__n == 0)
return 0;

if (std::__is_constant_evaluated()) {
for (size_t __i = 0; __i < __n; ++__i)
if (lt(__s1[__i], __s2[__i]))
return -1;
else if (lt(__s2[__i], __s1[__i]))
return 1;
return 0;
}

return __builtin_memcmp(__s1, __s2, __n);
}

static constexpr size_t length(const char_type *__s) {

if (std::__is_constant_evaluated())
return __gnu_cxx::char_traits<char_type>::length(__s);

return __builtin_strlen(__s);
}

static constexpr const char_type *find(const char_type *__s, size_t __n,
const char_type &__a) {
if (__n == 0)
return 0;

if (std::__is_constant_evaluated())
return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
}

static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
}

static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
}

static char_type *assign(char_type *__s, size_t __n, char_type __a) {
if (__n == 0)
return __s;

return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
}

static constexpr char_type to_char_type(const int_type &__c) noexcept {
return static_cast<char_type>(__c);
}

static constexpr int_type to_int_type(const char_type &__c) noexcept {
return static_cast<int_type>(static_cast<unsigned char>(__c));
}

static constexpr bool eq_int_type(const int_type &__c1,
const int_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr int_type eof() noexcept {
return static_cast<int_type>(-1);
}

static constexpr int_type not_eof(const int_type &__c) noexcept {
return (__c == eof()) ? 0 : __c;
}
};

template <> struct char_traits<wchar_t> {
typedef wchar_t char_type;
typedef wint_t int_type;
typedef streamoff off_type;
typedef wstreampos pos_type;
typedef mbstate_t state_type;

static constexpr void assign(char_type &__c1,
const char_type &__c2) noexcept {

__c1 = __c2;
}

static constexpr bool eq(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr bool lt(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 < __c2;
}

static constexpr int compare(const char_type *__s1, const char_type *__s2,
size_t __n) {
if (__n == 0)
return 0;

if (std::__is_constant_evaluated())
return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

return wmemcmp(__s1, __s2, __n);
}

static constexpr size_t length(const char_type *__s) {

if (std::__is_constant_evaluated())
return __gnu_cxx::char_traits<char_type>::length(__s);

return wcslen(__s);
}

static constexpr const char_type *find(const char_type *__s, size_t __n,
const char_type &__a) {
if (__n == 0)
return 0;

if (std::__is_constant_evaluated())
return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

return wmemchr(__s, __a, __n);
}

static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return wmemmove(__s1, __s2, __n);
}

static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return wmemcpy(__s1, __s2, __n);
}

static char_type *assign(char_type *__s, size_t __n, char_type __a) {
if (__n == 0)
return __s;

return wmemset(__s, __a, __n);
}

static constexpr char_type to_char_type(const int_type &__c) noexcept {
return char_type(__c);
}

static constexpr int_type to_int_type(const char_type &__c) noexcept {
return int_type(__c);
}

static constexpr bool eq_int_type(const int_type &__c1,
const int_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr int_type eof() noexcept {
return static_cast<int_type>((0xffffffffu));
}

static constexpr int_type not_eof(const int_type &__c) noexcept {
return eq_int_type(__c, eof()) ? 0 : __c;
}
};

} // namespace std

typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;

typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;

typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;

typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;

typedef unsigned long int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;

namespace std {

using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;

using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;

using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;

using ::intmax_t;
using ::intptr_t;

using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;

using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;

using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;

using ::uintmax_t;
using ::uintptr_t;

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <> struct char_traits<char16_t> {
typedef char16_t char_type;

typedef uint_least16_t int_type;

typedef streamoff off_type;
typedef u16streampos pos_type;
typedef mbstate_t state_type;

static constexpr void assign(char_type &__c1,
const char_type &__c2) noexcept {

__c1 = __c2;
}

static constexpr bool eq(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr bool lt(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 < __c2;
}

static constexpr int compare(const char_type *__s1, const char_type *__s2,
size_t __n) {
for (size_t __i = 0; __i < __n; ++__i)
if (lt(__s1[__i], __s2[__i]))
return -1;
else if (lt(__s2[__i], __s1[__i]))
return 1;
return 0;
}

static constexpr size_t length(const char_type *__s) {
size_t __i = 0;
while (!eq(__s[__i], char_type()))
++__i;
return __i;
}

static constexpr const char_type *find(const char_type *__s, size_t __n,
const char_type &__a) {
for (size_t __i = 0; __i < __n; ++__i)
if (eq(__s[__i], __a))
return __s + __i;
return 0;
}

static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return (static_cast<char_type *>(
__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
}

static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return (static_cast<char_type *>(
__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
}

static char_type *assign(char_type *__s, size_t __n, char_type __a) {
for (size_t __i = 0; __i < __n; ++__i)
assign(__s[__i], __a);
return __s;
}

static constexpr char_type to_char_type(const int_type &__c) noexcept {
return char_type(__c);
}

static constexpr int_type to_int_type(const char_type &__c) noexcept {
return __c == eof() ? int_type(0xfffd) : int_type(__c);
}

static constexpr bool eq_int_type(const int_type &__c1,
const int_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr int_type eof() noexcept {
return static_cast<int_type>(-1);
}

static constexpr int_type not_eof(const int_type &__c) noexcept {
return eq_int_type(__c, eof()) ? 0 : __c;
}
};

template <> struct char_traits<char32_t> {
typedef char32_t char_type;

typedef uint_least32_t int_type;

typedef streamoff off_type;
typedef u32streampos pos_type;
typedef mbstate_t state_type;

static constexpr void assign(char_type &__c1,
const char_type &__c2) noexcept {

__c1 = __c2;
}

static constexpr bool eq(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr bool lt(const char_type &__c1,
const char_type &__c2) noexcept {
return __c1 < __c2;
}

static constexpr int compare(const char_type *__s1, const char_type *__s2,
size_t __n) {
for (size_t __i = 0; __i < __n; ++__i)
if (lt(__s1[__i], __s2[__i]))
return -1;
else if (lt(__s2[__i], __s1[__i]))
return 1;
return 0;
}

static constexpr size_t length(const char_type *__s) {
size_t __i = 0;
while (!eq(__s[__i], char_type()))
++__i;
return __i;
}

static constexpr const char_type *find(const char_type *__s, size_t __n,
const char_type &__a) {
for (size_t __i = 0; __i < __n; ++__i)
if (eq(__s[__i], __a))
return __s + __i;
return 0;
}

static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return (static_cast<char_type *>(
__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
}

static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) {
if (__n == 0)
return __s1;

return (static_cast<char_type *>(
__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
}

static char_type *assign(char_type *__s, size_t __n, char_type __a) {
for (size_t __i = 0; __i < __n; ++__i)
assign(__s[__i], __a);
return __s;
}

static constexpr char_type to_char_type(const int_type &__c) noexcept {
return char_type(__c);
}

static constexpr int_type to_int_type(const char_type &__c) noexcept {
return int_type(__c);
}

static constexpr bool eq_int_type(const int_type &__c1,
const int_type &__c2) noexcept {
return __c1 == __c2;
}

static constexpr int_type eof() noexcept {
return static_cast<int_type>(-1);
}

static constexpr int_type not_eof(const int_type &__c) noexcept {
return eq_int_type(__c, eof()) ? 0 : __c;
}
};
#pragma GCC diagnostic pop

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp> class __new_allocator {
public:
typedef _Tp value_type;
typedef std::size_t size_type;
typedef std::ptrdiff_t difference_type;

typedef _Tp *pointer;
typedef const _Tp *const_pointer;
typedef _Tp &reference;
typedef const _Tp &const_reference;

template <typename _Tp1> struct rebind {
typedef __new_allocator<_Tp1> other;
};

typedef std::true_type propagate_on_container_move_assignment;

__new_allocator() noexcept {}

__new_allocator(const __new_allocator &) noexcept {}

template <typename _Tp1>

__new_allocator(const __new_allocator<_Tp1> &) noexcept {}

~__new_allocator() noexcept {}

pointer address(reference __x) const noexcept {
return std::__addressof(__x);
}

const_pointer address(const_reference __x) const noexcept {
return std::__addressof(__x);
}
[[__nodiscard__]] _Tp *
allocate(size_type __n, const void * = static_cast<const void *>(0)) {

static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");

if (__builtin_expect(__n > this->_M_max_size(), false)) {

if (__n > (std::size_t(-1) / sizeof(_Tp)))
std::__throw_bad_array_new_length();
std::__throw_bad_alloc();
}

if (alignof(_Tp) > 16) {
std::align_val_t __al = std::align_val_t(alignof(_Tp));
return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), __al));
}

return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
}

void deallocate(_Tp *__p, size_type __n __attribute__((__unused__))) {

if (alignof(_Tp) > 16) {
::operator delete((__p), (__n) * sizeof(_Tp),
std::align_val_t(alignof(_Tp)));
return;
}

::operator delete((__p), (__n) * sizeof(_Tp));
}

size_type max_size() const noexcept { return _M_max_size(); }

template <typename _Up, typename... _Args>
void construct(_Up *__p, _Args &&...__args) noexcept(
std::is_nothrow_constructible<_Up, _Args...>::value) {
::new ((void *)__p) _Up(std::forward<_Args>(__args)...);
}

template <typename _Up>
void destroy(_Up *__p) noexcept(std::is_nothrow_destructible<_Up>::value) {
__p->~_Up();
}
template <typename _Up>
friend bool operator==(const __new_allocator &,
const __new_allocator<_Up> &) noexcept {
return true;
}

template <typename _Up>
friend bool operator!=(const __new_allocator &,
const __new_allocator<_Up> &) noexcept {
return false;
}

private:
constexpr size_type _M_max_size() const noexcept {

return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);
}
};

} // namespace std

namespace std {
template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
}

namespace std __attribute__((__visibility__("default"))) {

template <> class allocator<void> {
public:
typedef void value_type;
typedef size_t size_type;
typedef ptrdiff_t difference_type;

typedef void *pointer;
typedef const void *const_pointer;

template <typename _Tp1> struct rebind {
typedef allocator<_Tp1> other;
};

using propagate_on_container_move_assignment = true_type;

using is_always_equal

= true_type;
};
template <typename _Tp> class allocator : public __allocator_base<_Tp> {
public:
typedef _Tp value_type;
typedef size_t size_type;
typedef ptrdiff_t difference_type;

typedef _Tp *pointer;
typedef const _Tp *const_pointer;
typedef _Tp &reference;
typedef const _Tp &const_reference;

template <typename _Tp1> struct rebind {
typedef allocator<_Tp1> other;
};

using propagate_on_container_move_assignment = true_type;

using is_always_equal

= true_type;

allocator() noexcept {}

allocator(const allocator &__a) noexcept : __allocator_base<_Tp>(__a) {}

allocator &operator=(const allocator &) = default;

template <typename _Tp1>

allocator(const allocator<_Tp1> &) noexcept {}

~allocator() noexcept {}
friend bool operator==(const allocator &, const allocator &) noexcept {
return true;
}

friend bool operator!=(const allocator &, const allocator &) noexcept {
return false;
}
};

template <typename _T1, typename _T2>
inline bool operator==(const allocator<_T1> &,
const allocator<_T2> &) noexcept {
return true;
}

template <typename _T1, typename _T2>
inline bool operator!=(const allocator<_T1> &,
const allocator<_T2> &) noexcept {
return false;
}

template <typename _Tp> class allocator<const _Tp> {
public:
typedef _Tp value_type;
template <typename _Up> allocator(const allocator<_Up> &) {}
};

template <typename _Tp> class allocator<volatile _Tp> {
public:
typedef _Tp value_type;
template <typename _Up> allocator(const allocator<_Up> &) {}
};

template <typename _Tp> class allocator<const volatile _Tp> {
public:
typedef _Tp value_type;
template <typename _Up> allocator(const allocator<_Up> &) {}
};

extern template class allocator<char>;
extern template class allocator<wchar_t>;

template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
static void _S_do_it(_Alloc &, _Alloc &) noexcept {}
};

template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept {

if (__one != __two)
swap(__one, __two);
}
};

template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
static bool _S_do_it(const _Alloc &, const _Alloc &) { return false; }
};

template <typename _Alloc> struct __alloc_neq<_Alloc, false> {
static bool _S_do_it(const _Alloc &__one, const _Alloc &__two) {
return __one != __two;
}
};

template <typename _Tp,
bool = __or_<
is_copy_constructible<typename _Tp::value_type>,
is_nothrow_move_constructible<typename _Tp::value_type>>::value>
struct __shrink_to_fit_aux {
static bool _S_do_it(_Tp &) noexcept { return false; }
};

template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {

static bool _S_do_it(_Tp &__c) noexcept {

try {
_Tp(__make_move_if_noexcept_iterator(__c.begin()),
__make_move_if_noexcept_iterator(__c.end()), __c.get_allocator())
.swap(__c);
return true;
} catch (...) {
return false;
}
}
};

} // namespace std

extern "C" {
struct lconv {

char *decimal_point;
char *thousands_sep;

char *grouping;

char *int_curr_symbol;
char *currency_symbol;
char *mon_decimal_point;
char *mon_thousands_sep;
char *mon_grouping;
char *positive_sign;
char *negative_sign;
char int_frac_digits;
char frac_digits;

char p_cs_precedes;

char p_sep_by_space;

char n_cs_precedes;

char n_sep_by_space;

char p_sign_posn;
char n_sign_posn;

char int_p_cs_precedes;

char int_p_sep_by_space;

char int_n_cs_precedes;

char int_n_sep_by_space;

char int_p_sign_posn;
char int_n_sign_posn;
};

extern char *setlocale(int __category, const char *__locale) noexcept(true);

extern struct lconv *localeconv(void) noexcept(true);
extern locale_t newlocale(int __category_mask, const char *__locale,
locale_t __base) noexcept(true);
extern locale_t duplocale(locale_t __dataset) noexcept(true);

extern void freelocale(locale_t __dataset) noexcept(true);

extern locale_t uselocale(locale_t __dataset) noexcept(true);
}
namespace std {
using ::lconv;
using ::localeconv;
using ::setlocale;
} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

extern "C" __typeof(uselocale) __uselocale;

}

namespace std __attribute__((__visibility__("default"))) {

typedef __locale_t __c_locale;
inline int __convert_from_v(
const __c_locale &__cloc __attribute__((__unused__)), char *__out,
const int __size __attribute__((__unused__)), const char *__fmt, ...) {

__c_locale __old = __gnu_cxx::__uselocale(__cloc);
__builtin_va_list __args;
__builtin_va_start(__args, __fmt);

const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);

__builtin_va_end(__args);

__gnu_cxx::__uselocale(__old);

return __ret;
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

class ios_base;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_ios;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_streambuf;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_istream;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_ostream;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_iostream;

namespace __cxx11 {

template <typename _CharT, typename _Traits = char_traits<_CharT>,
typename _Alloc = allocator<_CharT>>
class basic_stringbuf;

template <typename _CharT, typename _Traits = char_traits<_CharT>,
typename _Alloc = allocator<_CharT>>
class basic_istringstream;

template <typename _CharT, typename _Traits = char_traits<_CharT>,
typename _Alloc = allocator<_CharT>>
class basic_ostringstream;

template <typename _CharT, typename _Traits = char_traits<_CharT>,
typename _Alloc = allocator<_CharT>>
class basic_stringstream;

} // namespace __cxx11

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_filebuf;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_ifstream;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_ofstream;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class basic_fstream;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class istreambuf_iterator;

template <typename _CharT, typename _Traits = char_traits<_CharT>>
class ostreambuf_iterator;

typedef basic_ios<char> ios;

typedef basic_streambuf<char> streambuf;

typedef basic_istream<char> istream;

typedef basic_ostream<char> ostream;

typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;

typedef basic_istringstream<char> istringstream;

typedef basic_ostringstream<char> ostringstream;

typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;

typedef basic_ifstream<char> ifstream;

typedef basic_ofstream<char> ofstream;

typedef basic_fstream<char> fstream;

typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<wchar_t> wstreambuf;

typedef basic_istream<wchar_t> wistream;

typedef basic_ostream<wchar_t> wostream;

typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;

typedef basic_istringstream<wchar_t> wistringstream;

typedef basic_ostringstream<wchar_t> wostringstream;

typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;

typedef basic_ifstream<wchar_t> wifstream;

typedef basic_ofstream<wchar_t> wofstream;

typedef basic_fstream<wchar_t> wfstream;

} // namespace std

extern "C" {
enum {
_ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
_ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
_ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
_ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
_ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
_ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
_ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
_ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
_ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
_IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
_ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
_ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
extern const unsigned short int **__ctype_b_loc(void) noexcept(true)
__attribute__((__const__));
extern const __int32_t **__ctype_tolower_loc(void) noexcept(true)
__attribute__((__const__));
extern const __int32_t **__ctype_toupper_loc(void) noexcept(true)
__attribute__((__const__));
extern int isalnum(int) noexcept(true);
extern int isalpha(int) noexcept(true);
extern int iscntrl(int) noexcept(true);
extern int isdigit(int) noexcept(true);
extern int islower(int) noexcept(true);
extern int isgraph(int) noexcept(true);
extern int isprint(int) noexcept(true);
extern int ispunct(int) noexcept(true);
extern int isspace(int) noexcept(true);
extern int isupper(int) noexcept(true);
extern int isxdigit(int) noexcept(true);

extern int tolower(int __c) noexcept(true);

extern int toupper(int __c) noexcept(true);

extern int isblank(int) noexcept(true);

extern int isctype(int __c, int __mask) noexcept(true);

extern int isascii(int __c) noexcept(true);

extern int toascii(int __c) noexcept(true);

extern int _toupper(int) noexcept(true);
extern int _tolower(int) noexcept(true);
extern int isalnum_l(int, locale_t) noexcept(true);
extern int isalpha_l(int, locale_t) noexcept(true);
extern int iscntrl_l(int, locale_t) noexcept(true);
extern int isdigit_l(int, locale_t) noexcept(true);
extern int islower_l(int, locale_t) noexcept(true);
extern int isgraph_l(int, locale_t) noexcept(true);
extern int isprint_l(int, locale_t) noexcept(true);
extern int ispunct_l(int, locale_t) noexcept(true);
extern int isspace_l(int, locale_t) noexcept(true);
extern int isupper_l(int, locale_t) noexcept(true);
extern int isxdigit_l(int, locale_t) noexcept(true);

extern int isblank_l(int, locale_t) noexcept(true);

extern int __tolower_l(int __c, locale_t __l) noexcept(true);
extern int tolower_l(int __c, locale_t __l) noexcept(true);

extern int __toupper_l(int __c, locale_t __l) noexcept(true);
extern int toupper_l(int __c, locale_t __l) noexcept(true);
}
namespace std {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
} // namespace std

namespace std {
using ::isblank;
}

namespace std __attribute__((__visibility__("default"))) {

class locale;

template <typename _Facet> bool has_facet(const locale &) throw();

template <typename _Facet> const _Facet &use_facet(const locale &);

template <typename _CharT> bool isspace(_CharT, const locale &);

template <typename _CharT> bool isprint(_CharT, const locale &);

template <typename _CharT> bool iscntrl(_CharT, const locale &);

template <typename _CharT> bool isupper(_CharT, const locale &);

template <typename _CharT> bool islower(_CharT, const locale &);

template <typename _CharT> bool isalpha(_CharT, const locale &);

template <typename _CharT> bool isdigit(_CharT, const locale &);

template <typename _CharT> bool ispunct(_CharT, const locale &);

template <typename _CharT> bool isxdigit(_CharT, const locale &);

template <typename _CharT> bool isalnum(_CharT, const locale &);

template <typename _CharT> bool isgraph(_CharT, const locale &);

template <typename _CharT> bool isblank(_CharT, const locale &);

template <typename _CharT> _CharT toupper(_CharT, const locale &);

template <typename _CharT> _CharT tolower(_CharT, const locale &);

struct ctype_base;
template <typename _CharT> class ctype;
template <> class ctype<char>;

template <> class ctype<wchar_t>;

template <typename _CharT> class ctype_byname;

class codecvt_base;
template <typename _InternT, typename _ExternT, typename _StateT>
class codecvt;
template <> class codecvt<char, char, mbstate_t>;

template <> class codecvt<wchar_t, char, mbstate_t>;

template <> class codecvt<char16_t, char, mbstate_t>;
template <> class codecvt<char32_t, char, mbstate_t>;

template <typename _InternT, typename _ExternT, typename _StateT>
class codecvt_byname;

template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
class num_get;
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
class num_put;

namespace __cxx11 {
template <typename _CharT> class numpunct;
template <typename _CharT> class numpunct_byname;
} // namespace __cxx11

namespace __cxx11 {

template <typename _CharT> class collate;
template <typename _CharT> class collate_byname;
} // namespace __cxx11

class time_base;
namespace __cxx11 {
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
class time_get;
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
class time_get_byname;
} // namespace __cxx11
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
class time_put;
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
class time_put_byname;

class money_base;
namespace __cxx11 {
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
class money_get;
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
class money_put;
} // namespace __cxx11
namespace __cxx11 {
template <typename _CharT, bool _Intl = false> class moneypunct;
template <typename _CharT, bool _Intl = false> class moneypunct_byname;
} // namespace __cxx11

struct messages_base;
namespace __cxx11 {
template <typename _CharT> class messages;
template <typename _CharT> class messages_byname;
} // namespace __cxx11

} // namespace std

#pragma GCC visibility push(default)

namespace __cxxabiv1 {

class __forced_unwind {
virtual ~__forced_unwind() throw();

virtual void __pure_dummy() = 0;
};
} // namespace __cxxabiv1

#pragma GCC visibility pop

namespace std __attribute__((__visibility__("default"))) {

template <typename _CharT, typename _Traits>
inline void __ostream_write(basic_ostream<_CharT, _Traits> & __out,
const _CharT *__s, streamsize __n) {
typedef basic_ostream<_CharT, _Traits> __ostream_type;
typedef typename __ostream_type::ios_base __ios_base;

const streamsize __put = __out.rdbuf()->sputn(__s, __n);
if (__put != __n)
__out.setstate(__ios_base::badbit);
}

template <typename _CharT, typename _Traits>
inline void __ostream_fill(basic_ostream<_CharT, _Traits> & __out,
streamsize __n) {
typedef basic_ostream<_CharT, _Traits> __ostream_type;
typedef typename __ostream_type::ios_base __ios_base;

const _CharT __c = __out.fill();
for (; __n > 0; --__n) {
const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
if (_Traits::eq_int_type(__put, _Traits::eof())) {
__out.setstate(__ios_base::badbit);
break;
}
}
}

template <typename _CharT, typename _Traits>
basic_ostream<_CharT, _Traits> &__ostream_insert(
basic_ostream<_CharT, _Traits> & __out, const _CharT *__s,
streamsize __n) {
typedef basic_ostream<_CharT, _Traits> __ostream_type;
typedef typename __ostream_type::ios_base __ios_base;

typename __ostream_type::sentry __cerb(__out);
if (__cerb) {
try {
const streamsize __w = __out.width();
if (__w > __n) {
const bool __left =
((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
if (!__left)
__ostream_fill(__out, __w - __n);
if (__out.good())
__ostream_write(__out, __s, __n);
if (__left && __out.good())
__ostream_fill(__out, __w - __n);
} else
__ostream_write(__out, __s, __n);
__out.width(0);
} catch (__cxxabiv1::__forced_unwind &) {
__out._M_setstate(__ios_base::badbit);
throw;
} catch (...) {
__out._M_setstate(__ios_base::badbit);
}
}
return __out;
}

extern template ostream &__ostream_insert(ostream &, const char *,
streamsize);

extern template wostream &__ostream_insert(wostream &, const wchar_t *,
streamsize);

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Arg, typename _Result> struct unary_function {

typedef _Arg argument_type;

typedef _Result result_type;
} __attribute__((__deprecated__));

template <typename _Arg1, typename _Arg2, typename _Result>
struct binary_function {

typedef _Arg1 first_argument_type;

typedef _Arg2 second_argument_type;

typedef _Result result_type;
} __attribute__((__deprecated__));
struct __is_transparent;

template <typename _Tp = void> struct plus;

template <typename _Tp = void> struct minus;

template <typename _Tp = void> struct multiplies;

template <typename _Tp = void> struct divides;

template <typename _Tp = void> struct modulus;

template <typename _Tp = void> struct negate;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Tp> struct plus : public binary_function<_Tp, _Tp, _Tp> {

constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x + __y;
}
};

template <typename _Tp> struct minus : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x - __y;
}
};

template <typename _Tp>
struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x * __y;
}
};

template <typename _Tp>
struct divides : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x / __y;
}
};

template <typename _Tp>
struct modulus : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x % __y;
}
};

template <typename _Tp> struct negate : public unary_function<_Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x) const { return -__x; }
};
#pragma GCC diagnostic pop

template <> struct plus<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct minus<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct multiplies<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct divides<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct modulus<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct negate<void> {
template <typename _Tp>
constexpr auto operator()(_Tp &&__t) const
noexcept(noexcept(-std::forward<_Tp>(__t)))
-> decltype(-std::forward<_Tp>(__t)) {
return -std::forward<_Tp>(__t);
}

typedef __is_transparent is_transparent;
};
template <typename _Tp = void> struct equal_to;

template <typename _Tp = void> struct not_equal_to;

template <typename _Tp = void> struct greater;

template <typename _Tp = void> struct less;

template <typename _Tp = void> struct greater_equal;

template <typename _Tp = void> struct less_equal;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Tp>
struct equal_to : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x == __y;
}
};

template <typename _Tp>
struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x != __y;
}
};

template <typename _Tp>
struct greater : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x > __y;
}
};

template <typename _Tp> struct less : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x < __y;
}
};

template <typename _Tp>
struct greater_equal : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x >= __y;
}
};

template <typename _Tp>
struct less_equal : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x <= __y;
}
};

template <typename _Tp>
struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

if (std::__is_constant_evaluated())
return __x > __y;

return (long unsigned int)__x > (long unsigned int)__y;
}
};

template <typename _Tp>
struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

if (std::__is_constant_evaluated())
return __x < __y;

return (long unsigned int)__x < (long unsigned int)__y;
}
};

template <typename _Tp>
struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

if (std::__is_constant_evaluated())
return __x >= __y;

return (long unsigned int)__x >= (long unsigned int)__y;
}
};

template <typename _Tp>
struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

if (std::__is_constant_evaluated())
return __x <= __y;

return (long unsigned int)__x <= (long unsigned int)__y;
}
};
#pragma GCC diagnostic pop

template <> struct equal_to<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct not_equal_to<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct greater<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u)) {
return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
__ptr_cmp<_Tp, _Up>{});
}

template <typename _Tp, typename _Up>
constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
return greater<common_type_t<_Tp *, _Up *>>{}(__t, __u);
}

typedef __is_transparent is_transparent;

private:
template <typename _Tp, typename _Up>
static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
}

template <typename _Tp, typename _Up>
static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
return greater<const volatile void *>{}(
static_cast<const volatile void *>(std::forward<_Tp>(__t)),
static_cast<const volatile void *>(std::forward<_Up>(__u)));
}

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded2 : true_type {};

template <typename _Tp, typename _Up>
struct __not_overloaded2<
_Tp, _Up,
__void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

template <typename _Tp, typename _Up>
struct __not_overloaded<
_Tp, _Up,
__void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up>
using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
is_convertible<_Tp, const volatile void *>,
is_convertible<_Up, const volatile void *>>;
};

template <> struct less<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u)) {
return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
__ptr_cmp<_Tp, _Up>{});
}

template <typename _Tp, typename _Up>
constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
return less<common_type_t<_Tp *, _Up *>>{}(__t, __u);
}

typedef __is_transparent is_transparent;

private:
template <typename _Tp, typename _Up>
static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
}

template <typename _Tp, typename _Up>
static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
return less<const volatile void *>{}(
static_cast<const volatile void *>(std::forward<_Tp>(__t)),
static_cast<const volatile void *>(std::forward<_Up>(__u)));
}

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded2 : true_type {};

template <typename _Tp, typename _Up>
struct __not_overloaded2<
_Tp, _Up,
__void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

template <typename _Tp, typename _Up>
struct __not_overloaded<
_Tp, _Up,
__void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up>
using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
is_convertible<_Tp, const volatile void *>,
is_convertible<_Up, const volatile void *>>;
};

template <> struct greater_equal<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)) {
return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
__ptr_cmp<_Tp, _Up>{});
}

template <typename _Tp, typename _Up>
constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
return greater_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
}

typedef __is_transparent is_transparent;

private:
template <typename _Tp, typename _Up>
static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
}

template <typename _Tp, typename _Up>
static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
return greater_equal<const volatile void *>{}(
static_cast<const volatile void *>(std::forward<_Tp>(__t)),
static_cast<const volatile void *>(std::forward<_Up>(__u)));
}

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded2 : true_type {};

template <typename _Tp, typename _Up>
struct __not_overloaded2<
_Tp, _Up,
__void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

template <typename _Tp, typename _Up>
struct __not_overloaded<_Tp, _Up,
__void_t<decltype(operator>=(std::declval<_Tp>(),
std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up>
using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
is_convertible<_Tp, const volatile void *>,
is_convertible<_Up, const volatile void *>>;
};

template <> struct less_equal<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)) {
return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
__ptr_cmp<_Tp, _Up>{});
}

template <typename _Tp, typename _Up>
constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
return less_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
}

typedef __is_transparent is_transparent;

private:
template <typename _Tp, typename _Up>
static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
}

template <typename _Tp, typename _Up>
static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
return less_equal<const volatile void *>{}(
static_cast<const volatile void *>(std::forward<_Tp>(__t)),
static_cast<const volatile void *>(std::forward<_Up>(__u)));
}

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded2 : true_type {};

template <typename _Tp, typename _Up>
struct __not_overloaded2<
_Tp, _Up,
__void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up, typename = void>
struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

template <typename _Tp, typename _Up>
struct __not_overloaded<_Tp, _Up,
__void_t<decltype(operator<=(std::declval<_Tp>(),
std::declval<_Up>()))>>
: false_type {};

template <typename _Tp, typename _Up>
using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
is_convertible<_Tp, const volatile void *>,
is_convertible<_Up, const volatile void *>>;
};
template <typename _Tp = void> struct logical_and;

template <typename _Tp = void> struct logical_or;

template <typename _Tp = void> struct logical_not;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Tp>
struct logical_and : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x && __y;
}
};

template <typename _Tp>
struct logical_or : public binary_function<_Tp, _Tp, bool> {
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
return __x || __y;
}
};

template <typename _Tp>
struct logical_not : public unary_function<_Tp, bool> {
constexpr bool operator()(const _Tp &__x) const { return !__x; }
};
#pragma GCC diagnostic pop

template <> struct logical_and<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct logical_or<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct logical_not<void> {
template <typename _Tp>
constexpr auto operator()(_Tp &&__t) const
noexcept(noexcept(!std::forward<_Tp>(__t)))
-> decltype(!std::forward<_Tp>(__t)) {
return !std::forward<_Tp>(__t);
}

typedef __is_transparent is_transparent;
};

template <typename _Tp = void> struct bit_and;

template <typename _Tp = void> struct bit_or;

template <typename _Tp = void> struct bit_xor;

template <typename _Tp = void> struct bit_not;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Tp>
struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x & __y;
}
};

template <typename _Tp>
struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x | __y;
}
};

template <typename _Tp>
struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
return __x ^ __y;
}
};

template <typename _Tp> struct bit_not : public unary_function<_Tp, _Tp> {
constexpr _Tp operator()(const _Tp &__x) const { return ~__x; }
};
#pragma GCC diagnostic pop

template <> struct bit_and<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct bit_or<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct bit_xor<void> {
template <typename _Tp, typename _Up>
constexpr auto operator()(_Tp &&__t, _Up &&__u) const
noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)) {
return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
}

typedef __is_transparent is_transparent;
};

template <> struct bit_not<void> {
template <typename _Tp>
constexpr auto operator()(_Tp &&__t) const
noexcept(noexcept(~std::forward<_Tp>(__t)))
-> decltype(~std::forward<_Tp>(__t)) {
return ~std::forward<_Tp>(__t);
}

typedef __is_transparent is_transparent;
};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <typename _Predicate>
class [[__deprecated__]] unary_negate
: public unary_function<typename _Predicate::argument_type, bool> {
protected:
_Predicate _M_pred;

public:
constexpr explicit unary_negate(const _Predicate &__x) : _M_pred(__x) {}

constexpr bool
operator()(const typename _Predicate::argument_type &__x) const {
return !_M_pred(__x);
}
};

template <typename _Predicate>
__attribute__((
__deprecated__("use '"
"std::not_fn"
"' instead"))) constexpr inline unary_negate<_Predicate>
not1(const _Predicate &__pred) {
return unary_negate<_Predicate>(__pred);
}

template <typename _Predicate>
class [[__deprecated__]] binary_negate
: public binary_function<typename _Predicate::first_argument_type,
typename _Predicate::second_argument_type,
bool> {
protected:
_Predicate _M_pred;

public:
constexpr explicit binary_negate(const _Predicate &__x) : _M_pred(__x) {}

constexpr bool
operator()(const typename _Predicate::first_argument_type &__x,
const typename _Predicate::second_argument_type &__y) const {
return !_M_pred(__x, __y);
}
};

template <typename _Predicate>
__attribute__((
__deprecated__("use '"
"std::not_fn"
"' instead"))) constexpr inline binary_negate<_Predicate>
not2(const _Predicate &__pred) {
return binary_negate<_Predicate>(__pred);
}
template <typename _Arg, typename _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
_Result (*_M_ptr)(_Arg);

public:
pointer_to_unary_function() {}

explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}

_Result operator()(_Arg __x) const { return _M_ptr(__x); }
} __attribute__((__deprecated__));

template <typename _Arg, typename _Result>
__attribute__((__deprecated__(
"use '"
"std::function"
"' instead"))) inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result(*__x)(_Arg)) {
return pointer_to_unary_function<_Arg, _Result>(__x);
}

template <typename _Arg1, typename _Arg2, typename _Result>
class pointer_to_binary_function
: public binary_function<_Arg1, _Arg2, _Result> {
protected:
_Result (*_M_ptr)(_Arg1, _Arg2);

public:
pointer_to_binary_function() {}

explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
: _M_ptr(__x) {}

_Result operator()(_Arg1 __x, _Arg2 __y) const { return _M_ptr(__x, __y); }
} __attribute__((__deprecated__));

template <typename _Arg1, typename _Arg2, typename _Result>
__attribute__((__deprecated__(
"use '"
"std::function"
"' instead"))) inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
ptr_fun(_Result(*__x)(_Arg1, _Arg2)) {
return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
}

template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
_Tp &operator()(_Tp &__x) const { return __x; }

const _Tp &operator()(const _Tp &__x) const { return __x; }
};

template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {};

template <typename _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
typename _Pair::first_type &operator()(_Pair &__x) const {
return __x.first;
}

const typename _Pair::first_type &operator()(const _Pair &__x) const {
return __x.first;
}

template <typename _Pair2>
typename _Pair2::first_type &operator()(_Pair2 &__x) const {
return __x.first;
}

template <typename _Pair2>
const typename _Pair2::first_type &operator()(const _Pair2 &__x) const {
return __x.first;
}
};

template <typename _Pair>
struct _Select2nd
: public unary_function<_Pair, typename _Pair::second_type> {
typename _Pair::second_type &operator()(_Pair &__x) const {
return __x.second;
}

const typename _Pair::second_type &operator()(const _Pair &__x) const {
return __x.second;
}
};
template <typename _Ret, typename _Tp>
class mem_fun_t : public unary_function<_Tp *, _Ret> {
public:
explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}

_Ret operator()(_Tp *__p) const { return (__p->*_M_f)(); }

private:
_Ret (_Tp::*_M_f)();
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp>
class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
public:
explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}

_Ret operator()(const _Tp *__p) const { return (__p->*_M_f)(); }

private:
_Ret (_Tp::*_M_f)() const;
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp>
class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
public:
explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}

_Ret operator()(_Tp &__r) const { return (__r.*_M_f)(); }

private:
_Ret (_Tp::*_M_f)();
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
public:
explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}

_Ret operator()(const _Tp &__r) const { return (__r.*_M_f)(); }

private:
_Ret (_Tp::*_M_f)() const;
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp, typename _Arg>
class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
public:
explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}

_Ret operator()(_Tp *__p, _Arg __x) const { return (__p->*_M_f)(__x); }

private:
_Ret (_Tp::*_M_f)(_Arg);
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp, typename _Arg>
class const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
public:
explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}

_Ret operator()(const _Tp *__p, _Arg __x) const {
return (__p->*_M_f)(__x);
}

private:
_Ret (_Tp::*_M_f)(_Arg) const;
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp, typename _Arg>
class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
public:
explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}

_Ret operator()(_Tp &__r, _Arg __x) const { return (__r.*_M_f)(__x); }

private:
_Ret (_Tp::*_M_f)(_Arg);
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp, typename _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
public:
explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}

_Ret operator()(const _Tp &__r, _Arg __x) const { return (__r.*_M_f)(__x); }

private:
_Ret (_Tp::*_M_f)(_Arg) const;
} __attribute__((__deprecated__));

template <typename _Ret, typename _Tp>
__attribute__((__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline mem_fun_t<_Ret, _Tp>
mem_fun(_Ret(_Tp::*__f)()) {
return mem_fun_t<_Ret, _Tp>(__f);
}

template <typename _Ret, typename _Tp>
__attribute__((__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline const_mem_fun_t<_Ret, _Tp>
mem_fun(_Ret(_Tp::*__f)() const) {
return const_mem_fun_t<_Ret, _Tp>(__f);
}

template <typename _Ret, typename _Tp>
__attribute__((__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline mem_fun_ref_t<_Ret, _Tp>
mem_fun_ref(_Ret(_Tp::*__f)()) {
return mem_fun_ref_t<_Ret, _Tp>(__f);
}

template <typename _Ret, typename _Tp>
__attribute__((
__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline const_mem_fun_ref_t<_Ret, _Tp>
mem_fun_ref(_Ret(_Tp::*__f)() const) {
return const_mem_fun_ref_t<_Ret, _Tp>(__f);
}

template <typename _Ret, typename _Tp, typename _Arg>
__attribute__((
__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline mem_fun1_t<_Ret, _Tp, _Arg>
mem_fun(_Ret(_Tp::*__f)(_Arg)) {
return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
}

template <typename _Ret, typename _Tp, typename _Arg>
__attribute__((
__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline const_mem_fun1_t<_Ret, _Tp, _Arg>
mem_fun(_Ret(_Tp::*__f)(_Arg) const) {
return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
}

template <typename _Ret, typename _Tp, typename _Arg>
__attribute__((
__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
mem_fun_ref(_Ret(_Tp::*__f)(_Arg)) {
return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
}

template <typename _Ret, typename _Tp, typename _Arg>
__attribute__((
__deprecated__("use '"
"std::mem_fn"
"' instead"))) inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
mem_fun_ref(_Ret(_Tp::*__f)(_Arg) const) {
return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
}
#pragma GCC diagnostic pop

template <typename _Func, typename _SfinaeType, typename = __void_t<>>
struct __has_is_transparent {};

template <typename _Func, typename _SfinaeType>
struct __has_is_transparent<_Func, _SfinaeType,
__void_t<typename _Func::is_transparent>> {
typedef void type;
};

template <typename _Func, typename _SfinaeType>
using __has_is_transparent_t =
typename __has_is_transparent<_Func, _SfinaeType>::type;

} // namespace std

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__((__visibility__("default"))) {

template <typename _Operation>
class binder1st
: public unary_function<typename _Operation::second_argument_type,
typename _Operation::result_type> {
protected:
_Operation op;
typename _Operation::first_argument_type value;

public:
binder1st(const _Operation &__x,
const typename _Operation::first_argument_type &__y)
: op(__x), value(__y) {}

typename _Operation::result_type
operator()(const typename _Operation::second_argument_type &__x) const {
return op(value, __x);
}

typename _Operation::result_type
operator()(typename _Operation::second_argument_type &__x) const {
return op(value, __x);
}
} __attribute__((__deprecated__("use '"
"std::bind"
"' instead")));

template <typename _Operation, typename _Tp>
__attribute__((__deprecated__("use '"
"std::bind"
"' instead"))) inline binder1st<_Operation>
bind1st(const _Operation &__fn, const _Tp &__x) {
typedef typename _Operation::first_argument_type _Arg1_type;
return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <typename _Operation>
class binder2nd
: public unary_function<typename _Operation::first_argument_type,
typename _Operation::result_type> {
protected:
_Operation op;
typename _Operation::second_argument_type value;

public:
binder2nd(const _Operation &__x,
const typename _Operation::second_argument_type &__y)
: op(__x), value(__y) {}

typename _Operation::result_type
operator()(const typename _Operation::first_argument_type &__x) const {
return op(__x, value);
}

typename _Operation::result_type
operator()(typename _Operation::first_argument_type &__x) const {
return op(__x, value);
}
} __attribute__((__deprecated__("use '"
"std::bind"
"' instead")));

template <typename _Operation, typename _Tp>
__attribute__((__deprecated__("use '"
"std::bind"
"' instead"))) inline binder2nd<_Operation>
bind2nd(const _Operation &__fn, const _Tp &__x) {
typedef typename _Operation::second_argument_type _Arg2_type;
return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}

} // namespace std

#pragma GCC diagnostic pop

namespace std __attribute__((__visibility__("default"))) {

template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &
__t) noexcept {
return static_cast<_Up &&>(__t);
}

template <typename _Res, typename _Fn, typename... _Args>
constexpr _Res __invoke_impl(__invoke_other, _Fn && __f, _Args && ...__args) {
return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
}

template <typename _Res, typename _MemFun, typename _Tp, typename... _Args>
constexpr _Res __invoke_impl(__invoke_memfun_ref, _MemFun && __f, _Tp && __t,
_Args && ...__args) {
return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...);
}

template <typename _Res, typename _MemFun, typename _Tp, typename... _Args>
constexpr _Res __invoke_impl(__invoke_memfun_deref, _MemFun && __f,
_Tp && __t, _Args && ...__args) {
return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
}

template <typename _Res, typename _MemPtr, typename _Tp>
constexpr _Res __invoke_impl(__invoke_memobj_ref, _MemPtr && __f,
_Tp && __t) {
return __invfwd<_Tp>(__t).*__f;
}

template <typename _Res, typename _MemPtr, typename _Tp>
constexpr _Res __invoke_impl(__invoke_memobj_deref, _MemPtr && __f,
_Tp && __t) {
return (*std::forward<_Tp>(__t)).*__f;
}

template <typename _Callable, typename... _Args>
constexpr typename __invoke_result<_Callable, _Args...>::type
__invoke(_Callable && __fn, _Args && ...__args) noexcept(
__is_nothrow_invocable<_Callable, _Args...>::value) {
using __result = __invoke_result<_Callable, _Args...>;
using __type = typename __result::type;
using __tag = typename __result::__invoke_type;
return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
std::forward<_Args>(__args)...);
}

template <typename _Res, typename _Callable, typename... _Args>
constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
__invoke_r(_Callable && __fn, _Args && ...__args) noexcept(
is_nothrow_invocable_r_v<_Res, _Callable, _Args...>) {
using __result = __invoke_result<_Callable, _Args...>;
using __type = typename __result::type;
using __tag = typename __result::__invoke_type;
if constexpr (is_void_v<_Res>)
std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
std::forward<_Args>(__args)...);
else
return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
std::forward<_Args>(__args)...);
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Res, typename... _ArgTypes>
struct _Maybe_unary_or_binary_function {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Res, typename _T1>
struct _Maybe_unary_or_binary_function<_Res, _T1>
: std::unary_function<_T1, _Res> {};

template <typename _Res, typename _T1, typename _T2>
struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
: std::binary_function<_T1, _T2, _Res> {};

#pragma GCC diagnostic pop

template <typename _Signature> struct _Mem_fn_traits;

template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits_base {
using __result_type = _Res;
using __maybe_type =
_Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>;
using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......)>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) &>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const &>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile &>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) &&>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const &&>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile &&>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &&>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};

template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......)
const volatile noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) & noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const & noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile & noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &
noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &
noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) && noexcept>
: _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const && noexcept>
: _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile && noexcept>
: _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&
noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = false_type;
};
template <typename _Res, typename _Class, typename... _ArgTypes>
struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &&
noexcept>
: _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
using __vararg = true_type;
};

template <typename _Functor, typename = __void_t<>>
struct _Maybe_get_result_type {};

template <typename _Functor>
struct _Maybe_get_result_type<_Functor,
__void_t<typename _Functor::result_type>> {
typedef typename _Functor::result_type result_type;
};

template <typename _Functor>
struct _Weak_result_type_impl : _Maybe_get_result_type<_Functor> {};

template <typename _Res, typename... _ArgTypes, bool _NE>
struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept(_NE)> {
typedef _Res result_type;
};

template <typename _Res, typename... _ArgTypes, bool _NE>
struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept(_NE)> {
typedef _Res result_type;
};

template <typename _Res, typename... _ArgTypes, bool _NE>
struct _Weak_result_type_impl<_Res (*)(_ArgTypes...) noexcept(_NE)> {
typedef _Res result_type;
};

template <typename _Res, typename... _ArgTypes, bool _NE>
struct _Weak_result_type_impl<_Res (*)(_ArgTypes......) noexcept(_NE)> {
typedef _Res result_type;
};

template <typename _Functor,
bool = is_member_function_pointer<_Functor>::value>
struct _Weak_result_type_memfun : _Weak_result_type_impl<_Functor> {};

template <typename _MemFunPtr>
struct _Weak_result_type_memfun<_MemFunPtr, true> {
using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
};

template <typename _Func, typename _Class>
struct _Weak_result_type_memfun<_Func _Class::*, false> {};

template <typename _Functor>
struct _Weak_result_type
: _Weak_result_type_memfun<typename remove_cv<_Functor>::type> {};

template <typename _Tp, typename = __void_t<>> struct _Refwrap_base_arg1 {};

template <typename _Tp>
struct _Refwrap_base_arg1<_Tp, __void_t<typename _Tp::argument_type>> {
typedef typename _Tp::argument_type argument_type;
};

template <typename _Tp, typename = __void_t<>> struct _Refwrap_base_arg2 {};

template <typename _Tp>
struct _Refwrap_base_arg2<_Tp, __void_t<typename _Tp::first_argument_type,
typename _Tp::second_argument_type>> {
typedef typename _Tp::first_argument_type first_argument_type;
typedef typename _Tp::second_argument_type second_argument_type;
};

template <typename _Tp>
struct _Reference_wrapper_base : _Weak_result_type<_Tp>,
_Refwrap_base_arg1<_Tp>,
_Refwrap_base_arg2<_Tp> {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Res, typename _T1, bool _NE>
struct _Reference_wrapper_base<_Res(_T1) noexcept(_NE)>
: unary_function<_T1, _Res> {};

template <typename _Res, typename _T1>
struct _Reference_wrapper_base<_Res(_T1) const> : unary_function<_T1, _Res> {
};

template <typename _Res, typename _T1>
struct _Reference_wrapper_base<_Res(_T1) volatile>
: unary_function<_T1, _Res> {};

template <typename _Res, typename _T1>
struct _Reference_wrapper_base<_Res(_T1) const volatile>
: unary_function<_T1, _Res> {};

template <typename _Res, typename _T1, typename _T2, bool _NE>
struct _Reference_wrapper_base<_Res(_T1, _T2) noexcept(_NE)>
: binary_function<_T1, _T2, _Res> {};

template <typename _Res, typename _T1, typename _T2>
struct _Reference_wrapper_base<_Res(_T1, _T2) const>
: binary_function<_T1, _T2, _Res> {};

template <typename _Res, typename _T1, typename _T2>
struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
: binary_function<_T1, _T2, _Res> {};

template <typename _Res, typename _T1, typename _T2>
struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
: binary_function<_T1, _T2, _Res> {};

template <typename _Res, typename _T1, bool _NE>
struct _Reference_wrapper_base<_Res (*)(_T1) noexcept(_NE)>
: unary_function<_T1, _Res> {};

template <typename _Res, typename _T1, typename _T2, bool _NE>
struct _Reference_wrapper_base<_Res (*)(_T1, _T2) noexcept(_NE)>
: binary_function<_T1, _T2, _Res> {};

template <typename _Tp, bool = is_member_function_pointer<_Tp>::value>
struct _Reference_wrapper_base_memfun : _Reference_wrapper_base<_Tp> {};

template <typename _MemFunPtr>
struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
: _Mem_fn_traits<_MemFunPtr>::__maybe_type {
using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
};
#pragma GCC diagnostic pop
template <typename _Tp>
class reference_wrapper

: public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>

{
_Tp *_M_data;

static _Tp *_S_fun(_Tp &__r) noexcept { return std::__addressof(__r); }

static void _S_fun(_Tp &&) = delete;

template <typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
using __not_same =
typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

public:
typedef _Tp type;

template <
typename _Up, typename = __not_same<_Up>,
typename = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>

reference_wrapper(_Up &&__uref) noexcept(
noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
: _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref))) {}

reference_wrapper(const reference_wrapper &) = default;

reference_wrapper &operator=(const reference_wrapper &) = default;

operator _Tp &() const noexcept { return this->get(); }

_Tp &get() const noexcept { return *_M_data; }

template <typename... _Args>

typename result_of<_Tp &(_Args &&...)>::type
operator()(_Args &&...__args) const {

return std::__invoke(get(), std::forward<_Args>(__args)...);
}
};

template <typename _Tp> reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;

template <typename _Tp>

inline reference_wrapper<_Tp> ref(_Tp & __t) noexcept {
return reference_wrapper<_Tp>(__t);
}

template <typename _Tp>

inline reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept {
return reference_wrapper<const _Tp>(__t);
}

template <typename _Tp> void ref(const _Tp &&) = delete;

template <typename _Tp> void cref(const _Tp &&) = delete;

template <typename _Tp>

inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept {
return __t;
}

template <typename _Tp>

inline reference_wrapper<const _Tp> cref(
reference_wrapper<_Tp> __t) noexcept {
return {__t.get()};
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Container>
[[__nodiscard__]] inline constexpr auto begin(_Container & __cont)
->decltype(__cont.begin()) {
return __cont.begin();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto begin(const _Container &__cont)
->decltype(__cont.begin()) {
return __cont.begin();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto end(_Container & __cont)
->decltype(__cont.end()) {
return __cont.end();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto end(const _Container &__cont)
->decltype(__cont.end()) {
return __cont.end();
}

template <typename _Tp, size_t _Nm>
[[__nodiscard__]] inline constexpr _Tp *begin(_Tp(&__arr)[_Nm]) noexcept {
return __arr;
}

template <typename _Tp, size_t _Nm>
[[__nodiscard__]] inline constexpr _Tp *end(_Tp(&__arr)[_Nm]) noexcept {
return __arr + _Nm;
}

template <typename _Tp> class valarray;

template <typename _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
template <typename _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
template <typename _Tp> _Tp *end(valarray<_Tp> &) noexcept;
template <typename _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;

template <typename _Container>
[[__nodiscard__]] constexpr auto cbegin(const _Container &__cont) noexcept(
noexcept(std::begin(__cont)))
->decltype(std::begin(__cont)) {
return std::begin(__cont);
}

template <typename _Container>
[[__nodiscard__]] constexpr auto cend(const _Container &__cont) noexcept(
noexcept(std::end(__cont)))
->decltype(std::end(__cont)) {
return std::end(__cont);
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto rbegin(_Container & __cont)
->decltype(__cont.rbegin()) {
return __cont.rbegin();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto rbegin(const _Container &__cont)
->decltype(__cont.rbegin()) {
return __cont.rbegin();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto rend(_Container & __cont)
->decltype(__cont.rend()) {
return __cont.rend();
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto rend(const _Container &__cont)
->decltype(__cont.rend()) {
return __cont.rend();
}

template <typename _Tp, size_t _Nm>
[[__nodiscard__]] inline constexpr reverse_iterator<_Tp *> rbegin(
_Tp(&__arr)[_Nm]) noexcept {
return reverse_iterator<_Tp *>(__arr + _Nm);
}

template <typename _Tp, size_t _Nm>
[[__nodiscard__]] inline constexpr reverse_iterator<_Tp *> rend(
_Tp(&__arr)[_Nm]) noexcept {
return reverse_iterator<_Tp *>(__arr);
}

template <typename _Tp>
[[__nodiscard__]] inline constexpr reverse_iterator<const _Tp *> rbegin(
initializer_list<_Tp> __il) noexcept {
return reverse_iterator<const _Tp *>(__il.end());
}

template <typename _Tp>
[[__nodiscard__]] inline constexpr reverse_iterator<const _Tp *> rend(
initializer_list<_Tp> __il) noexcept {
return reverse_iterator<const _Tp *>(__il.begin());
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto crbegin(const _Container &__cont)
->decltype(std::rbegin(__cont)) {
return std::rbegin(__cont);
}

template <typename _Container>
[[__nodiscard__]] inline constexpr auto crend(const _Container &__cont)
->decltype(std::rend(__cont)) {
return std::rend(__cont);
}
template <typename _Container>
[[nodiscard]] constexpr auto size(const _Container &__cont) noexcept(
noexcept(__cont.size()))
->decltype(__cont.size()) {
return __cont.size();
}

template <typename _Tp, size_t _Nm>
[[nodiscard]] constexpr size_t size(const _Tp(&)[_Nm]) noexcept {
return _Nm;
}

template <typename _Container>
[[nodiscard]] constexpr auto empty(const _Container &__cont) noexcept(
noexcept(__cont.empty()))
->decltype(__cont.empty()) {
return __cont.empty();
}

template <typename _Tp, size_t _Nm>
[[nodiscard]] constexpr bool empty(const _Tp(&)[_Nm]) noexcept {
return false;
}

template <typename _Tp>
[[nodiscard]] constexpr bool empty(initializer_list<_Tp> __il) noexcept {
return __il.size() == 0;
}

template <typename _Container>
[[nodiscard]] constexpr auto data(_Container &
__cont) noexcept(noexcept(__cont.data()))
->decltype(__cont.data()) {
return __cont.data();
}

template <typename _Container>
[[nodiscard]] constexpr auto data(const _Container &__cont) noexcept(
noexcept(__cont.data()))
->decltype(__cont.data()) {
return __cont.data();
}

template <typename _Tp, size_t _Nm>
[[nodiscard]] constexpr _Tp *data(_Tp(&__array)[_Nm]) noexcept {
return __array;
}

template <typename _Tp>
[[nodiscard]] constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept {
return __il.begin();
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

struct __allocator_traits_base {
template <typename _Tp, typename _Up, typename = void>
struct __rebind : __replace_first_arg<_Tp, _Up> {};

template <typename _Tp, typename _Up>
struct __rebind<_Tp, _Up,
__void_t<typename _Tp::template rebind<_Up>::other>> {
using type = typename _Tp::template rebind<_Up>::other;
};

protected:
template <typename _Tp> using __pointer = typename _Tp::pointer;
template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
template <typename _Tp>
using __cv_pointer = typename _Tp::const_void_pointer;
template <typename _Tp>
using __pocca = typename _Tp::propagate_on_container_copy_assignment;
template <typename _Tp>
using __pocma = typename _Tp::propagate_on_container_move_assignment;
template <typename _Tp>
using __pocs = typename _Tp::propagate_on_container_swap;
template <typename _Tp> using __equal = typename _Tp::is_always_equal;
};

template <typename _Alloc, typename _Up>
using __alloc_rebind =
typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
template <typename _Alloc> struct allocator_traits : __allocator_traits_base {

typedef _Alloc allocator_type;

typedef typename _Alloc::value_type value_type;

using pointer = __detected_or_t<value_type *, __pointer, _Alloc>;

private:
template <template <typename> class _Func, typename _Tp, typename = void>
struct _Ptr {
using type = typename pointer_traits<pointer>::template rebind<_Tp>;
};

template <template <typename> class _Func, typename _Tp>
struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
using type = _Func<_Alloc>;
};

template <typename _A2, typename _PtrT, typename = void> struct _Diff {
using type = typename pointer_traits<_PtrT>::difference_type;
};

template <typename _A2, typename _PtrT>
struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
using type = typename _A2::difference_type;
};

template <typename _A2, typename _DiffT, typename = void>
struct _Size : make_unsigned<_DiffT> {};

template <typename _A2, typename _DiffT>
struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
using type = typename _A2::size_type;
};

public:
using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;

using void_pointer = typename _Ptr<__v_pointer, void>::type;

using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;

using difference_type = typename _Diff<_Alloc, pointer>::type;

using size_type = typename _Size<_Alloc, difference_type>::type;

using propagate_on_container_copy_assignment =
__detected_or_t<false_type, __pocca, _Alloc>;

using propagate_on_container_move_assignment =
__detected_or_t<false_type, __pocma, _Alloc>;

using propagate_on_container_swap =
__detected_or_t<false_type, __pocs, _Alloc>;

using is_always_equal =
__detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
template <typename _Tp>
using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

private:
template <typename _Alloc2>
static constexpr auto _S_allocate(_Alloc2 &__a, size_type __n,
const_void_pointer __hint, int)
-> decltype(__a.allocate(__n, __hint)) {
return __a.allocate(__n, __hint);
}

template <typename _Alloc2>
static constexpr pointer _S_allocate(_Alloc2 &__a, size_type __n,
const_void_pointer, ...) {
return __a.allocate(__n);
}

template <typename _Tp, typename... _Args> struct __construct_helper {
template <typename _Alloc2,
typename = decltype(std::declval<_Alloc2 *>()->construct(
std::declval<_Tp *>(), std::declval<_Args>()...))>
static true_type __test(int);

template <typename> static false_type __test(...);

using type = decltype(__test<_Alloc>(0));
};

template <typename _Tp, typename... _Args>
using __has_construct = typename __construct_helper<_Tp, _Args...>::type;

template <typename _Tp, typename... _Args>
static constexpr _Require<__has_construct<_Tp, _Args...>>
_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
noexcept(__a.construct(__p, std::forward<_Args>(__args)...))) {
__a.construct(__p, std::forward<_Args>(__args)...);
}

template <typename _Tp, typename... _Args>
static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
is_constructible<_Tp, _Args...>>>
_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(
std::is_nothrow_constructible<_Tp, _Args...>::value) {

::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
}

template <typename _Alloc2, typename _Tp>
static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p,
int) noexcept(noexcept(__a.destroy(__p)))
-> decltype(__a.destroy(__p)) {
__a.destroy(__p);
}

template <typename _Alloc2, typename _Tp>
static constexpr void
_S_destroy(_Alloc2 &, _Tp *__p,
...) noexcept(std::is_nothrow_destructible<_Tp>::value) {
std::_Destroy(__p);
}

template <typename _Alloc2>
static constexpr auto _S_max_size(_Alloc2 &__a, int)
-> decltype(__a.max_size()) {
return __a.max_size();
}

template <typename _Alloc2>
static constexpr size_type _S_max_size(_Alloc2 &, ...) {

return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(value_type);
}

template <typename _Alloc2>
static constexpr auto _S_select(_Alloc2 &__a, int)
-> decltype(__a.select_on_container_copy_construction()) {
return __a.select_on_container_copy_construction();
}

template <typename _Alloc2>
static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...) {
return __a;
}

public:
[[__nodiscard__]] static pointer allocate(_Alloc &__a, size_type __n) {
return __a.allocate(__n);
}
[[__nodiscard__]] static pointer allocate(_Alloc &__a, size_type __n,
const_void_pointer __hint) {
return _S_allocate(__a, __n, __hint, 0);
}
static void deallocate(_Alloc &__a, pointer __p, size_type __n) {
__a.deallocate(__p, __n);
}
template <typename _Tp, typename... _Args>
static auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...)))
-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...)) {
_S_construct(__a, __p, std::forward<_Args>(__args)...);
}
template <typename _Tp>
static void destroy(_Alloc &__a,
_Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))) {
_S_destroy(__a, __p, 0);
}
static size_type max_size(const _Alloc &__a) noexcept {
return _S_max_size(__a, 0);
}
static _Alloc select_on_container_copy_construction(const _Alloc &__rhs) {
return _S_select(__rhs, 0);
}
};

template <typename _Tp> struct allocator_traits<allocator<_Tp>> {

using allocator_type = allocator<_Tp>;

using value_type = _Tp;

using pointer = _Tp *;

using const_pointer = const _Tp *;

using void_pointer = void *;

using const_void_pointer = const void *;

using difference_type = std::ptrdiff_t;

using size_type = std::size_t;

using propagate_on_container_copy_assignment = false_type;

using propagate_on_container_move_assignment = true_type;

using propagate_on_container_swap = false_type;

using is_always_equal = true_type;

template <typename _Up> using rebind_alloc = allocator<_Up>;

template <typename _Up>
using rebind_traits = allocator_traits<allocator<_Up>>;
[[__nodiscard__]] static pointer allocate(allocator_type &__a,
size_type __n) {
return __a.allocate(__n);
}
[[__nodiscard__]] static pointer
allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) {

return __a.allocate(__n, __hint);
}
static void deallocate(allocator_type &__a, pointer __p, size_type __n) {
__a.deallocate(__p, __n);
}
template <typename _Up, typename... _Args>
static void construct(
allocator_type &__a __attribute__((__unused__)), _Up *__p,
_Args
&&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::
value) {

__a.construct(__p, std::forward<_Args>(__args)...);
}
template <typename _Up>
static void
destroy(allocator_type &__a __attribute__((__unused__)),
_Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {

__a.destroy(__p);
}

static size_type max_size(const allocator_type &__a
__attribute__((__unused__))) noexcept {

return __a.max_size();
}

static allocator_type
select_on_container_copy_construction(const allocator_type &__rhs) {
return __rhs;
}
};

template <> struct allocator_traits<allocator<void>> {

using allocator_type = allocator<void>;

using value_type = void;

using pointer = void *;

using const_pointer = const void *;

using void_pointer = void *;

using const_void_pointer = const void *;

using difference_type = std::ptrdiff_t;

using size_type = std::size_t;

using propagate_on_container_copy_assignment = false_type;

using propagate_on_container_move_assignment = true_type;

using propagate_on_container_swap = false_type;

using is_always_equal = true_type;

template <typename _Up> using rebind_alloc = allocator<_Up>;

template <typename _Up>
using rebind_traits = allocator_traits<allocator<_Up>>;

static void *allocate(allocator_type &, size_type,
const void * = nullptr) = delete;

static void deallocate(allocator_type &, void *, size_type) = delete;
template <typename _Up, typename... _Args>
static void
construct(allocator_type &, _Up *__p, _Args &&...__args) noexcept(
std::is_nothrow_constructible<_Up, _Args...>::value) {
std::_Construct(__p, std::forward<_Args>(__args)...);
}
template <typename _Up>
static void
destroy(allocator_type &,
_Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
std::_Destroy(__p);
}

static size_type max_size(const allocator_type &) = delete;

static allocator_type
select_on_container_copy_construction(const allocator_type &__rhs) {
return __rhs;
}
};
template <typename _Alloc>
constexpr inline void __alloc_on_copy(_Alloc & __one, const _Alloc &__two) {
typedef allocator_traits<_Alloc> __traits;
typedef typename __traits::propagate_on_container_copy_assignment __pocca;

if constexpr (__pocca::value)
__one = __two;
}

template <typename _Alloc>
constexpr _Alloc __alloc_on_copy(const _Alloc &__a) {
typedef allocator_traits<_Alloc> __traits;
return __traits::select_on_container_copy_construction(__a);
}
template <typename _Alloc>
constexpr inline void __alloc_on_move(_Alloc & __one, _Alloc & __two) {
typedef allocator_traits<_Alloc> __traits;
typedef typename __traits::propagate_on_container_move_assignment __pocma;

if constexpr (__pocma::value)
__one = std::move(__two);
}
template <typename _Alloc>
constexpr inline void __alloc_on_swap(_Alloc & __one, _Alloc & __two) {
typedef allocator_traits<_Alloc> __traits;
typedef typename __traits::propagate_on_container_swap __pocs;

if constexpr (__pocs::value) {
using std::swap;
swap(__one, __two);
}
}

template <typename _Alloc, typename _Tp,
typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
typename = void>
struct __is_alloc_insertable_impl : false_type {};

template <typename _Alloc, typename _Tp, typename _ValueT>
struct __is_alloc_insertable_impl<
_Alloc, _Tp, _ValueT,
__void_t<decltype(allocator_traits<_Alloc>::construct(
std::declval<_Alloc &>(), std::declval<_ValueT *>(),
std::declval<_Tp>()))>> : true_type {};

template <typename _Alloc>
struct __is_copy_insertable
: __is_alloc_insertable_impl<_Alloc,
typename _Alloc::value_type const &>::type {
};

template <typename _Tp>
struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {};

template <typename _Alloc>
struct __is_move_insertable
: __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
};

template <typename _Tp>
struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {};

template <typename _Alloc, typename = void>
struct __is_allocator : false_type {};

template <typename _Alloc>
struct __is_allocator<
_Alloc, __void_t<typename _Alloc::value_type,
decltype(std::declval<_Alloc &>().allocate(size_t{}))>>
: true_type {};

template <typename _Alloc>
using _RequireAllocator =
typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

template <typename _Alloc>
using _RequireNotAllocator =
typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
template <typename _ForwardIterator, typename _Allocator>

void _Destroy(_ForwardIterator __first, _ForwardIterator __last,
_Allocator & __alloc) {
for (; __first != __last; ++__first)

allocator_traits<_Allocator>::destroy(__alloc,
std::__addressof(*__first));
}

template <typename _ForwardIterator, typename _Tp>

inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last,
allocator<_Tp> &) {
_Destroy(__first, __last);
}

} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

template <typename _Alloc, typename = typename _Alloc::value_type>
struct __alloc_traits

: std::allocator_traits<_Alloc>

{
typedef _Alloc allocator_type;

typedef std::allocator_traits<_Alloc> _Base_type;
typedef typename _Base_type::value_type value_type;
typedef typename _Base_type::pointer pointer;
typedef typename _Base_type::const_pointer const_pointer;
typedef typename _Base_type::size_type size_type;
typedef typename _Base_type::difference_type difference_type;

typedef value_type &reference;
typedef const value_type &const_reference;
using _Base_type::allocate;
using _Base_type::construct;
using _Base_type::deallocate;
using _Base_type::destroy;
using _Base_type::max_size;

private:
template <typename _Ptr>
using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>,
std::__not_<std::is_pointer<_Ptr>>>;

public:
template <typename _Ptr, typename... _Args>
static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(
noexcept(_Base_type::construct(__a, std::__to_address(__p),
std::forward<_Args>(__args)...))) {
_Base_type::construct(__a, std::__to_address(__p),
std::forward<_Args>(__args)...);
}

template <typename _Ptr>
static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
destroy(_Alloc &__a, _Ptr __p) noexcept(
noexcept(_Base_type::destroy(__a, std::__to_address(__p)))) {
_Base_type::destroy(__a, std::__to_address(__p));
}

static constexpr _Alloc _S_select_on_copy(const _Alloc &__a) {
return _Base_type::select_on_container_copy_construction(__a);
}

static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b) {
std::__alloc_on_swap(__a, __b);
}

static constexpr bool _S_propagate_on_copy_assign() {
return _Base_type::propagate_on_container_copy_assignment::value;
}

static constexpr bool _S_propagate_on_move_assign() {
return _Base_type::propagate_on_container_move_assignment::value;
}

static constexpr bool _S_propagate_on_swap() {
return _Base_type::propagate_on_container_swap::value;
}

static constexpr bool _S_always_equal() {
return _Base_type::is_always_equal::value;
}

static constexpr bool _S_nothrow_move() {
return _S_propagate_on_move_assign() || _S_always_equal();
}

template <typename _Tp> struct rebind {
typedef typename _Base_type::template rebind_alloc<_Tp> other;
};
};

} // namespace __gnu_cxx

namespace std {

size_t _Hash_bytes(const void *__ptr, size_t __len, size_t __seed);

size_t _Fnv_hash_bytes(const void *__ptr, size_t __len, size_t __seed);

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _Result, typename _Arg> struct __hash_base {
typedef _Result result_type [[__deprecated__]];
typedef _Arg argument_type [[__deprecated__]];
};

template <typename _Tp> struct hash;

template <typename _Tp, typename = void> struct __poison_hash {
static constexpr bool __enable_hash_call = false;

private:
__poison_hash(__poison_hash &&);
~__poison_hash();
};

template <typename _Tp>
struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
static constexpr bool __enable_hash_call = true;
};

template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
private:
__hash_enum(__hash_enum &&);
~__hash_enum();
};

template <typename _Tp>
struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp> {
size_t operator()(_Tp __val) const noexcept {
using __type = typename underlying_type<_Tp>::type;
return hash<__type>{}(static_cast<__type>(__val));
}
};

template <typename _Tp> struct hash : __hash_enum<_Tp> {};

template <typename _Tp>
struct hash<_Tp *> : public __hash_base<size_t, _Tp *> {
size_t operator()(_Tp *__p) const noexcept {
return reinterpret_cast<size_t>(__p);
}
};
template <> struct hash<bool> : public __hash_base<size_t, bool> {
size_t operator()(bool __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<char> : public __hash_base<size_t, char> {
size_t operator()(char __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<signed char> : public __hash_base<size_t, signed char> {
size_t operator()(signed char __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<unsigned char> : public __hash_base<size_t, unsigned char> {
size_t operator()(unsigned char __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> {
size_t operator()(wchar_t __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<char16_t> : public __hash_base<size_t, char16_t> {
size_t operator()(char16_t __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<char32_t> : public __hash_base<size_t, char32_t> {
size_t operator()(char32_t __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<short> : public __hash_base<size_t, short> {
size_t operator()(short __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<int> : public __hash_base<size_t, int> {
size_t operator()(int __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<long> : public __hash_base<size_t, long> {
size_t operator()(long __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <> struct hash<long long> : public __hash_base<size_t, long long> {
size_t operator()(long long __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<unsigned short> : public __hash_base<size_t, unsigned short> {
size_t operator()(unsigned short __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<unsigned int> : public __hash_base<size_t, unsigned int> {
size_t operator()(unsigned int __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<unsigned long> : public __hash_base<size_t, unsigned long> {
size_t operator()(unsigned long __val) const noexcept {
return static_cast<size_t>(__val);
}
};

template <>
struct hash<unsigned long long>
: public __hash_base<size_t, unsigned long long> {
size_t operator()(unsigned long long __val) const noexcept {
return static_cast<size_t>(__val);
}
};

__extension__ template <>
struct hash<__int128> : public __hash_base<size_t, __int128> {
size_t operator()(__int128 __val) const noexcept {
return static_cast<size_t>(__val);
}
};
__extension__ template <>
struct hash<__int128 unsigned>
: public __hash_base<size_t, __int128 unsigned> {
size_t operator()(__int128 unsigned __val) const noexcept {
return static_cast<size_t>(__val);
}
};
struct _Hash_impl {
static size_t hash(const void *__ptr, size_t __clength,
size_t __seed = static_cast<size_t>(0xc70f6907UL)) {
return _Hash_bytes(__ptr, __clength, __seed);
}

template <typename _Tp> static size_t hash(const _Tp &__val) {
return hash(&__val, sizeof(__val));
}

template <typename _Tp>
static size_t __hash_combine(const _Tp &__val, size_t __hash) {
return hash(&__val, sizeof(__val), __hash);
}
};

struct _Fnv_hash_impl {
static size_t hash(const void *__ptr, size_t __clength,
size_t __seed = static_cast<size_t>(2166136261UL)) {
return _Fnv_hash_bytes(__ptr, __clength, __seed);
}

template <typename _Tp> static size_t hash(const _Tp &__val) {
return hash(&__val, sizeof(__val));
}

template <typename _Tp>
static size_t __hash_combine(const _Tp &__val, size_t __hash) {
return hash(&__val, sizeof(__val), __hash);
}
};

template <> struct hash<float> : public __hash_base<size_t, float> {
size_t operator()(float __val) const noexcept {

return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
}
};

template <> struct hash<double> : public __hash_base<size_t, double> {
size_t operator()(double __val) const noexcept {

return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
}
};

template <>
struct hash<long double> : public __hash_base<size_t, long double> {
__attribute__((__pure__)) size_t
operator()(long double __val) const noexcept;
};

template <> struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t> {
size_t operator()(nullptr_t) const noexcept { return 0; }
};
template <typename _Hash> struct __is_fast_hash : public std::true_type {};

template <>
struct __is_fast_hash<hash<long double>> : public std::false_type {};

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

constexpr size_t __sv_check(size_t __size, size_t __pos, const char *__s) {
if (__pos > __size)
__throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size "
"(which is %zu)"),
__s, __pos, __size);
return __pos;
}

constexpr size_t __sv_limit(size_t __size, size_t __pos,
size_t __off) noexcept {
const bool __testoff = __off < __size - __pos;
return __testoff ? __off : __size - __pos;
}
template <typename _CharT, typename _Traits = std::char_traits<_CharT>>
class basic_string_view {
static_assert(!is_array_v<_CharT>);
static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
static_assert(is_same_v<_CharT, typename _Traits::char_type>);

public:
using traits_type = _Traits;
using value_type = _CharT;
using pointer = value_type *;
using const_pointer = const value_type *;
using reference = value_type &;
using const_reference = const value_type &;
using const_iterator = const value_type *;
using iterator = const_iterator;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using reverse_iterator = const_reverse_iterator;
using size_type = size_t;
using difference_type = ptrdiff_t;
static constexpr size_type npos = size_type(-1);

constexpr basic_string_view() noexcept : _M_len{0}, _M_str{nullptr} {}

constexpr basic_string_view(const basic_string_view &) noexcept = default;

__attribute__((__nonnull__)) constexpr basic_string_view(
const _CharT *__str) noexcept
: _M_len{traits_type::length(__str)}, _M_str{__str} {}

constexpr basic_string_view(const _CharT *__str, size_type __len) noexcept
: _M_len{__len}, _M_str{__str} {}
constexpr basic_string_view &
operator=(const basic_string_view &) noexcept = default;

constexpr const_iterator begin() const noexcept { return this->_M_str; }

constexpr const_iterator end() const noexcept {
return this->_M_str + this->_M_len;
}

constexpr const_iterator cbegin() const noexcept { return this->_M_str; }

constexpr const_iterator cend() const noexcept {
return this->_M_str + this->_M_len;
}

constexpr const_reverse_iterator rbegin() const noexcept {
return const_reverse_iterator(this->end());
}

constexpr const_reverse_iterator rend() const noexcept {
return const_reverse_iterator(this->begin());
}

constexpr const_reverse_iterator crbegin() const noexcept {
return const_reverse_iterator(this->end());
}

constexpr const_reverse_iterator crend() const noexcept {
return const_reverse_iterator(this->begin());
}

constexpr size_type size() const noexcept { return this->_M_len; }

constexpr size_type length() const noexcept { return _M_len; }

constexpr size_type max_size() const noexcept {
return (npos - sizeof(size_type) - sizeof(void *)) / sizeof(value_type) /
4;
}

[[nodiscard]] constexpr bool empty() const noexcept {
return this->_M_len == 0;
}

constexpr const_reference operator[](size_type __pos) const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(__pos < this->_M_len))
__builtin_unreachable();
} while (false);
return *(this->_M_str + __pos);
}

constexpr const_reference at(size_type __pos) const {
if (__pos >= _M_len)
__throw_out_of_range_fmt(("basic_string_view::at: __pos "
"(which is %zu) >= this->size() "
"(which is %zu)")

,
__pos, this->size());
return *(this->_M_str + __pos);
}

constexpr const_reference front() const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
__builtin_unreachable();
} while (false);
return *this->_M_str;
}

constexpr const_reference back() const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
__builtin_unreachable();
} while (false);
return *(this->_M_str + this->_M_len - 1);
}

constexpr const_pointer data() const noexcept { return this->_M_str; }

constexpr void remove_prefix(size_type __n) noexcept {
do {
if (std::__is_constant_evaluated() && !bool(this->_M_len >= __n))
__builtin_unreachable();
} while (false);
this->_M_str += __n;
this->_M_len -= __n;
}

constexpr void remove_suffix(size_type __n) noexcept {
this->_M_len -= __n;
}

constexpr void swap(basic_string_view &__sv) noexcept {
auto __tmp = *this;
*this = __sv;
__sv = __tmp;
}

size_type copy(_CharT *__str, size_type __n, size_type __pos = 0) const {
;
__pos = std::__sv_check(size(), __pos, "basic_string_view::copy");
const size_type __rlen = std::min(__n, _M_len - __pos);

traits_type::copy(__str, data() + __pos, __rlen);
return __rlen;
}

constexpr basic_string_view substr(size_type __pos = 0,
size_type __n = npos) const
noexcept(false) {
__pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
const size_type __rlen = std::min(__n, _M_len - __pos);
return basic_string_view{_M_str + __pos, __rlen};
}

constexpr int compare(basic_string_view __str) const noexcept {
const size_type __rlen = std::min(this->_M_len, __str._M_len);
int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
if (__ret == 0)
__ret = _S_compare(this->_M_len, __str._M_len);
return __ret;
}

constexpr int compare(size_type __pos1, size_type __n1,
basic_string_view __str) const {
return this->substr(__pos1, __n1).compare(__str);
}

constexpr int compare(size_type __pos1, size_type __n1,
basic_string_view __str, size_type __pos2,
size_type __n2) const {
return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
}

__attribute__((__nonnull__)) constexpr int
compare(const _CharT *__str) const noexcept {
return this->compare(basic_string_view{__str});
}

__attribute__((__nonnull__)) constexpr int
compare(size_type __pos1, size_type __n1, const _CharT *__str) const {
return this->substr(__pos1, __n1).compare(basic_string_view{__str});
}

constexpr int compare(size_type __pos1, size_type __n1, const _CharT *__str,
size_type __n2) const noexcept(false) {
return this->substr(__pos1, __n1).compare(basic_string_view(__str, __n2));
}
constexpr size_type find(basic_string_view __str,
size_type __pos = 0) const noexcept {
return this->find(__str._M_str, __pos, __str._M_len);
}

constexpr size_type find(_CharT __c, size_type __pos = 0) const noexcept;

constexpr size_type find(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
find(const _CharT *__str, size_type __pos = 0) const noexcept {
return this->find(__str, __pos, traits_type::length(__str));
}

constexpr size_type rfind(basic_string_view __str,
size_type __pos = npos) const noexcept {
return this->rfind(__str._M_str, __pos, __str._M_len);
}

constexpr size_type rfind(_CharT __c,
size_type __pos = npos) const noexcept;

constexpr size_type rfind(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
rfind(const _CharT *__str, size_type __pos = npos) const noexcept {
return this->rfind(__str, __pos, traits_type::length(__str));
}

constexpr size_type find_first_of(basic_string_view __str,
size_type __pos = 0) const noexcept {
return this->find_first_of(__str._M_str, __pos, __str._M_len);
}

constexpr size_type find_first_of(_CharT __c,
size_type __pos = 0) const noexcept {
return this->find(__c, __pos);
}

constexpr size_type find_first_of(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
find_first_of(const _CharT *__str, size_type __pos = 0) const noexcept {
return this->find_first_of(__str, __pos, traits_type::length(__str));
}

constexpr size_type find_last_of(basic_string_view __str,
size_type __pos = npos) const noexcept {
return this->find_last_of(__str._M_str, __pos, __str._M_len);
}

constexpr size_type find_last_of(_CharT __c,
size_type __pos = npos) const noexcept {
return this->rfind(__c, __pos);
}

constexpr size_type find_last_of(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
find_last_of(const _CharT *__str, size_type __pos = npos) const noexcept {
return this->find_last_of(__str, __pos, traits_type::length(__str));
}

constexpr size_type find_first_not_of(basic_string_view __str,
size_type __pos = 0) const noexcept {
return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
}

constexpr size_type find_first_not_of(_CharT __c,
size_type __pos = 0) const noexcept;

constexpr size_type find_first_not_of(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
find_first_not_of(const _CharT *__str, size_type __pos = 0) const noexcept {
return this->find_first_not_of(__str, __pos, traits_type::length(__str));
}

constexpr size_type
find_last_not_of(basic_string_view __str,
size_type __pos = npos) const noexcept {
return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
}

constexpr size_type find_last_not_of(_CharT __c,
size_type __pos = npos) const noexcept;

constexpr size_type find_last_not_of(const _CharT *__str, size_type __pos,
size_type __n) const noexcept;

__attribute__((__nonnull__)) constexpr size_type
find_last_not_of(const _CharT *__str,
size_type __pos = npos) const noexcept {
return this->find_last_not_of(__str, __pos, traits_type::length(__str));
}

private:
static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept {
using __limits = __gnu_cxx::__int_traits<int>;
const difference_type __diff = __n1 - __n2;
if (__diff > __limits::__max)
return __limits::__max;
if (__diff < __limits::__min)
return __limits::__min;
return static_cast<int>(__diff);
}

size_t _M_len;
const _CharT *_M_str;
};
template <typename _CharT, typename _Traits>
constexpr bool operator==(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.size() == __y.size() && __x.compare(__y) == 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator==(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return __x.size() == __y.size() && __x.compare(__y) == 0;
}
template <typename _CharT, typename _Traits>
constexpr bool operator==(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.size() == __y.size() && __x.compare(__y) == 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator!=(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return !(__x == __y);
}

template <typename _CharT, typename _Traits>
constexpr bool operator!=(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return !(__x == __y);
}

template <typename _CharT, typename _Traits>
constexpr bool operator!=(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return !(__x == __y);
}

template <typename _CharT, typename _Traits>
constexpr bool operator<(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) < 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator<(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return __x.compare(__y) < 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator<(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) < 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) > 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return __x.compare(__y) > 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) > 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator<=(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) <= 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator<=(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return __x.compare(__y) <= 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator<=(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) <= 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>=(basic_string_view<_CharT, _Traits> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) >= 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>=(
basic_string_view<_CharT, _Traits> __x,
__type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
return __x.compare(__y) >= 0;
}

template <typename _CharT, typename _Traits>
constexpr bool operator>=(
__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
basic_string_view<_CharT, _Traits> __y) noexcept {
return __x.compare(__y) >= 0;
}

template <typename _CharT, typename _Traits>
inline basic_ostream<_CharT, _Traits> &operator<<(
basic_ostream<_CharT, _Traits> &__os,
basic_string_view<_CharT, _Traits> __str) {
return __ostream_insert(__os, __str.data(), __str.size());
}

using string_view = basic_string_view<char>;
using wstring_view = basic_string_view<wchar_t>;

using u16string_view = basic_string_view<char16_t>;
using u32string_view = basic_string_view<char32_t>;

template <typename _Tp> struct hash;

template <>
struct hash<string_view> : public __hash_base<size_t, string_view> {
size_t operator()(const string_view &__str) const noexcept {
return std::_Hash_impl::hash(__str.data(), __str.length());
}
};

template <> struct __is_fast_hash<hash<string_view>> : std::false_type {};

template <>
struct hash<wstring_view> : public __hash_base<size_t, wstring_view> {
size_t operator()(const wstring_view &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
}
};

template <> struct __is_fast_hash<hash<wstring_view>> : std::false_type {};
template <>
struct hash<u16string_view> : public __hash_base<size_t, u16string_view> {
size_t operator()(const u16string_view &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
}
};

template <> struct __is_fast_hash<hash<u16string_view>> : std::false_type {};

template <>
struct hash<u32string_view> : public __hash_base<size_t, u32string_view> {
size_t operator()(const u32string_view &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
}
};

template <> struct __is_fast_hash<hash<u32string_view>> : std::false_type {};

inline namespace literals {
inline namespace string_view_literals {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
inline constexpr basic_string_view<char> operator""sv(const char *__str,
size_t __len) noexcept {
return basic_string_view<char>{__str, __len};
}

inline constexpr basic_string_view<wchar_t>
operator""sv(const wchar_t *__str, size_t __len) noexcept {
return basic_string_view<wchar_t>{__str, __len};
}

inline constexpr basic_string_view<char16_t>
operator""sv(const char16_t *__str, size_t __len) noexcept {
return basic_string_view<char16_t>{__str, __len};
}

inline constexpr basic_string_view<char32_t>
operator""sv(const char32_t *__str, size_t __len) noexcept {
return basic_string_view<char32_t>{__str, __len};
}

#pragma GCC diagnostic pop
} // namespace string_view_literals
} // namespace literals

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find(const _CharT *__str, size_type __pos,
size_type __n) const noexcept {
;

if (__n == 0)
return __pos <= _M_len ? __pos : npos;
if (__pos >= _M_len)
return npos;

const _CharT __elem0 = __str[0];
const _CharT *__first = _M_str + __pos;
const _CharT *const __last = _M_str + _M_len;
size_type __len = _M_len - __pos;

while (__len >= __n) {

__first = traits_type::find(__first, __len - __n + 1, __elem0);
if (!__first)
return npos;

if (traits_type::compare(__first, __str, __n) == 0)
return __first - _M_str;
__len = __last - ++__first;
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find(_CharT __c, size_type __pos)
const noexcept {
size_type __ret = npos;
if (__pos < this->_M_len) {
const size_type __n = this->_M_len - __pos;
const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
if (__p)
__ret = __p - this->_M_str;
}
return __ret;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::rfind(
const _CharT *__str, size_type __pos, size_type __n) const noexcept {
;

if (__n <= this->_M_len) {
__pos = std::min(size_type(this->_M_len - __n), __pos);
do {
if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
return __pos;
} while (__pos-- > 0);
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::rfind(_CharT __c, size_type __pos)
const noexcept {
size_type __size = this->_M_len;
if (__size > 0) {
if (--__size > __pos)
__size = __pos;
for (++__size; __size-- > 0;)
if (traits_type::eq(this->_M_str[__size], __c))
return __size;
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_first_of(
const _CharT *__str, size_type __pos, size_type __n) const noexcept {
;
for (; __n && __pos < this->_M_len; ++__pos) {
const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
if (__p)
return __pos;
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_last_of(
const _CharT *__str, size_type __pos, size_type __n) const noexcept {
;
size_type __size = this->size();
if (__size && __n) {
if (--__size > __pos)
__size = __pos;
do {
if (traits_type::find(__str, __n, this->_M_str[__size]))
return __size;
} while (__size-- != 0);
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_first_not_of(
const _CharT *__str, size_type __pos, size_type __n) const noexcept {
;
for (; __pos < this->_M_len; ++__pos)
if (!traits_type::find(__str, __n, this->_M_str[__pos]))
return __pos;
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_first_not_of(
_CharT __c, size_type __pos) const noexcept {
for (; __pos < this->_M_len; ++__pos)
if (!traits_type::eq(this->_M_str[__pos], __c))
return __pos;
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_last_not_of(
const _CharT *__str, size_type __pos, size_type __n) const noexcept {
;
size_type __size = this->_M_len;
if (__size) {
if (--__size > __pos)
__size = __pos;
do {
if (!traits_type::find(__str, __n, this->_M_str[__size]))
return __size;
} while (__size--);
}
return npos;
}

template <typename _CharT, typename _Traits>
constexpr typename basic_string_view<_CharT, _Traits>::size_type
basic_string_view<_CharT, _Traits>::find_last_not_of(
_CharT __c, size_type __pos) const noexcept {
size_type __size = this->_M_len;
if (__size) {
if (--__size > __pos)
__size = __pos;
do {
if (!traits_type::eq(this->_M_str[__size], __c))
return __size;
} while (__size--);
}
return npos;
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __cxx11 {
template <typename _CharT, typename _Traits, typename _Alloc>
class basic_string {
typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<
_CharT>::other _Char_alloc_type;

typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;

public:
typedef _Traits traits_type;
typedef typename _Traits::char_type value_type;
typedef _Char_alloc_type allocator_type;
typedef typename _Alloc_traits::size_type size_type;
typedef typename _Alloc_traits::difference_type difference_type;
typedef typename _Alloc_traits::reference reference;
typedef typename _Alloc_traits::const_reference const_reference;
typedef typename _Alloc_traits::pointer pointer;
typedef typename _Alloc_traits::const_pointer const_pointer;
typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
const_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
typedef std::reverse_iterator<iterator> reverse_iterator;

static const size_type npos = static_cast<size_type>(-1);

protected:
typedef const_iterator __const_iterator;

private:
typedef basic_string_view<_CharT, _Traits> __sv_type;

template <typename _Tp, typename _Res>
using _If_sv = enable_if_t<
__and_<is_convertible<const _Tp &, __sv_type>,
__not_<is_convertible<const _Tp *, const basic_string *>>,
__not_<is_convertible<const _Tp &, const _CharT *>>>::value,
_Res>;

static __sv_type _S_to_string_view(__sv_type __svt) noexcept {
return __svt;
}

struct __sv_wrapper {
explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) {}

__sv_type _M_sv;
};

explicit basic_string(__sv_wrapper __svw, const _Alloc &__a)
: basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) {}

struct _Alloc_hider : allocator_type {

_Alloc_hider(pointer __dat, const _Alloc &__a)
: allocator_type(__a), _M_p(__dat) {}

_Alloc_hider(pointer __dat, _Alloc &&__a = _Alloc())
: allocator_type(std::move(__a)), _M_p(__dat) {}

pointer _M_p;
};

_Alloc_hider _M_dataplus;
size_type _M_string_length;

enum { _S_local_capacity = 15 / sizeof(_CharT) };

union {
_CharT _M_local_buf[_S_local_capacity + 1];
size_type _M_allocated_capacity;
};

void _M_data(pointer __p) { _M_dataplus._M_p = __p; }

void _M_length(size_type __length) { _M_string_length = __length; }

pointer _M_data() const { return _M_dataplus._M_p; }

pointer _M_local_data() {

return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
}

const_pointer _M_local_data() const {

return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
}

void _M_capacity(size_type __capacity) {
_M_allocated_capacity = __capacity;
}

void _M_set_length(size_type __n) {
_M_length(__n);
traits_type::assign(_M_data()[__n], _CharT());
}

bool _M_is_local() const { return _M_data() == _M_local_data(); }

pointer _M_create(size_type &, size_type);

void _M_dispose() {
if (!_M_is_local())
_M_destroy(_M_allocated_capacity);
}

void _M_destroy(size_type __size) throw() {
_Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
}
template <typename _InIterator>

void _M_construct(_InIterator __beg, _InIterator __end,
std::input_iterator_tag);

template <typename _FwdIterator>

void _M_construct(_FwdIterator __beg, _FwdIterator __end,
std::forward_iterator_tag);

void _M_construct(size_type __req, _CharT __c);

allocator_type &_M_get_allocator() { return _M_dataplus; }

const allocator_type &_M_get_allocator() const { return _M_dataplus; }

__attribute__((__always_inline__)) constexpr pointer
_M_use_local_data() noexcept {

return _M_local_data();
}

private:
size_type _M_check(size_type __pos, const char *__s) const {
if (__pos > this->size())
__throw_out_of_range_fmt(("%s: __pos (which is %zu) > "
"this->size() (which is %zu)"),
__s, __pos, this->size());
return __pos;
}

void _M_check_length(size_type __n1, size_type __n2,
const char *__s) const {
if (this->max_size() - (this->size() - __n1) < __n2)
__throw_length_error((__s));
}

size_type _M_limit(size_type __pos, size_type __off) const noexcept {
const bool __testoff = __off < this->size() - __pos;
return __testoff ? __off : this->size() - __pos;
}

bool _M_disjunct(const _CharT *__s) const noexcept {
return (less<const _CharT *>()(__s, _M_data()) ||
less<const _CharT *>()(_M_data() + this->size(), __s));
}

static void _S_copy(_CharT *__d, const _CharT *__s, size_type __n) {
if (__n == 1)
traits_type::assign(*__d, *__s);
else
traits_type::copy(__d, __s, __n);
}

static void _S_move(_CharT *__d, const _CharT *__s, size_type __n) {
if (__n == 1)
traits_type::assign(*__d, *__s);
else
traits_type::move(__d, __s, __n);
}

static void _S_assign(_CharT *__d, size_type __n, _CharT __c) {
if (__n == 1)
traits_type::assign(*__d, __c);
else
traits_type::assign(__d, __n, __c);
}

template <class _Iterator>

static void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) {
for (; __k1 != __k2; ++__k1, (void)++__p)
traits_type::assign(*__p, *__k1);
}

static void _S_copy_chars(_CharT *__p, iterator __k1,
iterator __k2) noexcept {
_S_copy_chars(__p, __k1.base(), __k2.base());
}

static void _S_copy_chars(_CharT *__p, const_iterator __k1,
const_iterator __k2) noexcept {
_S_copy_chars(__p, __k1.base(), __k2.base());
}

static void _S_copy_chars(_CharT *__p, _CharT *__k1,
_CharT *__k2) noexcept {
_S_copy(__p, __k1, __k2 - __k1);
}

static void _S_copy_chars(_CharT *__p, const _CharT *__k1,
const _CharT *__k2) noexcept {
_S_copy(__p, __k1, __k2 - __k1);
}

static int _S_compare(size_type __n1, size_type __n2) noexcept {
const difference_type __d = difference_type(__n1 - __n2);

if (__d > __gnu_cxx::__numeric_traits<int>::__max)
return __gnu_cxx::__numeric_traits<int>::__max;
else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
return __gnu_cxx::__numeric_traits<int>::__min;
else
return int(__d);
}

void _M_assign(const basic_string &);

void _M_mutate(size_type __pos, size_type __len1, const _CharT *__s,
size_type __len2);

void _M_erase(size_type __pos, size_type __n);

public:
basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
: _M_dataplus(_M_local_data()) {
_M_use_local_data();
_M_set_length(0);
}

explicit basic_string(const _Alloc &__a) noexcept
: _M_dataplus(_M_local_data(), __a) {
_M_use_local_data();
_M_set_length(0);
}

basic_string(const basic_string &__str)
: _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(
__str._M_get_allocator())) {
_M_construct(__str._M_data(), __str._M_data() + __str.length(),
std::forward_iterator_tag());
}

basic_string(const basic_string &__str, size_type __pos,
const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {
const _CharT *__start =
__str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
_M_construct(__start, __start + __str._M_limit(__pos, npos),
std::forward_iterator_tag());
}

basic_string(const basic_string &__str, size_type __pos, size_type __n)
: _M_dataplus(_M_local_data()) {
const _CharT *__start =
__str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
_M_construct(__start, __start + __str._M_limit(__pos, __n),
std::forward_iterator_tag());
}

basic_string(const basic_string &__str, size_type __pos, size_type __n,
const _Alloc &__a)
: _M_dataplus(_M_local_data(), __a) {
const _CharT *__start =
__str._M_data() + __str._M_check(__pos, "string::string");
_M_construct(__start, __start + __str._M_limit(__pos, __n),
std::forward_iterator_tag());
}

basic_string(const _CharT *__s, size_type __n, const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {

if (__s == 0 && __n > 0)
std::__throw_logic_error(("basic_string: "
"construction from null is not valid"));
_M_construct(__s, __s + __n, std::forward_iterator_tag());
}
template <typename = _RequireAllocator<_Alloc>>

basic_string(const _CharT *__s, const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {

if (__s == 0)
std::__throw_logic_error(("basic_string: "
"construction from null is not valid"));
const _CharT *__end = __s + traits_type::length(__s);
_M_construct(__s, __end, forward_iterator_tag());
}
template <typename = _RequireAllocator<_Alloc>>

basic_string(size_type __n, _CharT __c, const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {
_M_construct(__n, __c);
}

basic_string(basic_string &&__str) noexcept
: _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())) {
if (__str._M_is_local()) {
traits_type::copy(_M_local_buf, __str._M_local_buf, __str.length() + 1);
} else {
_M_data(__str._M_data());
_M_capacity(__str._M_allocated_capacity);
}

_M_length(__str.length());
__str._M_data(__str._M_local_data());
__str._M_set_length(0);
}

basic_string(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {
_M_construct(__l.begin(), __l.end(), std::forward_iterator_tag());
}

basic_string(const basic_string &__str, const _Alloc &__a)
: _M_dataplus(_M_local_data(), __a) {
_M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
}

basic_string(basic_string &&__str,
const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal())
: _M_dataplus(_M_local_data(), __a) {
if (__str._M_is_local()) {
traits_type::copy(_M_local_buf, __str._M_local_buf, __str.length() + 1);
_M_length(__str.length());
__str._M_set_length(0);
} else if (_Alloc_traits::_S_always_equal() ||
__str.get_allocator() == __a) {
_M_data(__str._M_data());
_M_length(__str.length());
_M_capacity(__str._M_allocated_capacity);
__str._M_data(__str._M_local_buf);
__str._M_set_length(0);
} else
_M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
}
template <typename _InputIterator,
typename = std::_RequireInputIter<_InputIterator>>

basic_string(_InputIterator __beg, _InputIterator __end,
const _Alloc &__a = _Alloc())
: _M_dataplus(_M_local_data(), __a) {

_M_construct(__beg, __end, std::__iterator_category(__beg));
}
template <typename _Tp,
typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>>

basic_string(const _Tp &__t, size_type __pos, size_type __n,
const _Alloc &__a = _Alloc())
: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) {}

template <typename _Tp, typename = _If_sv<_Tp, void>>

explicit basic_string(const _Tp &__t, const _Alloc &__a = _Alloc())
: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) {}

~basic_string() { _M_dispose(); }

basic_string &operator=(const basic_string &__str) {
return this->assign(__str);
}

basic_string &operator=(const _CharT *__s) { return this->assign(__s); }

basic_string &operator=(_CharT __c) {
this->assign(1, __c);
return *this;
}

basic_string &
operator=(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() &&
!_Alloc_traits::_S_always_equal() &&
_M_get_allocator() != __str._M_get_allocator()) {

_M_destroy(_M_allocated_capacity);
_M_data(_M_local_data());
_M_set_length(0);
}

std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

if (__str._M_is_local()) {

if (__builtin_expect(std::__addressof(__str) != this, true)) {
if (__str.size())
this->_S_copy(_M_data(), __str._M_data(), __str.size());
_M_set_length(__str.size());
}
} else if (_Alloc_traits::_S_propagate_on_move_assign() ||
_Alloc_traits::_S_always_equal() ||
_M_get_allocator() == __str._M_get_allocator()) {

pointer __data = nullptr;
size_type __capacity;
if (!_M_is_local()) {
if (_Alloc_traits::_S_always_equal()) {

__data = _M_data();
__capacity = _M_allocated_capacity;
} else
_M_destroy(_M_allocated_capacity);
}

_M_data(__str._M_data());
_M_length(__str.length());
_M_capacity(__str._M_allocated_capacity);
if (__data) {
__str._M_data(__data);
__str._M_capacity(__capacity);
} else
__str._M_data(__str._M_local_buf);
} else
assign(__str);
__str.clear();
return *this;
}

basic_string &operator=(initializer_list<_CharT> __l) {
this->assign(__l.begin(), __l.size());
return *this;
}

template <typename _Tp>

_If_sv<_Tp, basic_string &> operator=(const _Tp &__svt) {
return this->assign(__svt);
}

operator __sv_type() const noexcept { return __sv_type(data(), size()); }

iterator begin() noexcept { return iterator(_M_data()); }

const_iterator begin() const noexcept { return const_iterator(_M_data()); }

iterator end() noexcept { return iterator(_M_data() + this->size()); }

const_iterator end() const noexcept {
return const_iterator(_M_data() + this->size());
}

reverse_iterator rbegin() noexcept { return reverse_iterator(this->end()); }

const_reverse_iterator rbegin() const noexcept {
return const_reverse_iterator(this->end());
}

reverse_iterator rend() noexcept { return reverse_iterator(this->begin()); }

const_reverse_iterator rend() const noexcept {
return const_reverse_iterator(this->begin());
}

const_iterator cbegin() const noexcept {
return const_iterator(this->_M_data());
}

const_iterator cend() const noexcept {
return const_iterator(this->_M_data() + this->size());
}

const_reverse_iterator crbegin() const noexcept {
return const_reverse_iterator(this->end());
}

const_reverse_iterator crend() const noexcept {
return const_reverse_iterator(this->begin());
}

public:
size_type size() const noexcept { return _M_string_length; }

size_type length() const noexcept { return _M_string_length; }

size_type max_size() const noexcept {
return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
}

void resize(size_type __n, _CharT __c);

void resize(size_type __n) { this->resize(__n, _CharT()); }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

void shrink_to_fit() noexcept { reserve(); }
#pragma GCC diagnostic pop

size_type capacity() const noexcept {
return _M_is_local() ? size_type(_S_local_capacity)
: _M_allocated_capacity;
}

void reserve(size_type __res_arg);

void reserve();

void clear() noexcept { _M_set_length(0); }

[[__nodiscard__]] bool empty() const noexcept { return this->size() == 0; }

const_reference operator[](size_type __pos) const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(__pos <= size()))
__builtin_unreachable();
} while (false);
return _M_data()[__pos];
}

reference operator[](size_type __pos) {

do {
if (std::__is_constant_evaluated() && !bool(__pos <= size()))
__builtin_unreachable();
} while (false);

;
return _M_data()[__pos];
}

const_reference at(size_type __n) const {
if (__n >= this->size())
__throw_out_of_range_fmt(("basic_string::at: __n "
"(which is %zu) >= this->size() "
"(which is %zu)")

,
__n, this->size());
return _M_data()[__n];
}

reference at(size_type __n) {
if (__n >= size())
__throw_out_of_range_fmt(("basic_string::at: __n "
"(which is %zu) >= this->size() "
"(which is %zu)")

,
__n, this->size());
return _M_data()[__n];
}

reference front() noexcept {
do {
if (std::__is_constant_evaluated() && !bool(!empty()))
__builtin_unreachable();
} while (false);
return operator[](0);
}

const_reference front() const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(!empty()))
__builtin_unreachable();
} while (false);
return operator[](0);
}

reference back() noexcept {
do {
if (std::__is_constant_evaluated() && !bool(!empty()))
__builtin_unreachable();
} while (false);
return operator[](this->size() - 1);
}

const_reference back() const noexcept {
do {
if (std::__is_constant_evaluated() && !bool(!empty()))
__builtin_unreachable();
} while (false);
return operator[](this->size() - 1);
}

basic_string &operator+=(const basic_string &__str) {
return this->append(__str);
}

basic_string &operator+=(const _CharT *__s) { return this->append(__s); }

basic_string &operator+=(_CharT __c) {
this->push_back(__c);
return *this;
}

basic_string &operator+=(initializer_list<_CharT> __l) {
return this->append(__l.begin(), __l.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> operator+=(const _Tp &__svt) {
return this->append(__svt);
}

basic_string &append(const basic_string &__str) {
return this->append(__str._M_data(), __str.size());
}

basic_string &append(const basic_string &__str, size_type __pos,
size_type __n = npos) {
return this->append(__str._M_data() +
__str._M_check(__pos, "basic_string::append"),
__str._M_limit(__pos, __n));
}

basic_string &append(const _CharT *__s, size_type __n) {
;
_M_check_length(size_type(0), __n, "basic_string::append");
return _M_append(__s, __n);
}

basic_string &append(const _CharT *__s) {
;
const size_type __n = traits_type::length(__s);
_M_check_length(size_type(0), __n, "basic_string::append");
return _M_append(__s, __n);
}

basic_string &append(size_type __n, _CharT __c) {
return _M_replace_aux(this->size(), size_type(0), __n, __c);
}

basic_string &append(initializer_list<_CharT> __l) {
return this->append(__l.begin(), __l.size());
}
template <class _InputIterator,
typename = std::_RequireInputIter<_InputIterator>>

basic_string &append(_InputIterator __first, _InputIterator __last) {
return this->replace(end(), end(), __first, __last);
}

template <typename _Tp>

_If_sv<_Tp, basic_string &> append(const _Tp &__svt) {
__sv_type __sv = __svt;
return this->append(__sv.data(), __sv.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> append(const _Tp &__svt, size_type __pos,
size_type __n = npos) {
__sv_type __sv = __svt;
return _M_append(__sv.data() + std::__sv_check(__sv.size(), __pos,
"basic_string::append"),
std::__sv_limit(__sv.size(), __pos, __n));
}

void push_back(_CharT __c) {
const size_type __size = this->size();
if (__size + 1 > this->capacity())
this->_M_mutate(__size, size_type(0), 0, size_type(1));
traits_type::assign(this->_M_data()[__size], __c);
this->_M_set_length(__size + 1);
}

basic_string &assign(const basic_string &__str) {

if (_Alloc_traits::_S_propagate_on_copy_assign()) {
if (!_Alloc_traits::_S_always_equal() && !_M_is_local() &&
_M_get_allocator() != __str._M_get_allocator()) {

if (__str.size() <= _S_local_capacity) {
_M_destroy(_M_allocated_capacity);
_M_data(_M_use_local_data());
_M_set_length(0);
} else {
const auto __len = __str.size();
auto __alloc = __str._M_get_allocator();

auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
_M_destroy(_M_allocated_capacity);
_M_data(__ptr);
_M_capacity(__len);
_M_set_length(__len);
}
}
std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
}

this->_M_assign(__str);
return *this;
}

basic_string &
assign(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {

return *this = std::move(__str);
}

basic_string &assign(const basic_string &__str, size_type __pos,
size_type __n = npos) {
return _M_replace(size_type(0), this->size(),
__str._M_data() +
__str._M_check(__pos, "basic_string::assign"),
__str._M_limit(__pos, __n));
}

basic_string &assign(const _CharT *__s, size_type __n) {
;
return _M_replace(size_type(0), this->size(), __s, __n);
}

basic_string &assign(const _CharT *__s) {
;
return _M_replace(size_type(0), this->size(), __s,
traits_type::length(__s));
}

basic_string &assign(size_type __n, _CharT __c) {
return _M_replace_aux(size_type(0), this->size(), __n, __c);
}
template <class _InputIterator,
typename = std::_RequireInputIter<_InputIterator>>

basic_string &assign(_InputIterator __first, _InputIterator __last) {
return this->replace(begin(), end(), __first, __last);
}

basic_string &assign(initializer_list<_CharT> __l) {
return this->assign(__l.begin(), __l.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> assign(const _Tp &__svt) {
__sv_type __sv = __svt;
return this->assign(__sv.data(), __sv.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> assign(const _Tp &__svt, size_type __pos,
size_type __n = npos) {
__sv_type __sv = __svt;
return _M_replace(size_type(0), this->size(),
__sv.data() + std::__sv_check(__sv.size(), __pos,
"basic_string::assign"),
std::__sv_limit(__sv.size(), __pos, __n));
}

iterator insert(const_iterator __p, size_type __n, _CharT __c) {
;
const size_type __pos = __p - begin();
this->replace(__p, __p, __n, __c);
return iterator(this->_M_data() + __pos);
}
template <class _InputIterator,
typename = std::_RequireInputIter<_InputIterator>>

iterator insert(const_iterator __p, _InputIterator __beg,
_InputIterator __end) {
;
const size_type __pos = __p - begin();
this->replace(__p, __p, __beg, __end);
return iterator(this->_M_data() + __pos);
}

iterator insert(const_iterator __p, initializer_list<_CharT> __l) {
return this->insert(__p, __l.begin(), __l.end());
}

basic_string &insert(size_type __pos1, const basic_string &__str) {
return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
}

basic_string &insert(size_type __pos1, const basic_string &__str,
size_type __pos2, size_type __n = npos) {
return this->replace(__pos1, size_type(0),
__str._M_data() +
__str._M_check(__pos2, "basic_string::insert"),
__str._M_limit(__pos2, __n));
}

basic_string &insert(size_type __pos, const _CharT *__s, size_type __n) {
return this->replace(__pos, size_type(0), __s, __n);
}

basic_string &insert(size_type __pos, const _CharT *__s) {
;
return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
}

basic_string &insert(size_type __pos, size_type __n, _CharT __c) {
return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
size_type(0), __n, __c);
}

iterator insert(__const_iterator __p, _CharT __c) {
;
const size_type __pos = __p - begin();
_M_replace_aux(__pos, size_type(0), size_type(1), __c);
return iterator(_M_data() + __pos);
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> insert(size_type __pos, const _Tp &__svt) {
__sv_type __sv = __svt;
return this->insert(__pos, __sv.data(), __sv.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> insert(size_type __pos1, const _Tp &__svt,
size_type __pos2, size_type __n = npos) {
__sv_type __sv = __svt;
return this->replace(
__pos1, size_type(0),
__sv.data() +
std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
std::__sv_limit(__sv.size(), __pos2, __n));
}

basic_string &erase(size_type __pos = 0, size_type __n = npos) {
_M_check(__pos, "basic_string::erase");
if (__n == npos)
this->_M_set_length(__pos);
else if (__n != 0)
this->_M_erase(__pos, _M_limit(__pos, __n));
return *this;
}

iterator erase(__const_iterator __position) {

;
const size_type __pos = __position - begin();
this->_M_erase(__pos, size_type(1));
return iterator(_M_data() + __pos);
}

iterator erase(__const_iterator __first, __const_iterator __last) {

;
const size_type __pos = __first - begin();
if (__last == end())
this->_M_set_length(__pos);
else
this->_M_erase(__pos, __last - __first);
return iterator(this->_M_data() + __pos);
}

void pop_back() noexcept {
do {
if (std::__is_constant_evaluated() && !bool(!empty()))
__builtin_unreachable();
} while (false);
_M_erase(size() - 1, 1);
}

basic_string &replace(size_type __pos, size_type __n,
const basic_string &__str) {
return this->replace(__pos, __n, __str._M_data(), __str.size());
}

basic_string &replace(size_type __pos1, size_type __n1,
const basic_string &__str, size_type __pos2,
size_type __n2 = npos) {
return this->replace(__pos1, __n1,
__str._M_data() +
__str._M_check(__pos2, "basic_string::replace"),
__str._M_limit(__pos2, __n2));
}

basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s,
size_type __n2) {
;
return _M_replace(_M_check(__pos, "basic_string::replace"),
_M_limit(__pos, __n1), __s, __n2);
}

basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s) {
;
return this->replace(__pos, __n1, __s, traits_type::length(__s));
}

basic_string &replace(size_type __pos, size_type __n1, size_type __n2,
_CharT __c) {
return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
_M_limit(__pos, __n1), __n2, __c);
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
const basic_string &__str) {
return this->replace(__i1, __i2, __str._M_data(), __str.size());
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
const _CharT *__s, size_type __n) {

;
return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
const _CharT *__s) {
;
return this->replace(__i1, __i2, __s, traits_type::length(__s));
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
size_type __n, _CharT __c) {

;
return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
}
template <class _InputIterator,
typename = std::_RequireInputIter<_InputIterator>>

basic_string &replace(const_iterator __i1, const_iterator __i2,
_InputIterator __k1, _InputIterator __k2) {

;
;
return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
std::__false_type());
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
_CharT *__k1, _CharT *__k2) {

;
;
return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
const _CharT *__k1, const _CharT *__k2) {

;
;
return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
iterator __k1, iterator __k2) {

;
;
return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(),
__k2 - __k1);
}

basic_string &replace(__const_iterator __i1, __const_iterator __i2,
const_iterator __k1, const_iterator __k2) {

;
;
return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(),
__k2 - __k1);
}

basic_string &replace(const_iterator __i1, const_iterator __i2,
initializer_list<_CharT> __l) {
return this->replace(__i1, __i2, __l.begin(), __l.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> replace(size_type __pos, size_type __n,
const _Tp &__svt) {
__sv_type __sv = __svt;
return this->replace(__pos, __n, __sv.data(), __sv.size());
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> replace(size_type __pos1, size_type __n1,
const _Tp &__svt, size_type __pos2,
size_type __n2 = npos) {
__sv_type __sv = __svt;
return this->replace(
__pos1, __n1,
__sv.data() +
std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
std::__sv_limit(__sv.size(), __pos2, __n2));
}
template <typename _Tp>

_If_sv<_Tp, basic_string &> replace(const_iterator __i1,
const_iterator __i2, const _Tp &__svt) {
__sv_type __sv = __svt;
return this->replace(__i1 - begin(), __i2 - __i1, __sv);
}

private:
template <class _Integer>

basic_string &_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
_Integer __n, _Integer __val,
__true_type) {
return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
}

template <class _InputIterator>

basic_string &_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
_InputIterator __k1, _InputIterator __k2,
__false_type);

basic_string &_M_replace_aux(size_type __pos1, size_type __n1,
size_type __n2, _CharT __c);

basic_string &_M_replace(size_type __pos, size_type __len1,
const _CharT *__s, const size_type __len2);

basic_string &_M_append(const _CharT *__s, size_type __n);

public:
size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const;

void swap(basic_string &__s) noexcept;

const _CharT *c_str() const noexcept { return _M_data(); }

const _CharT *data() const noexcept { return _M_data(); }

_CharT *data() noexcept { return _M_data(); }

allocator_type get_allocator() const noexcept { return _M_get_allocator(); }

size_type find(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type find(const basic_string &__str,
size_type __pos = 0) const noexcept {
return this->find(__str.data(), __pos, __str.size());
}
template <typename _Tp>

_If_sv<_Tp, size_type> find(const _Tp &__svt, size_type __pos = 0) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->find(__sv.data(), __pos, __sv.size());
}

size_type find(const _CharT *__s, size_type __pos = 0) const noexcept {
;
return this->find(__s, __pos, traits_type::length(__s));
}

size_type find(_CharT __c, size_type __pos = 0) const noexcept;

size_type rfind(const basic_string &__str,
size_type __pos = npos) const noexcept {
return this->rfind(__str.data(), __pos, __str.size());
}
template <typename _Tp>

_If_sv<_Tp, size_type> rfind(const _Tp &__svt, size_type __pos = npos) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->rfind(__sv.data(), __pos, __sv.size());
}

size_type rfind(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type rfind(const _CharT *__s, size_type __pos = npos) const {
;
return this->rfind(__s, __pos, traits_type::length(__s));
}

size_type rfind(_CharT __c, size_type __pos = npos) const noexcept;

size_type find_first_of(const basic_string &__str,
size_type __pos = 0) const noexcept {
return this->find_first_of(__str.data(), __pos, __str.size());
}
template <typename _Tp>

_If_sv<_Tp, size_type> find_first_of(const _Tp &__svt,
size_type __pos = 0) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->find_first_of(__sv.data(), __pos, __sv.size());
}

size_type find_first_of(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type find_first_of(const _CharT *__s,
size_type __pos = 0) const noexcept {
;
return this->find_first_of(__s, __pos, traits_type::length(__s));
}

size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept {
return this->find(__c, __pos);
}

size_type find_last_of(const basic_string &__str,
size_type __pos = npos) const noexcept {
return this->find_last_of(__str.data(), __pos, __str.size());
}
template <typename _Tp>

_If_sv<_Tp, size_type> find_last_of(const _Tp &__svt,
size_type __pos = npos) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->find_last_of(__sv.data(), __pos, __sv.size());
}

size_type find_last_of(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type find_last_of(const _CharT *__s,
size_type __pos = npos) const noexcept {
;
return this->find_last_of(__s, __pos, traits_type::length(__s));
}

size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept {
return this->rfind(__c, __pos);
}

size_type find_first_not_of(const basic_string &__str,
size_type __pos = 0) const noexcept {
return this->find_first_not_of(__str.data(), __pos, __str.size());
}
template <typename _Tp>
_If_sv<_Tp, size_type>

find_first_not_of(const _Tp &__svt, size_type __pos = 0) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->find_first_not_of(__sv.data(), __pos, __sv.size());
}

size_type find_first_not_of(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type find_first_not_of(const _CharT *__s,
size_type __pos = 0) const noexcept {
;
return this->find_first_not_of(__s, __pos, traits_type::length(__s));
}

size_type find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;

size_type find_last_not_of(const basic_string &__str,
size_type __pos = npos) const noexcept {
return this->find_last_not_of(__str.data(), __pos, __str.size());
}
template <typename _Tp>

_If_sv<_Tp, size_type> find_last_not_of(const _Tp &__svt,
size_type __pos = npos) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return this->find_last_not_of(__sv.data(), __pos, __sv.size());
}

size_type find_last_not_of(const _CharT *__s, size_type __pos,
size_type __n) const noexcept;

size_type find_last_not_of(const _CharT *__s,
size_type __pos = npos) const noexcept {
;
return this->find_last_not_of(__s, __pos, traits_type::length(__s));
}

size_type find_last_not_of(_CharT __c,
size_type __pos = npos) const noexcept;

basic_string substr(size_type __pos = 0, size_type __n = npos) const {
return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n);
}

int compare(const basic_string &__str) const {
const size_type __size = this->size();
const size_type __osize = __str.size();
const size_type __len = std::min(__size, __osize);

int __r = traits_type::compare(_M_data(), __str.data(), __len);
if (!__r)
__r = _S_compare(__size, __osize);
return __r;
}

template <typename _Tp>

_If_sv<_Tp, int> compare(const _Tp &__svt) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
const size_type __size = this->size();
const size_type __osize = __sv.size();
const size_type __len = std::min(__size, __osize);

int __r = traits_type::compare(_M_data(), __sv.data(), __len);
if (!__r)
__r = _S_compare(__size, __osize);
return __r;
}
template <typename _Tp>

_If_sv<_Tp, int> compare(size_type __pos, size_type __n,
const _Tp &__svt) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return __sv_type(*this).substr(__pos, __n).compare(__sv);
}
template <typename _Tp>

_If_sv<_Tp, int> compare(size_type __pos1, size_type __n1, const _Tp &__svt,
size_type __pos2, size_type __n2 = npos) const
noexcept(is_same<_Tp, __sv_type>::value) {
__sv_type __sv = __svt;
return __sv_type(*this)
.substr(__pos1, __n1)
.compare(__sv.substr(__pos2, __n2));
}

int compare(size_type __pos, size_type __n,
const basic_string &__str) const;

int compare(size_type __pos1, size_type __n1, const basic_string &__str,
size_type __pos2, size_type __n2 = npos) const;

int compare(const _CharT *__s) const noexcept;

int compare(size_type __pos, size_type __n1, const _CharT *__s) const;

int compare(size_type __pos, size_type __n1, const _CharT *__s,
size_type __n2) const;
template <typename, typename, typename> friend class basic_stringbuf;
};
} // namespace __cxx11

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __cxx11 {
template <
typename _InputIterator,
typename _CharT = typename iterator_traits<_InputIterator>::value_type,
typename _Allocator = allocator<_CharT>,
typename = _RequireInputIter<_InputIterator>,
typename = _RequireAllocator<_Allocator>>
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
-> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template <typename _CharT, typename _Traits,
typename _Allocator = allocator<_CharT>,
typename = _RequireAllocator<_Allocator>>
basic_string(basic_string_view<_CharT, _Traits>,
const _Allocator & = _Allocator())
-> basic_string<_CharT, _Traits, _Allocator>;

template <typename _CharT, typename _Traits,
typename _Allocator = allocator<_CharT>,
typename = _RequireAllocator<_Allocator>>
basic_string(basic_string_view<_CharT, _Traits>,
typename basic_string<_CharT, _Traits, _Allocator>::size_type,
typename basic_string<_CharT, _Traits, _Allocator>::size_type,
const _Allocator & = _Allocator())
-> basic_string<_CharT, _Traits, _Allocator>;
} // namespace __cxx11
template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> operator+(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
__str.append(__rhs);
return __str;
}

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> operator+(
const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> operator+(
_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
__str.append(__rhs);
return __str;
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs) {
typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
typedef typename __string_type::size_type __size_type;
__string_type __str(__lhs);
__str.append(__size_type(1), __rhs);
return __str;
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
basic_string<_CharT, _Traits, _Alloc> &&__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return std::move(__lhs.append(__rhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
return std::move(__rhs.insert(0, __lhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
basic_string<_CharT, _Traits, _Alloc> &&__lhs,
basic_string<_CharT, _Traits, _Alloc> &&__rhs) {

using _Alloc_traits = allocator_traits<_Alloc>;
bool __use_rhs = false;
if constexpr (typename _Alloc_traits::is_always_equal{})
__use_rhs = true;
else if (__lhs.get_allocator() == __rhs.get_allocator())
__use_rhs = true;
if (__use_rhs)

{
const auto __size = __lhs.size() + __rhs.size();
if (__size > __lhs.capacity() && __size <= __rhs.capacity())
return std::move(__rhs.insert(0, __lhs));
}
return std::move(__lhs.append(__rhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
return std::move(__rhs.insert(0, __lhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
return std::move(__rhs.insert(0, 1, __lhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs) {
return std::move(__lhs.append(__rhs));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline basic_string<_CharT, _Traits, _Alloc> operator+(
basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs) {
return std::move(__lhs.append(1, __rhs));
}
template <typename _CharT, typename _Traits, typename _Alloc>

inline bool operator==(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return __lhs.compare(__rhs) == 0;
}

template <typename _CharT>

inline
typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
operator==(const basic_string<_CharT> &__lhs,
const basic_string<_CharT> &__rhs) noexcept {
return (__lhs.size() == __rhs.size() &&
!std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
__lhs.size()));
}

template <typename _CharT, typename _Traits, typename _Alloc>

inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return __lhs.compare(__rhs) == 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator==(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return __rhs.compare(__lhs) == 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator!=(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return !(__lhs == __rhs);
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator!=(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return !(__lhs == __rhs);
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return !(__lhs == __rhs);
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return __lhs.compare(__rhs) < 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return __lhs.compare(__rhs) < 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return __rhs.compare(__lhs) > 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return __lhs.compare(__rhs) > 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return __lhs.compare(__rhs) > 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return __rhs.compare(__lhs) < 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<=(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return __lhs.compare(__rhs) <= 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return __lhs.compare(__rhs) <= 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator<=(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return __rhs.compare(__lhs) >= 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>=(
const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
return __lhs.compare(__rhs) >= 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
const _CharT *__rhs) {
return __lhs.compare(__rhs) >= 0;
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline bool operator>=(const _CharT *__lhs,
const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
return __rhs.compare(__lhs) <= 0;
}
template <typename _CharT, typename _Traits, typename _Alloc>

inline void swap(basic_string<_CharT, _Traits, _Alloc> & __lhs,
basic_string<_CharT, _Traits, _Alloc> &
__rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
__lhs.swap(__rhs);
}
template <typename _CharT, typename _Traits, typename _Alloc>
basic_istream<_CharT, _Traits> &operator>>(
basic_istream<_CharT, _Traits> &__is,
basic_string<_CharT, _Traits, _Alloc> &__str);

template <>
basic_istream<char> &operator>>(basic_istream<char> &__is,
basic_string<char> &__str);
template <typename _CharT, typename _Traits, typename _Alloc>
inline basic_ostream<_CharT, _Traits> &operator<<(
basic_ostream<_CharT, _Traits> &__os,
const basic_string<_CharT, _Traits, _Alloc> &__str) {

return __ostream_insert(__os, __str.data(), __str.size());
}
template <typename _CharT, typename _Traits, typename _Alloc>
basic_istream<_CharT, _Traits> &getline(
basic_istream<_CharT, _Traits> & __is,
basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim);
template <typename _CharT, typename _Traits, typename _Alloc>
inline basic_istream<_CharT, _Traits> &getline(
basic_istream<_CharT, _Traits> & __is,
basic_string<_CharT, _Traits, _Alloc> & __str) {
return std::getline(__is, __str, __is.widen('\n'));
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline basic_istream<_CharT, _Traits> &getline(
basic_istream<_CharT, _Traits> && __is,
basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim) {
return std::getline(__is, __str, __delim);
}

template <typename _CharT, typename _Traits, typename _Alloc>
inline basic_istream<_CharT, _Traits> &getline(
basic_istream<_CharT, _Traits> && __is,
basic_string<_CharT, _Traits, _Alloc> & __str) {
return std::getline(__is, __str);
}

template <>
basic_istream<char> &getline(basic_istream<char> & __in,
basic_string<char> & __str, char __delim);

template <>
basic_istream<wchar_t> &getline(basic_istream<wchar_t> & __in,
basic_string<wchar_t> & __str,
wchar_t __delim);

} // namespace std

extern "C" {

typedef struct _G_fpos_t {
__off_t __pos;
__mbstate_t __state;
} __fpos_t;
typedef struct _G_fpos64_t {
__off64_t __pos;
__mbstate_t __state;
} __fpos64_t;

struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;

typedef void _IO_lock_t;

struct _IO_FILE {
int _flags;

char *_IO_read_ptr;
char *_IO_read_end;
char *_IO_read_base;
char *_IO_write_base;
char *_IO_write_ptr;
char *_IO_write_end;
char *_IO_buf_base;
char *_IO_buf_end;

char *_IO_save_base;
char *_IO_backup_base;
char *_IO_save_end;

struct _IO_marker *_markers;

struct _IO_FILE *_chain;

int _fileno;
int _flags2;
__off_t _old_offset;

unsigned short _cur_column;
signed char _vtable_offset;
char _shortbuf[1];

_IO_lock_t *_lock;

__off64_t _offset;

struct _IO_codecvt *_codecvt;
struct _IO_wide_data *_wide_data;
struct _IO_FILE *_freeres_list;
void *_freeres_buf;
size_t __pad5;
int _mode;

char _unused2[15 * sizeof(int) - 4 * sizeof(void *) - sizeof(size_t)];
};

typedef __ssize_t cookie_read_function_t(void *__cookie, char *__buf,
size_t __nbytes);

typedef __ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
size_t __nbytes);

typedef int cookie_seek_function_t(void *__cookie, __off64_t *__pos, int __w);

typedef int cookie_close_function_t(void *__cookie);

typedef struct _IO_cookie_io_functions_t {
cookie_read_function_t *read;
cookie_write_function_t *write;
cookie_seek_function_t *seek;
cookie_close_function_t *close;
} cookie_io_functions_t;

typedef __gnuc_va_list va_list;
typedef __fpos_t fpos_t;

typedef __fpos64_t fpos64_t;
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

extern int remove(const char *__filename) noexcept(true);

extern int rename(const char *__old, const char *__new) noexcept(true);

extern int renameat(int __oldfd, const char *__old, int __newfd,
const char *__new) noexcept(true);
extern int renameat2(int __oldfd, const char *__old, int __newfd,
const char *__new, unsigned int __flags) noexcept(true);

extern int fclose(FILE *__stream);
extern FILE *tmpfile(void) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));
extern FILE *tmpfile64(void) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));

extern char *tmpnam(char[20]) noexcept(true);

extern char *tmpnam_r(char __s[20]) noexcept(true);
extern char *tempnam(const char *__dir, const char *__pfx) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(__builtin_free, 1)));

extern int fflush(FILE *__stream);
extern int fflush_unlocked(FILE *__stream);
extern int fcloseall(void);
extern FILE *fopen(const char *__restrict __filename,
const char *__restrict __modes) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));

extern FILE *freopen(const char *__restrict __filename,
const char *__restrict __modes, FILE *__restrict __stream);
extern FILE *fopen64(const char *__restrict __filename,
const char *__restrict __modes) __attribute__((__malloc__))
__attribute__((__malloc__(fclose, 1)));
extern FILE *freopen64(const char *__restrict __filename,
const char *__restrict __modes,
FILE *__restrict __stream);

extern FILE *fdopen(int __fd, const char *__modes) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(fclose, 1)));

extern FILE *fopencookie(void *__restrict __magic_cookie,
const char *__restrict __modes,
cookie_io_functions_t __io_funcs) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(fclose, 1)));

extern FILE *fmemopen(void *__s, size_t __len,
const char *__modes) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(fclose, 1)));

extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(fclose, 1)));

extern __FILE *open_wmemstream(wchar_t **__bufloc,
size_t *__sizeloc) noexcept(true)
__attribute__((__malloc__)) __attribute__((__malloc__(fclose, 1)));

extern void setbuf(FILE *__restrict __stream,
char *__restrict __buf) noexcept(true);

extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf,
int __modes, size_t __n) noexcept(true);

extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf,
size_t __size) noexcept(true);

extern void setlinebuf(FILE *__stream) noexcept(true);

extern int fprintf(FILE *__restrict __stream, const char *__restrict __format,
...);

extern int printf(const char *__restrict __format, ...);

extern int sprintf(char *__restrict __s, const char *__restrict __format,
...) noexcept(true);

extern int vfprintf(FILE *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg);

extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf(char *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg) noexcept(true);

extern int snprintf(char *__restrict __s, size_t __maxlen,
const char *__restrict __format, ...) noexcept(true)
__attribute__((__format__(__printf__, 3, 4)));

extern int vsnprintf(char *__restrict __s, size_t __maxlen,
const char *__restrict __format,
__gnuc_va_list __arg) noexcept(true)
__attribute__((__format__(__printf__, 3, 0)));

extern int vasprintf(char **__restrict __ptr, const char *__restrict __f,
__gnuc_va_list __arg) noexcept(true)
__attribute__((__format__(__printf__, 2, 0)));
extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt,
...) noexcept(true)
__attribute__((__format__(__printf__, 2, 3)));
extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt,
...) noexcept(true)
__attribute__((__format__(__printf__, 2, 3)));

extern int vdprintf(int __fd, const char *__restrict __fmt,
__gnuc_va_list __arg)
__attribute__((__format__(__printf__, 2, 0)));
extern int dprintf(int __fd, const char *__restrict __fmt, ...)
__attribute__((__format__(__printf__, 2, 3)));

extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
...);

extern int scanf(const char *__restrict __format, ...);

extern int sscanf(const char *__restrict __s, const char *__restrict __format,
...) noexcept(true);
extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
...) __asm__(""
"__isoc99_fscanf")

;
extern int scanf(const char *__restrict __format,
...) __asm__(""
"__isoc99_scanf");
extern int sscanf(const char *__restrict __s, const char *__restrict __format,
...) noexcept(true) __asm__(""
"__isoc99_sscanf")

;
extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg)
__attribute__((__format__(__scanf__, 2, 0)));

extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg)
__attribute__((__format__(__scanf__, 1, 0)));

extern int vsscanf(const char *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg) noexcept(true)
__attribute__((__format__(__scanf__, 2, 0)));

extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg) __asm__(""
"__isoc99_vfscanf")

__attribute__((__format__(__scanf__, 2, 0)));
extern int vscanf(const char *__restrict __format,
__gnuc_va_list __arg) __asm__(""
"__isoc99_vscanf")

__attribute__((__format__(__scanf__, 1, 0)));
extern int
vsscanf(const char *__restrict __s, const char *__restrict __format,
__gnuc_va_list __arg) noexcept(true) __asm__(""
"__isoc99_vsscanf")

__attribute__((__format__(__scanf__, 2, 0)));
extern int fgetc(FILE *__stream);
extern int getc(FILE *__stream);

extern int getchar(void);

extern int getc_unlocked(FILE *__stream);
extern int getchar_unlocked(void);
extern int fgetc_unlocked(FILE *__stream);
extern int fputc(int __c, FILE *__stream);
extern int putc(int __c, FILE *__stream);

extern int putchar(int __c);
extern int fputc_unlocked(int __c, FILE *__stream);

extern int putc_unlocked(int __c, FILE *__stream);
extern int putchar_unlocked(int __c);

extern int getw(FILE *__stream);

extern int putw(int __w, FILE *__stream);

extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream)
__attribute__((__access__(__write_only__, 1, 2)));
extern char *fgets_unlocked(char *__restrict __s, int __n,
FILE *__restrict __stream)
__attribute__((__access__(__write_only__, 1, 2)));
extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n,
int __delimiter, FILE *__restrict __stream);
extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n,
int __delimiter, FILE *__restrict __stream);

extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
FILE *__restrict __stream);

extern int fputs(const char *__restrict __s, FILE *__restrict __stream);

extern int puts(const char *__s);

extern int ungetc(int __c, FILE *__stream);

extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n,
FILE *__restrict __stream);

extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n,
FILE *__restrict __s);
extern int fputs_unlocked(const char *__restrict __s,
FILE *__restrict __stream);
extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n,
FILE *__restrict __stream);
extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size,
size_t __n, FILE *__restrict __stream);

extern int fseek(FILE *__stream, long int __off, int __whence);

extern long int ftell(FILE *__stream);

extern void rewind(FILE *__stream);
extern int fseeko(FILE *__stream, __off_t __off, int __whence);

extern __off_t ftello(FILE *__stream);
extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);

extern int fsetpos(FILE *__stream, const fpos_t *__pos);
extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64(FILE *__stream);
extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);

extern void clearerr(FILE *__stream) noexcept(true);

extern int feof(FILE *__stream) noexcept(true);

extern int ferror(FILE *__stream) noexcept(true);

extern void clearerr_unlocked(FILE *__stream) noexcept(true);
extern int feof_unlocked(FILE *__stream) noexcept(true);
extern int ferror_unlocked(FILE *__stream) noexcept(true);

extern void perror(const char *__s);

extern int fileno(FILE *__stream) noexcept(true);

extern int fileno_unlocked(FILE *__stream) noexcept(true);
extern int pclose(FILE *__stream);

extern FILE *popen(const char *__command, const char *__modes)
__attribute__((__malloc__)) __attribute__((__malloc__(pclose, 1)));

extern char *ctermid(char *__s) noexcept(true)
__attribute__((__access__(__write_only__, 1)));

extern char *cuserid(char *__s) __attribute__((__access__(__write_only__, 1)));

struct obstack;

extern int obstack_printf(struct obstack *__restrict __obstack,
const char *__restrict __format, ...) noexcept(true)
__attribute__((__format__(__printf__, 2, 3)));
extern int obstack_vprintf(struct obstack *__restrict __obstack,
const char *__restrict __format,
__gnuc_va_list __args) noexcept(true)
__attribute__((__format__(__printf__, 2, 0)));

extern void flockfile(FILE *__stream) noexcept(true);

extern int ftrylockfile(FILE *__stream) noexcept(true);

extern void funlockfile(FILE *__stream) noexcept(true);
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);
}
namespace std {
using ::FILE;
using ::fpos_t;

using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;

using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;

using ::tmpnam;

using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;
} // namespace std
namespace __gnu_cxx {
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;

} // namespace __gnu_cxx

namespace std {
using ::__gnu_cxx::snprintf;
using ::__gnu_cxx::vfscanf;
using ::__gnu_cxx::vscanf;
using ::__gnu_cxx::vsnprintf;
using ::__gnu_cxx::vsscanf;
} // namespace std

extern "C" {

extern int *__errno_location(void) noexcept(true) __attribute__((__const__));

extern char *program_invocation_name;
extern char *program_invocation_short_name;

typedef int error_t;
}

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

template <typename _TRet, typename _Ret = _TRet, typename _CharT,
typename... _Base>
_Ret __stoa(_TRet(*__convf)(const _CharT *, _CharT **, _Base...),
const char *__name, const _CharT *__str, std::size_t *__idx,
_Base... __base) {
_Ret __ret;

_CharT *__endptr;

struct _Save_errno {
_Save_errno() : _M_errno((*__errno_location())) {
(*__errno_location()) = 0;
}
~_Save_errno() {
if ((*__errno_location()) == 0)
(*__errno_location()) = _M_errno;
}
int _M_errno;
} const __save_errno;

struct _Range_chk {
static bool _S_chk(_TRet, std::false_type) { return false; }

static bool _S_chk(_TRet __val, std::true_type) {
return __val < _TRet(__numeric_traits<int>::__min) ||
__val > _TRet(__numeric_traits<int>::__max);
}
};

const _TRet __tmp = __convf(__str, &__endptr, __base...);

if (__endptr == __str)
std::__throw_invalid_argument(__name);
else if ((*__errno_location()) == 34 ||
_Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
std::__throw_out_of_range(__name);
else
__ret = __tmp;

if (__idx)
*__idx = __endptr - __str;

return __ret;
}

template <typename _String, typename _CharT = typename _String::value_type>
_String __to_xstring(
int (*__convf)(_CharT *, std::size_t, const _CharT *, __builtin_va_list),
std::size_t __n, const _CharT *__fmt, ...) {

_CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));

__builtin_va_list __args;
__builtin_va_start(__args, __fmt);

const int __len = __convf(__s, __n, __fmt, __args);

__builtin_va_end(__args);

return _String(__s, __s + __len);
}

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

namespace __detail {

template <typename _Tp>
constexpr unsigned __to_chars_len(_Tp __value, int __base = 10) noexcept {
static_assert(is_integral<_Tp>::value, "implementation bug");
static_assert(is_unsigned<_Tp>::value, "implementation bug");

unsigned __n = 1;
const unsigned __b2 = __base * __base;
const unsigned __b3 = __b2 * __base;
const unsigned long __b4 = __b3 * __base;
for (;;) {
if (__value < (unsigned)__base)
return __n;
if (__value < __b2)
return __n + 1;
if (__value < __b3)
return __n + 2;
if (__value < __b4)
return __n + 3;
__value /= __b4;
__n += 4;
}
}

template <typename _Tp>
void __to_chars_10_impl(char *__first, unsigned __len, _Tp __val) noexcept {
static_assert(is_integral<_Tp>::value, "implementation bug");
static_assert(is_unsigned<_Tp>::value, "implementation bug");

static constexpr char __digits[201] =
"0001020304050607080910111213141516171819"
"2021222324252627282930313233343536373839"
"4041424344454647484950515253545556575859"
"6061626364656667686970717273747576777879"
"8081828384858687888990919293949596979899";
unsigned __pos = __len - 1;
while (__val >= 100) {
auto const __num = (__val % 100) * 2;
__val /= 100;
__first[__pos] = __digits[__num + 1];
__first[__pos - 1] = __digits[__num];
__pos -= 2;
}
if (__val >= 10) {
auto const __num = __val * 2;
__first[1] = __digits[__num + 1];
__first[0] = __digits[__num];
} else
__first[0] = '0' + __val;
}

} // namespace __detail

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __cxx11 {

inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) {
return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
__idx, __base);
}

inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) {
return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx,
__base);
}

inline unsigned long stoul(const string &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx,
__base);
}

inline long long stoll(const string &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx,
__base);
}

inline unsigned long long stoull(const string &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx,
__base);
}

inline float stof(const string &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
}

inline double stod(const string &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
}

inline long double stold(const string &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
}

inline string to_string(int __val)

noexcept

{
const bool __neg = __val < 0;
const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
const auto __len = __detail::__to_chars_len(__uval);
string __str(__neg + __len, '-');
__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
return __str;
}

inline string to_string(unsigned __val)

noexcept

{
string __str(__detail::__to_chars_len(__val), '\0');
__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
return __str;
}

inline string to_string(long __val)

{
const bool __neg = __val < 0;
const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
const auto __len = __detail::__to_chars_len(__uval);
string __str(__neg + __len, '-');
__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
return __str;
}

inline string to_string(unsigned long __val)

{
string __str(__detail::__to_chars_len(__val), '\0');
__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
return __str;
}

inline string to_string(long long __val) {
const bool __neg = __val < 0;
const unsigned long long __uval =
__neg ? (unsigned long long)~__val + 1ull : __val;
const auto __len = __detail::__to_chars_len(__uval);
string __str(__neg + __len, '-');
__detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
return __str;
}

inline string to_string(unsigned long long __val) {
string __str(__detail::__to_chars_len(__val), '\0');
__detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
return __str;
}

inline string to_string(float __val) {
const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
}

inline string to_string(double __val) {
const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
}

inline string to_string(long double __val) {
const int __n =
__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%Lf", __val);
}

inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) {
return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
__idx, __base);
}

inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) {
return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx,
__base);
}

inline unsigned long stoul(const wstring &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx,
__base);
}

inline long long stoll(const wstring &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx,
__base);
}

inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0,
int __base = 10) {
return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx,
__base);
}

inline float stof(const wstring &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
}

inline double stod(const wstring &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
}

inline long double stold(const wstring &__str, size_t *__idx = 0) {
return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
}

inline wstring to_wstring(int __val) {
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
L"%d", __val);
}

inline wstring to_wstring(unsigned __val) {
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
4 * sizeof(unsigned), L"%u", __val);
}

inline wstring to_wstring(long __val) {
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
L"%ld", __val);
}

inline wstring to_wstring(unsigned long __val) {
return __gnu_cxx::__to_xstring<wstring>(
&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
}

inline wstring to_wstring(long long __val) {
return __gnu_cxx::__to_xstring<wstring>(
&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
}

inline wstring to_wstring(unsigned long long __val) {
return __gnu_cxx::__to_xstring<wstring>(
&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
}

inline wstring to_wstring(float __val) {
const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
}

inline wstring to_wstring(double __val) {
const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
}

inline wstring to_wstring(long double __val) {
const int __n =
__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%Lf",
__val);
}

} // namespace __cxx11

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <> struct hash<string> : public __hash_base<size_t, string> {
size_t operator()(const string &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length());
}
};

template <> struct __is_fast_hash<hash<string>> : std::false_type {};

template <> struct hash<wstring> : public __hash_base<size_t, wstring> {
size_t operator()(const wstring &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
}
};

template <> struct __is_fast_hash<hash<wstring>> : std::false_type {};
template <> struct hash<u16string> : public __hash_base<size_t, u16string> {
size_t operator()(const u16string &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
}
};

template <> struct __is_fast_hash<hash<u16string>> : std::false_type {};

template <> struct hash<u32string> : public __hash_base<size_t, u32string> {
size_t operator()(const u32string &__s) const noexcept {
return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
}
};

template <> struct __is_fast_hash<hash<u32string>> : std::false_type {};

inline namespace literals {
inline namespace string_literals {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"

__attribute((__abi_tag__("cxx11"))) inline basic_string<char>
operator""s(const char *__str, size_t __len) {
return basic_string<char>{__str, __len};
}

__attribute((__abi_tag__("cxx11"))) inline basic_string<wchar_t>
operator""s(const wchar_t *__str, size_t __len) {
return basic_string<wchar_t>{__str, __len};
}
__attribute((__abi_tag__("cxx11"))) inline basic_string<char16_t>
operator""s(const char16_t *__str, size_t __len) {
return basic_string<char16_t>{__str, __len};
}

__attribute((__abi_tag__("cxx11"))) inline basic_string<char32_t>
operator""s(const char32_t *__str, size_t __len) {
return basic_string<char32_t>{__str, __len};
}

#pragma GCC diagnostic pop
} // namespace string_literals
} // namespace literals

namespace __detail::__variant {
template <typename> struct _Never_valueless_alt;

template <typename _Tp, typename _Traits, typename _Alloc>
struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
: __and_<is_nothrow_move_constructible<
std::basic_string<_Tp, _Traits, _Alloc>>,
is_nothrow_move_assignable<
std::basic_string<_Tp, _Traits, _Alloc>>>::type {};
} // namespace __detail::__variant

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <typename _CharT, typename _Traits, typename _Alloc>
const typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::npos;

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string &
__s) noexcept {
if (this == std::__addressof(__s))
return;

_Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

if (_M_is_local())
if (__s._M_is_local()) {
if (length() && __s.length()) {
_CharT __tmp_data[_S_local_capacity + 1];
traits_type::copy(__tmp_data, __s._M_local_buf, __s.length() + 1);
traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
traits_type::copy(_M_local_buf, __tmp_data, __s.length() + 1);
} else if (__s.length()) {
traits_type::copy(_M_local_buf, __s._M_local_buf, __s.length() + 1);
_M_length(__s.length());
__s._M_set_length(0);
return;
} else if (length()) {
traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
__s._M_length(length());
_M_set_length(0);
return;
}
} else {
const size_type __tmp_capacity = __s._M_allocated_capacity;
traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
_M_data(__s._M_data());
__s._M_data(__s._M_local_buf);
_M_capacity(__tmp_capacity);
}
else {
const size_type __tmp_capacity = _M_allocated_capacity;
if (__s._M_is_local()) {
traits_type::copy(_M_local_buf, __s._M_local_buf, __s.length() + 1);
__s._M_data(_M_data());
_M_data(_M_local_buf);
} else {
pointer __tmp_ptr = _M_data();
_M_data(__s._M_data());
__s._M_data(__tmp_ptr);
_M_capacity(__s._M_allocated_capacity);
}
__s._M_capacity(__tmp_capacity);
}

const size_type __tmp_length = length();
_M_length(__s.length());
__s._M_length(__tmp_length);
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::pointer
basic_string<_CharT, _Traits, _Alloc>::_M_create(size_type & __capacity,
size_type __old_capacity) {

if (__capacity > max_size())
std::__throw_length_error(("basic_string::_M_create"));

if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
__capacity = 2 * __old_capacity;

if (__capacity > max_size())
__capacity = max_size();
}

return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
}

template <typename _CharT, typename _Traits, typename _Alloc>
template <typename _InIterator>

void basic_string<_CharT, _Traits, _Alloc>::_M_construct(
_InIterator __beg, _InIterator __end, std::input_iterator_tag) {
size_type __len = 0;
size_type __capacity = size_type(_S_local_capacity);

pointer __p = _M_use_local_data();

while (__beg != __end && __len < __capacity) {
__p[__len++] = *__beg;
++__beg;
}

struct _Guard {

explicit _Guard(basic_string *__s) : _M_guarded(__s) {}

~_Guard() {
if (_M_guarded)
_M_guarded->_M_dispose();
}

basic_string *_M_guarded;
} __guard(this);

while (__beg != __end) {
if (__len == __capacity) {

__capacity = __len + 1;
pointer __another = _M_create(__capacity, __len);
this->_S_copy(__another, _M_data(), __len);
_M_dispose();
_M_data(__another);
_M_capacity(__capacity);
}
traits_type::assign(_M_data()[__len++], *__beg);
++__beg;
}

__guard._M_guarded = 0;

_M_set_length(__len);
}

template <typename _CharT, typename _Traits, typename _Alloc>
template <typename _InIterator>

void basic_string<_CharT, _Traits, _Alloc>::_M_construct(
_InIterator __beg, _InIterator __end, std::forward_iterator_tag) {
size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

if (__dnew > size_type(_S_local_capacity)) {
_M_data(_M_create(__dnew, size_type(0)));
_M_capacity(__dnew);
} else
_M_use_local_data();

struct _Guard {

explicit _Guard(basic_string *__s) : _M_guarded(__s) {}

~_Guard() {
if (_M_guarded)
_M_guarded->_M_dispose();
}

basic_string *_M_guarded;
} __guard(this);

this->_S_copy_chars(_M_data(), __beg, __end);

__guard._M_guarded = 0;

_M_set_length(__dnew);
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::_M_construct(size_type __n,
_CharT __c) {
if (__n > size_type(_S_local_capacity)) {
_M_data(_M_create(__n, size_type(0)));
_M_capacity(__n);
} else
_M_use_local_data();

if (__n)
this->_S_assign(_M_data(), __n, __c);

_M_set_length(__n);
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::_M_assign(
const basic_string &__str) {
if (this != std::__addressof(__str)) {
const size_type __rsize = __str.length();
const size_type __capacity = capacity();

if (__rsize > __capacity) {
size_type __new_capacity = __rsize;
pointer __tmp = _M_create(__new_capacity, __capacity);
_M_dispose();
_M_data(__tmp);
_M_capacity(__new_capacity);
}

if (__rsize)
this->_S_copy(_M_data(), __str._M_data(), __rsize);

_M_set_length(__rsize);
}
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res) {
const size_type __capacity = capacity();

if (__res <= __capacity)
return;

pointer __tmp = _M_create(__res, __capacity);
this->_S_copy(__tmp, _M_data(), length() + 1);
_M_dispose();
_M_data(__tmp);
_M_capacity(__res);
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(
size_type __pos, size_type __len1, const _CharT *__s, size_type __len2) {
const size_type __how_much = length() - __pos - __len1;

size_type __new_capacity = length() + __len2 - __len1;
pointer __r = _M_create(__new_capacity, capacity());

if (__pos)
this->_S_copy(__r, _M_data(), __pos);
if (__s && __len2)
this->_S_copy(__r + __pos, __s, __len2);
if (__how_much)
this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1,
__how_much);

_M_dispose();
_M_data(__r);
_M_capacity(__new_capacity);
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::_M_erase(size_type __pos,
size_type __n) {
const size_type __how_much = length() - __pos - __n;

if (__how_much && __n)
this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

_M_set_length(length() - __n);
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::reserve() {
if (_M_is_local())
return;

const size_type __length = length();
const size_type __capacity = _M_allocated_capacity;

if (__length <= size_type(_S_local_capacity)) {
this->_S_copy(_M_use_local_data(), _M_data(), __length + 1);
_M_destroy(__capacity);
_M_data(_M_local_data());
}

else if (__length < __capacity)
try {
pointer __tmp =
_Alloc_traits::allocate(_M_get_allocator(), __length + 1);
this->_S_copy(__tmp, _M_data(), __length + 1);
_M_dispose();
_M_data(__tmp);
_M_capacity(__length);
} catch (const __cxxabiv1::__forced_unwind &) {
throw;
} catch (...) {
}
}

template <typename _CharT, typename _Traits, typename _Alloc>

void basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n,
_CharT __c) {
const size_type __size = this->size();
if (__size < __n)
this->append(__n - __size, __c);
else if (__n < __size)
this->_M_set_length(__n);
}

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> &
basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s,
size_type __n) {
const size_type __len = __n + this->size();

if (__len <= this->capacity()) {
if (__n)
this->_S_copy(this->_M_data() + this->size(), __s, __n);
} else
this->_M_mutate(this->size(), size_type(0), __s, __n);

this->_M_set_length(__len);
return *this;
}

template <typename _CharT, typename _Traits, typename _Alloc>
template <typename _InputIterator>

basic_string<_CharT, _Traits, _Alloc> &
basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(
const_iterator __i1, const_iterator __i2, _InputIterator __k1,
_InputIterator __k2, std::__false_type) {

const basic_string __s(__k1, __k2, this->get_allocator());
const size_type __n1 = __i2 - __i1;
return _M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
}

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> &
basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(
size_type __pos1, size_type __n1, size_type __n2, _CharT __c) {
_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

const size_type __old_size = this->size();
const size_type __new_size = __old_size + __n2 - __n1;

if (__new_size <= this->capacity()) {
pointer __p = this->_M_data() + __pos1;

const size_type __how_much = __old_size - __pos1 - __n1;
if (__how_much && __n1 != __n2)
this->_S_move(__p + __n2, __p + __n1, __how_much);
} else
this->_M_mutate(__pos1, __n1, 0, __n2);

if (__n2)
this->_S_assign(this->_M_data() + __pos1, __n2, __c);

this->_M_set_length(__new_size);
return *this;
}

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> &
basic_string<_CharT, _Traits, _Alloc>::_M_replace(
size_type __pos, size_type __len1, const _CharT *__s,
const size_type __len2) {
_M_check_length(__len1, __len2, "basic_string::_M_replace");

const size_type __old_size = this->size();
const size_type __new_size = __old_size + __len2 - __len1;

if (__new_size <= this->capacity()) {
pointer __p = this->_M_data() + __pos;

const size_type __how_much = __old_size - __pos - __len1;
if (_M_disjunct(__s)) {
if (__how_much && __len1 != __len2)
this->_S_move(__p + __len2, __p + __len1, __how_much);
if (__len2)
this->_S_copy(__p, __s, __len2);
} else {

if (__len2 && __len2 <= __len1)
this->_S_move(__p, __s, __len2);
if (__how_much && __len1 != __len2)
this->_S_move(__p + __len2, __p + __len1, __how_much);
if (__len2 > __len1) {
if (__s + __len2 <= __p + __len1)
this->_S_move(__p, __s, __len2);
else if (__s >= __p + __len1) {

const size_type __poff = (__s - __p) + (__len2 - __len1);
this->_S_copy(__p, __p + __poff, __len2);
} else {
const size_type __nleft = (__p + __len1) - __s;
this->_S_move(__p, __s, __nleft);
this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
}
}
}
} else
this->_M_mutate(__pos, __len1, __s, __len2);

this->_M_set_length(__new_size);
return *this;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::copy(_CharT * __s, size_type __n,
size_type __pos) const {
_M_check(__pos, "basic_string::copy");
__n = _M_limit(__pos, __n);
;
if (__n)
_S_copy(__s, _M_data() + __pos, __n);

return __n;
}
template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> operator+(
const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
;
typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
typedef typename __string_type::size_type __size_type;
typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<
_CharT>::other _Char_alloc_type;
typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
const __size_type __len = _Traits::length(__lhs);
__string_type __str(
_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
__str.reserve(__len + __rhs.size());
__str.append(__lhs, __len);
__str.append(__rhs);
return __str;
}

template <typename _CharT, typename _Traits, typename _Alloc>

basic_string<_CharT, _Traits, _Alloc> operator+(
_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
typedef typename __string_type::size_type __size_type;
typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<
_CharT>::other _Char_alloc_type;
typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
__string_type __str(
_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
const __size_type __len = __rhs.size();
__str.reserve(__len + 1);
__str.append(__size_type(1), __lhs);
__str.append(__rhs);
return __str;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
const size_type __size = this->size();

if (__n == 0)
return __pos <= __size ? __pos : npos;
if (__pos >= __size)
return npos;

const _CharT __elem0 = __s[0];
const _CharT *const __data = data();
const _CharT *__first = __data + __pos;
const _CharT *const __last = __data + __size;
size_type __len = __size - __pos;

while (__len >= __n) {

__first = traits_type::find(__first, __len - __n + 1, __elem0);
if (!__first)
return npos;

if (traits_type::compare(__first, __s, __n) == 0)
return __first - __data;
__len = __last - ++__first;
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, size_type __pos)
const noexcept {
size_type __ret = npos;
const size_type __size = this->size();
if (__pos < __size) {
const _CharT *__data = _M_data();
const size_type __n = __size - __pos;
const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
if (__p)
__ret = __p - __data;
}
return __ret;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::rfind(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
const size_type __size = this->size();
if (__n <= __size) {
__pos = std::min(size_type(__size - __n), __pos);
const _CharT *__data = _M_data();
do {
if (traits_type::compare(__data + __pos, __s, __n) == 0)
return __pos;
} while (__pos-- > 0);
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, size_type __pos)
const noexcept {
size_type __size = this->size();
if (__size) {
if (--__size > __pos)
__size = __pos;
for (++__size; __size-- > 0;)
if (traits_type::eq(_M_data()[__size], __c))
return __size;
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_first_of(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
for (; __n && __pos < this->size(); ++__pos) {
const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
if (__p)
return __pos;
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_last_of(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
size_type __size = this->size();
if (__size && __n) {
if (--__size > __pos)
__size = __pos;
do {
if (traits_type::find(__s, __n, _M_data()[__size]))
return __size;
} while (__size-- != 0);
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
for (; __pos < this->size(); ++__pos)
if (!traits_type::find(__s, __n, _M_data()[__pos]))
return __pos;
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
_CharT __c, size_type __pos) const noexcept {
for (; __pos < this->size(); ++__pos)
if (!traits_type::eq(_M_data()[__pos], __c))
return __pos;
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
const _CharT *__s, size_type __pos, size_type __n) const noexcept {
;
size_type __size = this->size();
if (__size) {
if (--__size > __pos)
__size = __pos;
do {
if (!traits_type::find(__s, __n, _M_data()[__size]))
return __size;
} while (__size--);
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

typename basic_string<_CharT, _Traits, _Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
_CharT __c, size_type __pos) const noexcept {
size_type __size = this->size();
if (__size) {
if (--__size > __pos)
__size = __pos;
do {
if (!traits_type::eq(_M_data()[__size], __c))
return __size;
} while (__size--);
}
return npos;
}

template <typename _CharT, typename _Traits, typename _Alloc>

int basic_string<_CharT, _Traits, _Alloc>::compare(
size_type __pos, size_type __n, const basic_string &__str) const {
_M_check(__pos, "basic_string::compare");
__n = _M_limit(__pos, __n);
const size_type __osize = __str.size();
const size_type __len = std::min(__n, __osize);
int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
if (!__r)
__r = _S_compare(__n, __osize);
return __r;
}

template <typename _CharT, typename _Traits, typename _Alloc>

int basic_string<_CharT, _Traits, _Alloc>::compare(
size_type __pos1, size_type __n1, const basic_string &__str,
size_type __pos2, size_type __n2) const {
_M_check(__pos1, "basic_string::compare");
__str._M_check(__pos2, "basic_string::compare");
__n1 = _M_limit(__pos1, __n1);
__n2 = __str._M_limit(__pos2, __n2);
const size_type __len = std::min(__n1, __n2);
int __r =
traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
if (!__r)
__r = _S_compare(__n1, __n2);
return __r;
}

template <typename _CharT, typename _Traits, typename _Alloc>

int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s)
const noexcept {
;
const size_type __size = this->size();
const size_type __osize = traits_type::length(__s);
const size_type __len = std::min(__size, __osize);
int __r = traits_type::compare(_M_data(), __s, __len);
if (!__r)
__r = _S_compare(__size, __osize);
return __r;
}

template <typename _CharT, typename _Traits, typename _Alloc>

int basic_string<_CharT, _Traits, _Alloc>::compare(
size_type __pos, size_type __n1, const _CharT *__s) const {
;
_M_check(__pos, "basic_string::compare");
__n1 = _M_limit(__pos, __n1);
const size_type __osize = traits_type::length(__s);
const size_type __len = std::min(__n1, __osize);
int __r = traits_type::compare(_M_data() + __pos, __s, __len);
if (!__r)
__r = _S_compare(__n1, __osize);
return __r;
}

template <typename _CharT, typename _Traits, typename _Alloc>

int basic_string<_CharT, _Traits, _Alloc>::compare(
size_type __pos, size_type __n1, const _CharT *__s, size_type __n2)
const {
;
_M_check(__pos, "basic_string::compare");
__n1 = _M_limit(__pos, __n1);
const size_type __len = std::min(__n1, __n2);
int __r = traits_type::compare(_M_data() + __pos, __s, __len);
if (!__r)
__r = _S_compare(__n1, __n2);
return __r;
}

template <typename _CharT, typename _Traits, typename _Alloc>
basic_istream<_CharT, _Traits> &operator>>(
basic_istream<_CharT, _Traits> &__in,
basic_string<_CharT, _Traits, _Alloc> &__str) {
typedef basic_istream<_CharT, _Traits> __istream_type;
typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
typedef typename __istream_type::ios_base __ios_base;
typedef typename __istream_type::int_type __int_type;
typedef typename __string_type::size_type __size_type;
typedef ctype<_CharT> __ctype_type;
typedef typename __ctype_type::ctype_base __ctype_base;

__size_type __extracted = 0;
typename __ios_base::iostate __err = __ios_base::goodbit;
typename __istream_type::sentry __cerb(__in, false);
if (__cerb) {
try {

__str.erase();
_CharT __buf[128];
__size_type __len = 0;
const streamsize __w = __in.width();
const __size_type __n =
__w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
const __int_type __eof = _Traits::eof();
__int_type __c = __in.rdbuf()->sgetc();

while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) &&
!__ct.is(__ctype_base::space, _Traits::to_char_type(__c))) {
if (__len == sizeof(__buf) / sizeof(_CharT)) {
__str.append(__buf, sizeof(__buf) / sizeof(_CharT));
__len = 0;
}
__buf[__len++] = _Traits::to_char_type(__c);
++__extracted;
__c = __in.rdbuf()->snextc();
}
__str.append(__buf, __len);

if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
__err |= __ios_base::eofbit;
__in.width(0);
} catch (__cxxabiv1::__forced_unwind &) {
__in._M_setstate(__ios_base::badbit);
throw;
} catch (...) {

__in._M_setstate(__ios_base::badbit);
}
}

if (!__extracted)
__err |= __ios_base::failbit;
if (__err)
__in.setstate(__err);
return __in;
}

template <typename _CharT, typename _Traits, typename _Alloc>
basic_istream<_CharT, _Traits> &getline(
basic_istream<_CharT, _Traits> & __in,
basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim) {
typedef basic_istream<_CharT, _Traits> __istream_type;
typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
typedef typename __istream_type::ios_base __ios_base;
typedef typename __istream_type::int_type __int_type;
typedef typename __string_type::size_type __size_type;

__size_type __extracted = 0;
const __size_type __n = __str.max_size();
typename __ios_base::iostate __err = __ios_base::goodbit;
typename __istream_type::sentry __cerb(__in, true);
if (__cerb) {
try {
__str.erase();
const __int_type __idelim = _Traits::to_int_type(__delim);
const __int_type __eof = _Traits::eof();
__int_type __c = __in.rdbuf()->sgetc();

while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) &&
!_Traits::eq_int_type(__c, __idelim)) {
__str += _Traits::to_char_type(__c);
++__extracted;
__c = __in.rdbuf()->snextc();
}

if (_Traits::eq_int_type(__c, __eof))
__err |= __ios_base::eofbit;
else if (_Traits::eq_int_type(__c, __idelim)) {
++__extracted;
__in.rdbuf()->sbumpc();
} else
__err |= __ios_base::failbit;
} catch (__cxxabiv1::__forced_unwind &) {
__in._M_setstate(__ios_base::badbit);
throw;
} catch (...) {

__in._M_setstate(__ios_base::badbit);
}
}
if (!__extracted)
__err |= __ios_base::failbit;
if (__err)
__in.setstate(__err);
return __in;
}
extern template class basic_string<char>;

extern template basic_istream<char> &operator>>(basic_istream<char> &,
string &);
extern template basic_ostream<char> &operator<<(basic_ostream<char> &,
const string &);
extern template basic_istream<char> &getline(basic_istream<char> &, string &,
char);
extern template basic_istream<char> &getline(basic_istream<char> &, string &);

extern template class basic_string<wchar_t>;

extern template basic_istream<wchar_t> &operator>>(basic_istream<wchar_t> &,
wstring &);
extern template basic_ostream<wchar_t> &operator<<(basic_ostream<wchar_t> &,
const wstring &);
extern template basic_istream<wchar_t> &getline(basic_istream<wchar_t> &,
wstring &, wchar_t);
extern template basic_istream<wchar_t> &getline(basic_istream<wchar_t> &,
wstring &);

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace pmr {
template <typename _Tp> class polymorphic_allocator;
template <typename _CharT, typename _Traits = char_traits<_CharT>>
using basic_string =
std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
using string = basic_string<char>;

using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
} // namespace pmr

template <typename _Str>
struct __hash_string_base : public __hash_base<size_t, _Str> {
size_t operator()(const _Str &__s) const noexcept {
return hash<basic_string_view<typename _Str::value_type>>{}(__s);
}
};

template <>
struct hash<pmr::string> : public __hash_string_base<pmr::string> {};

template <>
struct hash<pmr::u16string> : public __hash_string_base<pmr::u16string> {};
template <>
struct hash<pmr::u32string> : public __hash_string_base<pmr::u32string> {};
template <>
struct hash<pmr::wstring> : public __hash_string_base<pmr::wstring> {};

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

template <size_t _Nw> struct _Base_bitset {
typedef unsigned long _WordT;

_WordT _M_w[_Nw];

constexpr _Base_bitset() noexcept : _M_w() {}

constexpr _Base_bitset(unsigned long long __val) noexcept
: _M_w{_WordT(__val)

} {}

static constexpr size_t _S_whichword(size_t __pos) noexcept {
return __pos / (8 * 8);
}

static constexpr size_t _S_whichbyte(size_t __pos) noexcept {
return (__pos % (8 * 8)) / 8;
}

static constexpr size_t _S_whichbit(size_t __pos) noexcept {
return __pos % (8 * 8);
}

static constexpr _WordT _S_maskbit(size_t __pos) noexcept {
return (static_cast<_WordT>(1)) << _S_whichbit(__pos);
}

_WordT &_M_getword(size_t __pos) noexcept {
return _M_w[_S_whichword(__pos)];
}

constexpr _WordT _M_getword(size_t __pos) const noexcept {
return _M_w[_S_whichword(__pos)];
}

const _WordT *_M_getdata() const noexcept { return _M_w; }

_WordT &_M_hiword() noexcept { return _M_w[_Nw - 1]; }

constexpr _WordT _M_hiword() const noexcept { return _M_w[_Nw - 1]; }

void _M_do_and(const _Base_bitset<_Nw> &__x) noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
_M_w[__i] &= __x._M_w[__i];
}

void _M_do_or(const _Base_bitset<_Nw> &__x) noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
_M_w[__i] |= __x._M_w[__i];
}

void _M_do_xor(const _Base_bitset<_Nw> &__x) noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
_M_w[__i] ^= __x._M_w[__i];
}

void _M_do_left_shift(size_t __shift) noexcept;

void _M_do_right_shift(size_t __shift) noexcept;

void _M_do_flip() noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
_M_w[__i] = ~_M_w[__i];
}

void _M_do_set() noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
_M_w[__i] = ~static_cast<_WordT>(0);
}

void _M_do_reset() noexcept {
__builtin_memset(_M_w, 0, _Nw * sizeof(_WordT));
}

bool _M_is_equal(const _Base_bitset<_Nw> &__x) const noexcept {
for (size_t __i = 0; __i < _Nw; ++__i)
if (_M_w[__i] != __x._M_w[__i])
return false;
return true;
}

template <size_t _Nb> bool _M_are_all() const noexcept {
for (size_t __i = 0; __i < _Nw - 1; __i++)
if (_M_w[__i] != ~static_cast<_WordT>(0))
return false;
return _M_hiword() == (~static_cast<_WordT>(0) >> (_Nw * (8 * 8) - _Nb));
}

bool _M_is_any() const noexcept {
for (size_t __i = 0; __i < _Nw; __i++)
if (_M_w[__i] != static_cast<_WordT>(0))
return true;
return false;
}

size_t _M_do_count() const noexcept {
size_t __result = 0;
for (size_t __i = 0; __i < _Nw; __i++)
__result += __builtin_popcountl(_M_w[__i]);
return __result;
}

unsigned long _M_do_to_ulong() const;

unsigned long long _M_do_to_ullong() const;

size_t _M_do_find_first(size_t) const noexcept;

size_t _M_do_find_next(size_t, size_t) const noexcept;
};

template <size_t _Nw>
void _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept {
if (__builtin_expect(__shift != 0, 1)) {
const size_t __wshift = __shift / (8 * 8);
const size_t __offset = __shift % (8 * 8);

if (__offset == 0)
for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
_M_w[__n] = _M_w[__n - __wshift];
else {
const size_t __sub_offset = ((8 * 8) - __offset);
for (size_t __n = _Nw - 1; __n > __wshift; --__n)
_M_w[__n] = ((_M_w[__n - __wshift] << __offset) |
(_M_w[__n - __wshift - 1] >> __sub_offset));
_M_w[__wshift] = _M_w[0] << __offset;
}

std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
}
}

template <size_t _Nw>
void _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept {
if (__builtin_expect(__shift != 0, 1)) {
const size_t __wshift = __shift / (8 * 8);
const size_t __offset = __shift % (8 * 8);
const size_t __limit = _Nw - __wshift - 1;

if (__offset == 0)
for (size_t __n = 0; __n <= __limit; ++__n)
_M_w[__n] = _M_w[__n + __wshift];
else {
const size_t __sub_offset = ((8 * 8) - __offset);
for (size_t __n = 0; __n < __limit; ++__n)
_M_w[__n] = ((_M_w[__n + __wshift] >> __offset) |
(_M_w[__n + __wshift + 1] << __sub_offset));
_M_w[__limit] = _M_w[_Nw - 1] >> __offset;
}

std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
}
}

template <size_t _Nw>
unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const {
for (size_t __i = 1; __i < _Nw; ++__i)
if (_M_w[__i])
__throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
return _M_w[0];
}

template <size_t _Nw>
unsigned long long _Base_bitset<_Nw>::_M_do_to_ullong() const {
const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
if (_M_w[__i])
__throw_overflow_error(("_Base_bitset::_M_do_to_ullong"));

if (__dw)
return _M_w[0] + (static_cast<unsigned long long>(_M_w[1]) << (8 * 8));
return _M_w[0];
}

template <size_t _Nw>
size_t _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found)
const noexcept {
for (size_t __i = 0; __i < _Nw; __i++) {
_WordT __thisword = _M_w[__i];
if (__thisword != static_cast<_WordT>(0))
return (__i * (8 * 8) + __builtin_ctzl(__thisword));
}

return __not_found;
}

template <size_t _Nw>
size_t _Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found)
const noexcept {

++__prev;

if (__prev >= _Nw * (8 * 8))
return __not_found;

size_t __i = _S_whichword(__prev);
_WordT __thisword = _M_w[__i];

__thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);

if (__thisword != static_cast<_WordT>(0))
return (__i * (8 * 8) + __builtin_ctzl(__thisword));

__i++;
for (; __i < _Nw; __i++) {
__thisword = _M_w[__i];
if (__thisword != static_cast<_WordT>(0))
return (__i * (8 * 8) + __builtin_ctzl(__thisword));
}

return __not_found;
}

template <> struct _Base_bitset<1> {
typedef unsigned long _WordT;
_WordT _M_w;

constexpr _Base_bitset() noexcept : _M_w(0) {}

constexpr _Base_bitset(unsigned long long __val) noexcept

: _M_w(__val) {}

static constexpr size_t _S_whichword(size_t __pos) noexcept {
return __pos / (8 * 8);
}

static constexpr size_t _S_whichbyte(size_t __pos) noexcept {
return (__pos % (8 * 8)) / 8;
}

static constexpr size_t _S_whichbit(size_t __pos) noexcept {
return __pos % (8 * 8);
}

static constexpr _WordT _S_maskbit(size_t __pos) noexcept {
return (static_cast<_WordT>(1)) << _S_whichbit(__pos);
}

_WordT &_M_getword(size_t) noexcept { return _M_w; }

constexpr _WordT _M_getword(size_t) const noexcept { return _M_w; }

const _WordT *_M_getdata() const noexcept { return &_M_w; }

_WordT &_M_hiword() noexcept { return _M_w; }

constexpr _WordT _M_hiword() const noexcept { return _M_w; }

void _M_do_and(const _Base_bitset<1> &__x) noexcept { _M_w &= __x._M_w; }

void _M_do_or(const _Base_bitset<1> &__x) noexcept { _M_w |= __x._M_w; }

void _M_do_xor(const _Base_bitset<1> &__x) noexcept { _M_w ^= __x._M_w; }

void _M_do_left_shift(size_t __shift) noexcept { _M_w <<= __shift; }

void _M_do_right_shift(size_t __shift) noexcept { _M_w >>= __shift; }

void _M_do_flip() noexcept { _M_w = ~_M_w; }

void _M_do_set() noexcept { _M_w = ~static_cast<_WordT>(0); }

void _M_do_reset() noexcept { _M_w = 0; }

bool _M_is_equal(const _Base_bitset<1> &__x) const noexcept {
return _M_w == __x._M_w;
}

template <size_t _Nb> bool _M_are_all() const noexcept {
return _M_w == (~static_cast<_WordT>(0) >> ((8 * 8) - _Nb));
}

bool _M_is_any() const noexcept { return _M_w != 0; }

size_t _M_do_count() const noexcept { return __builtin_popcountl(_M_w); }

unsigned long _M_do_to_ulong() const noexcept { return _M_w; }

unsigned long long _M_do_to_ullong() const noexcept { return _M_w; }

size_t _M_do_find_first(size_t __not_found) const noexcept {
if (_M_w != 0)
return __builtin_ctzl(_M_w);
else
return __not_found;
}

size_t _M_do_find_next(size_t __prev, size_t __not_found) const noexcept {
++__prev;
if (__prev >= ((size_t)(8 * 8)))
return __not_found;

_WordT __x = _M_w >> __prev;
if (__x != 0)
return __builtin_ctzl(__x) + __prev;
else
return __not_found;
}
};

template <> struct _Base_bitset<0> {
typedef unsigned long _WordT;

constexpr _Base_bitset() noexcept {}

constexpr _Base_bitset(unsigned long long) noexcept

{}

static constexpr size_t _S_whichword(size_t __pos) noexcept {
return __pos / (8 * 8);
}

static constexpr size_t _S_whichbyte(size_t __pos) noexcept {
return (__pos % (8 * 8)) / 8;
}

static constexpr size_t _S_whichbit(size_t __pos) noexcept {
return __pos % (8 * 8);
}

static constexpr _WordT _S_maskbit(size_t __pos) noexcept {
return (static_cast<_WordT>(1)) << _S_whichbit(__pos);
}
_WordT &_M_getword(size_t) noexcept {
__throw_out_of_range(("_Base_bitset::_M_getword"));
return *new _WordT;
}

constexpr _WordT _M_getword(size_t) const noexcept { return 0; }

constexpr _WordT _M_hiword() const noexcept { return 0; }

void _M_do_and(const _Base_bitset<0> &) noexcept {}

void _M_do_or(const _Base_bitset<0> &) noexcept {}

void _M_do_xor(const _Base_bitset<0> &) noexcept {}

void _M_do_left_shift(size_t) noexcept {}

void _M_do_right_shift(size_t) noexcept {}

void _M_do_flip() noexcept {}

void _M_do_set() noexcept {}

void _M_do_reset() noexcept {}

bool _M_is_equal(const _Base_bitset<0> &) const noexcept { return true; }

template <size_t _Nb> bool _M_are_all() const noexcept { return true; }

bool _M_is_any() const noexcept { return false; }

size_t _M_do_count() const noexcept { return 0; }

unsigned long _M_do_to_ulong() const noexcept { return 0; }

unsigned long long _M_do_to_ullong() const noexcept { return 0; }

size_t _M_do_find_first(size_t) const noexcept { return 0; }

size_t _M_do_find_next(size_t, size_t) const noexcept { return 0; }
};

template <size_t _Extrabits> struct _Sanitize {
typedef unsigned long _WordT;

static void _S_do_sanitize(_WordT &__val) noexcept {
__val &= ~((~static_cast<_WordT>(0)) << _Extrabits);
}
};

template <> struct _Sanitize<0> {
typedef unsigned long _WordT;

static void _S_do_sanitize(_WordT) noexcept {}
};

template <size_t _Nb, bool = (_Nb < (8 * 8))> struct _Sanitize_val {
static constexpr unsigned long long
_S_do_sanitize_val(unsigned long long __val) {
return __val;
}
};

template <size_t _Nb> struct _Sanitize_val<_Nb, true> {
static constexpr unsigned long long
_S_do_sanitize_val(unsigned long long __val) {
return __val & ~((~static_cast<unsigned long long>(0)) << _Nb);
}
};
template <size_t _Nb>
class bitset : private _Base_bitset<((_Nb) / (8 * 8) +
((_Nb) % (8 * 8) == 0 ? 0 : 1))> {
private:
typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
_Base;
typedef unsigned long _WordT;

template <class _CharT, class _Traits, class _Alloc>
void _M_check_initial_position(
const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __position) const {
if (__position > __s.size())
__throw_out_of_range_fmt(("bitset::bitset: __position "
"(which is %zu) > __s.size() "
"(which is %zu)")

,
__position, __s.size());
}

void _M_check(size_t __position, const char *__s) const {
if (__position >= _Nb)
__throw_out_of_range_fmt(("%s: __position (which is %zu) "
">= _Nb (which is %zu)"),
__s, __position, _Nb);
}

void _M_do_sanitize() noexcept {
typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
__sanitize_type::_S_do_sanitize(this->_M_hiword());
}

friend struct std::hash<bitset>;

public:
class reference {
friend class bitset;

_WordT *_M_wp;
size_t _M_bpos;

reference();

public:
reference(bitset &__b, size_t __pos) noexcept {
_M_wp = &__b._M_getword(__pos);
_M_bpos = _Base::_S_whichbit(__pos);
}

reference(const reference &) = default;

~reference() noexcept {}

reference &operator=(bool __x) noexcept {
if (__x)
*_M_wp |= _Base::_S_maskbit(_M_bpos);
else
*_M_wp &= ~_Base::_S_maskbit(_M_bpos);
return *this;
}

reference &operator=(const reference &__j) noexcept {
if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
*_M_wp |= _Base::_S_maskbit(_M_bpos);
else
*_M_wp &= ~_Base::_S_maskbit(_M_bpos);
return *this;
}

bool operator~() const noexcept {
return (*(_M_wp)&_Base::_S_maskbit(_M_bpos)) == 0;
}

operator bool() const noexcept {
return (*(_M_wp)&_Base::_S_maskbit(_M_bpos)) != 0;
}

reference &flip() noexcept {
*_M_wp ^= _Base::_S_maskbit(_M_bpos);
return *this;
}
};
friend class reference;

constexpr bitset() noexcept {}

constexpr bitset(unsigned long long __val) noexcept
: _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) {}
template <class _CharT, class _Traits, class _Alloc>
explicit bitset(const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __position = 0)
: _Base() {
_M_check_initial_position(__s, __position);
_M_copy_from_string(__s, __position,
std::basic_string<_CharT, _Traits, _Alloc>::npos,
_CharT('0'), _CharT('1'));
}
template <class _CharT, class _Traits, class _Alloc>
bitset(const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __position, size_t __n)
: _Base() {
_M_check_initial_position(__s, __position);
_M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
}

template <class _CharT, class _Traits, class _Alloc>
bitset(const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __position, size_t __n, _CharT __zero,
_CharT __one = _CharT('1'))
: _Base() {
_M_check_initial_position(__s, __position);
_M_copy_from_string(__s, __position, __n, __zero, __one);
}
template <typename _CharT>
explicit bitset(const _CharT *__str,
typename std::basic_string<_CharT>::size_type __n =
std::basic_string<_CharT>::npos,
_CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
: _Base() {
if (!__str)
__throw_logic_error(("bitset::bitset(const _CharT*, ...)"));

if (__n == std::basic_string<_CharT>::npos)
__n = std::char_traits<_CharT>::length(__str);
_M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0, __n,
__zero, __one);
}
bitset<_Nb> &operator&=(const bitset<_Nb> &__rhs) noexcept {
this->_M_do_and(__rhs);
return *this;
}

bitset<_Nb> &operator|=(const bitset<_Nb> &__rhs) noexcept {
this->_M_do_or(__rhs);
return *this;
}

bitset<_Nb> &operator^=(const bitset<_Nb> &__rhs) noexcept {
this->_M_do_xor(__rhs);
return *this;
}
bitset<_Nb> &operator<<=(size_t __position) noexcept {
if (__builtin_expect(__position < _Nb, 1)) {
this->_M_do_left_shift(__position);
this->_M_do_sanitize();
} else
this->_M_do_reset();
return *this;
}

bitset<_Nb> &operator>>=(size_t __position) noexcept {
if (__builtin_expect(__position < _Nb, 1)) {
this->_M_do_right_shift(__position);
this->_M_do_sanitize();
} else
this->_M_do_reset();
return *this;
}
bitset<_Nb> &_Unchecked_set(size_t __pos) noexcept {
this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
return *this;
}

bitset<_Nb> &_Unchecked_set(size_t __pos, int __val) noexcept {
if (__val)
this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
else
this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
return *this;
}

bitset<_Nb> &_Unchecked_reset(size_t __pos) noexcept {
this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
return *this;
}

bitset<_Nb> &_Unchecked_flip(size_t __pos) noexcept {
this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
return *this;
}

constexpr bool _Unchecked_test(size_t __pos) const noexcept {
return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos)) !=
static_cast<_WordT>(0));
}

bitset<_Nb> &set() noexcept {
this->_M_do_set();
this->_M_do_sanitize();
return *this;
}

bitset<_Nb> &set(size_t __position, bool __val = true) {
this->_M_check(__position, ("bitset::set"));
return _Unchecked_set(__position, __val);
}

bitset<_Nb> &reset() noexcept {
this->_M_do_reset();
return *this;
}
bitset<_Nb> &reset(size_t __position) {
this->_M_check(__position, ("bitset::reset"));
return _Unchecked_reset(__position);
}

bitset<_Nb> &flip() noexcept {
this->_M_do_flip();
this->_M_do_sanitize();
return *this;
}

bitset<_Nb> &flip(size_t __position) {
this->_M_check(__position, ("bitset::flip"));
return _Unchecked_flip(__position);
}

bitset<_Nb> operator~() const noexcept { return bitset<_Nb>(*this).flip(); }
reference operator[](size_t __position) {
return reference(*this, __position);
}

constexpr bool operator[](size_t __position) const {
return _Unchecked_test(__position);
}
unsigned long to_ulong() const { return this->_M_do_to_ulong(); }

unsigned long long to_ullong() const { return this->_M_do_to_ullong(); }
template <class _CharT, class _Traits, class _Alloc>
std::basic_string<_CharT, _Traits, _Alloc> to_string() const {
std::basic_string<_CharT, _Traits, _Alloc> __result;
_M_copy_to_string(__result, _CharT('0'), _CharT('1'));
return __result;
}

template <class _CharT, class _Traits, class _Alloc>
std::basic_string<_CharT, _Traits, _Alloc>
to_string(_CharT __zero, _CharT __one = _CharT('1')) const {
std::basic_string<_CharT, _Traits, _Alloc> __result;
_M_copy_to_string(__result, __zero, __one);
return __result;
}

template <class _CharT, class _Traits>
std::basic_string<_CharT, _Traits, std::allocator<_CharT>>
to_string() const {
return to_string<_CharT, _Traits, std::allocator<_CharT>>();
}

template <class _CharT, class _Traits>
std::basic_string<_CharT, _Traits, std::allocator<_CharT>>
to_string(_CharT __zero, _CharT __one = _CharT('1')) const {
return to_string<_CharT, _Traits, std::allocator<_CharT>>(__zero, __one);
}

template <class _CharT>
std::basic_string<_CharT, std::char_traits<_CharT>, std::allocator<_CharT>>
to_string() const {
return to_string<_CharT, std::char_traits<_CharT>,
std::allocator<_CharT>>();
}

template <class _CharT>
std::basic_string<_CharT, std::char_traits<_CharT>, std::allocator<_CharT>>
to_string(_CharT __zero, _CharT __one = _CharT('1')) const {
return to_string<_CharT, std::char_traits<_CharT>,
std::allocator<_CharT>>(__zero, __one);
}

std::basic_string<char, std::char_traits<char>, std::allocator<char>>
to_string() const {
return to_string<char, std::char_traits<char>, std::allocator<char>>();
}

std::basic_string<char, std::char_traits<char>, std::allocator<char>>
to_string(char __zero, char __one = '1') const {
return to_string<char, std::char_traits<char>, std::allocator<char>>(
__zero, __one);
}

template <class _CharT, class _Traits>
void _M_copy_from_ptr(const _CharT *, size_t, size_t, size_t, _CharT,
_CharT);

template <class _CharT, class _Traits, class _Alloc>
void
_M_copy_from_string(const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __pos, size_t __n, _CharT __zero, _CharT __one) {
_M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
__zero, __one);
}

template <class _CharT, class _Traits, class _Alloc>
void _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc> &, _CharT,
_CharT) const;

template <class _CharT, class _Traits, class _Alloc>
void
_M_copy_from_string(const std::basic_string<_CharT, _Traits, _Alloc> &__s,
size_t __pos, size_t __n) {
_M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1'));
}

template <class _CharT, class _Traits, class _Alloc>
void
_M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc> &__s) const {
_M_copy_to_string(__s, _CharT('0'), _CharT('1'));
}

size_t count() const noexcept { return this->_M_do_count(); }

constexpr size_t size() const noexcept { return _Nb; }

bool operator==(const bitset<_Nb> &__rhs) const noexcept {
return this->_M_is_equal(__rhs);
}

bool operator!=(const bitset<_Nb> &__rhs) const noexcept {
return !this->_M_is_equal(__rhs);
}
bool test(size_t __position) const {
this->_M_check(__position, ("bitset::test"));
return _Unchecked_test(__position);
}

bool all() const noexcept { return this->template _M_are_all<_Nb>(); }

bool any() const noexcept { return this->_M_is_any(); }

bool none() const noexcept { return !this->_M_is_any(); }

bitset<_Nb> operator<<(size_t __position) const noexcept {
return bitset<_Nb>(*this) <<= __position;
}

bitset<_Nb> operator>>(size_t __position) const noexcept {
return bitset<_Nb>(*this) >>= __position;
}
size_t _Find_first() const noexcept { return this->_M_do_find_first(_Nb); }
size_t _Find_next(size_t __prev) const noexcept {
return this->_M_do_find_next(__prev, _Nb);
}
};

template <size_t _Nb>
template <class _CharT, class _Traits>
void bitset<_Nb>::_M_copy_from_ptr(const _CharT *__s, size_t __len,
size_t __pos, size_t __n, _CharT __zero,
_CharT __one) {
reset();
const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
for (size_t __i = __nbits; __i > 0; --__i) {
const _CharT __c = __s[__pos + __nbits - __i];
if (_Traits::eq(__c, __zero))
;
else if (_Traits::eq(__c, __one))
_Unchecked_set(__i - 1);
else
__throw_invalid_argument(("bitset::_M_copy_from_ptr"));
}
}

template <size_t _Nb>
template <class _CharT, class _Traits, class _Alloc>
void bitset<_Nb>::_M_copy_to_string(
std::basic_string<_CharT, _Traits, _Alloc> & __s, _CharT __zero,
_CharT __one) const {
__s.assign(_Nb, __zero);
for (size_t __i = _Nb; __i > 0; --__i)
if (_Unchecked_test(__i - 1))
_Traits::assign(__s[_Nb - __i], __one);
}
template <size_t _Nb>
inline bitset<_Nb> operator&(const bitset<_Nb> &__x,
const bitset<_Nb> &__y) noexcept {
bitset<_Nb> __result(__x);
__result &= __y;
return __result;
}

template <size_t _Nb>
inline bitset<_Nb> operator|(const bitset<_Nb> &__x,
const bitset<_Nb> &__y) noexcept {
bitset<_Nb> __result(__x);
__result |= __y;
return __result;
}

template <size_t _Nb>
inline bitset<_Nb> operator^(const bitset<_Nb> &__x,
const bitset<_Nb> &__y) noexcept {
bitset<_Nb> __result(__x);
__result ^= __y;
return __result;
}
template <class _CharT, class _Traits, size_t _Nb>
std::basic_istream<_CharT, _Traits> &operator>>(
std::basic_istream<_CharT, _Traits> &__is, bitset<_Nb> &__x) {
typedef typename _Traits::char_type char_type;
typedef std::basic_istream<_CharT, _Traits> __istream_type;
typedef typename __istream_type::ios_base __ios_base;

std::basic_string<_CharT, _Traits> __tmp;
__tmp.reserve(_Nb);

const char_type __zero = __is.widen('0');
const char_type __one = __is.widen('1');

typename __ios_base::iostate __state = __ios_base::goodbit;
typename __istream_type::sentry __sentry(__is);
if (__sentry) {
try {
for (size_t __i = _Nb; __i > 0; --__i) {
static typename _Traits::int_type __eof = _Traits::eof();

typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
if (_Traits::eq_int_type(__c1, __eof)) {
__state |= __ios_base::eofbit;
break;
} else {
const char_type __c2 = _Traits::to_char_type(__c1);
if (_Traits::eq(__c2, __zero))
__tmp.push_back(__zero);
else if (_Traits::eq(__c2, __one))
__tmp.push_back(__one);
else if (_Traits::eq_int_type(__is.rdbuf()->sputbackc(__c2),
__eof)) {
__state |= __ios_base::failbit;
break;
}
}
}
} catch (__cxxabiv1::__forced_unwind &) {
__is._M_setstate(__ios_base::badbit);
throw;
} catch (...) {
__is._M_setstate(__ios_base::badbit);
}
}

if (__tmp.empty() && _Nb)
__state |= __ios_base::failbit;
else
__x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb, __zero,
__one);
if (__state)
__is.setstate(__state);
return __is;
}

template <class _CharT, class _Traits, size_t _Nb>
std::basic_ostream<_CharT, _Traits> &operator<<(
std::basic_ostream<_CharT, _Traits> &__os, const bitset<_Nb> &__x) {
std::basic_string<_CharT, _Traits> __tmp;

const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__os.getloc());
__x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
return __os << __tmp;
}

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

template <size_t _Nb>
struct hash<std::bitset<_Nb>> : public __hash_base<size_t, std::bitset<_Nb>> {
size_t operator()(const std::bitset<_Nb> &__b) const noexcept {
const size_t __clength = (_Nb + 8 - 1) / 8;
return std::_Hash_impl::hash(__b._M_getdata(), __clength);
}
};

template <>
struct hash<std::bitset<0>> : public __hash_base<size_t, std::bitset<0>> {
size_t operator()(const std::bitset<0> &) const noexcept { return 0; }
};

} // namespace std

extern "C" {

typedef float float_t;
typedef double double_t;

enum {
FP_INT_UPWARD =

0,
FP_INT_DOWNWARD =

1,
FP_INT_TOWARDZERO =

2,
FP_INT_TONEARESTFROMZERO =

3,
FP_INT_TONEAREST =

4,
};
extern int __fpclassify(double __value) noexcept(true)
__attribute__((__const__));

extern int __signbit(double __value) noexcept(true) __attribute__((__const__));

extern int __isinf(double __value) noexcept(true) __attribute__((__const__));

extern int __finite(double __value) noexcept(true) __attribute__((__const__));

extern int __isnan(double __value) noexcept(true) __attribute__((__const__));

extern int __iseqsig(double __x, double __y) noexcept(true);

extern int __issignaling(double __value) noexcept(true)
__attribute__((__const__));
extern double acos(double __x) noexcept(true);
extern double __acos(double __x) noexcept(true);

extern double asin(double __x) noexcept(true);
extern double __asin(double __x) noexcept(true);

extern double atan(double __x) noexcept(true);
extern double __atan(double __x) noexcept(true);

extern double atan2(double __y, double __x) noexcept(true);
extern double __atan2(double __y, double __x) noexcept(true);

extern double cos(double __x) noexcept(true);
extern double __cos(double __x) noexcept(true);

extern double sin(double __x) noexcept(true);
extern double __sin(double __x) noexcept(true);

extern double tan(double __x) noexcept(true);
extern double __tan(double __x) noexcept(true);

extern double cosh(double __x) noexcept(true);
extern double __cosh(double __x) noexcept(true);

extern double sinh(double __x) noexcept(true);
extern double __sinh(double __x) noexcept(true);

extern double tanh(double __x) noexcept(true);
extern double __tanh(double __x) noexcept(true);

extern void sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
extern void __sincos(double __x, double *__sinx, double *__cosx) noexcept(true);

extern double acosh(double __x) noexcept(true);
extern double __acosh(double __x) noexcept(true);

extern double asinh(double __x) noexcept(true);
extern double __asinh(double __x) noexcept(true);

extern double atanh(double __x) noexcept(true);
extern double __atanh(double __x) noexcept(true);

extern double exp(double __x) noexcept(true);
extern double __exp(double __x) noexcept(true);

extern double frexp(double __x, int *__exponent) noexcept(true);
extern double __frexp(double __x, int *__exponent) noexcept(true);

extern double ldexp(double __x, int __exponent) noexcept(true);
extern double __ldexp(double __x, int __exponent) noexcept(true);

extern double log(double __x) noexcept(true);
extern double __log(double __x) noexcept(true);

extern double log10(double __x) noexcept(true);
extern double __log10(double __x) noexcept(true);

extern double modf(double __x, double *__iptr) noexcept(true);
extern double __modf(double __x, double *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern double exp10(double __x) noexcept(true);
extern double __exp10(double __x) noexcept(true);

extern double expm1(double __x) noexcept(true);
extern double __expm1(double __x) noexcept(true);

extern double log1p(double __x) noexcept(true);
extern double __log1p(double __x) noexcept(true);

extern double logb(double __x) noexcept(true);
extern double __logb(double __x) noexcept(true);

extern double exp2(double __x) noexcept(true);
extern double __exp2(double __x) noexcept(true);

extern double log2(double __x) noexcept(true);
extern double __log2(double __x) noexcept(true);

extern double pow(double __x, double __y) noexcept(true);
extern double __pow(double __x, double __y) noexcept(true);

extern double sqrt(double __x) noexcept(true);
extern double __sqrt(double __x) noexcept(true);

extern double hypot(double __x, double __y) noexcept(true);
extern double __hypot(double __x, double __y) noexcept(true);

extern double cbrt(double __x) noexcept(true);
extern double __cbrt(double __x) noexcept(true);

extern double ceil(double __x) noexcept(true) __attribute__((__const__));
extern double __ceil(double __x) noexcept(true) __attribute__((__const__));

extern double fabs(double __x) noexcept(true) __attribute__((__const__));
extern double __fabs(double __x) noexcept(true) __attribute__((__const__));

extern double floor(double __x) noexcept(true) __attribute__((__const__));
extern double __floor(double __x) noexcept(true) __attribute__((__const__));

extern double fmod(double __x, double __y) noexcept(true);
extern double __fmod(double __x, double __y) noexcept(true);
extern int finite(double __value) noexcept(true) __attribute__((__const__));

extern double drem(double __x, double __y) noexcept(true);
extern double __drem(double __x, double __y) noexcept(true);

extern double significand(double __x) noexcept(true);
extern double __significand(double __x) noexcept(true);

extern double copysign(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __copysign(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double nan(const char *__tagb) noexcept(true);
extern double __nan(const char *__tagb) noexcept(true);
extern double j0(double) noexcept(true);
extern double __j0(double) noexcept(true);
extern double j1(double) noexcept(true);
extern double __j1(double) noexcept(true);
extern double jn(int, double) noexcept(true);
extern double __jn(int, double) noexcept(true);
extern double y0(double) noexcept(true);
extern double __y0(double) noexcept(true);
extern double y1(double) noexcept(true);
extern double __y1(double) noexcept(true);
extern double yn(int, double) noexcept(true);
extern double __yn(int, double) noexcept(true);

extern double erf(double) noexcept(true);
extern double __erf(double) noexcept(true);
extern double erfc(double) noexcept(true);
extern double __erfc(double) noexcept(true);
extern double lgamma(double) noexcept(true);
extern double __lgamma(double) noexcept(true);

extern double tgamma(double) noexcept(true);
extern double __tgamma(double) noexcept(true);

extern double gamma(double) noexcept(true);
extern double __gamma(double) noexcept(true);

extern double lgamma_r(double, int *__signgamp) noexcept(true);
extern double __lgamma_r(double, int *__signgamp) noexcept(true);

extern double rint(double __x) noexcept(true);
extern double __rint(double __x) noexcept(true);

extern double nextafter(double __x, double __y) noexcept(true);
extern double __nextafter(double __x, double __y) noexcept(true);

extern double nexttoward(double __x, long double __y) noexcept(true);
extern double __nexttoward(double __x, long double __y) noexcept(true);

extern double nextdown(double __x) noexcept(true);
extern double __nextdown(double __x) noexcept(true);

extern double nextup(double __x) noexcept(true);
extern double __nextup(double __x) noexcept(true);

extern double remainder(double __x, double __y) noexcept(true);
extern double __remainder(double __x, double __y) noexcept(true);

extern double scalbn(double __x, int __n) noexcept(true);
extern double __scalbn(double __x, int __n) noexcept(true);

extern int ilogb(double __x) noexcept(true);
extern int __ilogb(double __x) noexcept(true);

extern long int llogb(double __x) noexcept(true);
extern long int __llogb(double __x) noexcept(true);

extern double scalbln(double __x, long int __n) noexcept(true);
extern double __scalbln(double __x, long int __n) noexcept(true);

extern double nearbyint(double __x) noexcept(true);
extern double __nearbyint(double __x) noexcept(true);

extern double round(double __x) noexcept(true) __attribute__((__const__));
extern double __round(double __x) noexcept(true) __attribute__((__const__));

extern double trunc(double __x) noexcept(true) __attribute__((__const__));
extern double __trunc(double __x) noexcept(true) __attribute__((__const__));

extern double remquo(double __x, double __y, int *__quo) noexcept(true);
extern double __remquo(double __x, double __y, int *__quo) noexcept(true);

extern long int lrint(double __x) noexcept(true);
extern long int __lrint(double __x) noexcept(true);
__extension__ extern long long int llrint(double __x) noexcept(true);
extern long long int __llrint(double __x) noexcept(true);

extern long int lround(double __x) noexcept(true);
extern long int __lround(double __x) noexcept(true);
__extension__ extern long long int llround(double __x) noexcept(true);
extern long long int __llround(double __x) noexcept(true);

extern double fdim(double __x, double __y) noexcept(true);
extern double __fdim(double __x, double __y) noexcept(true);

extern double fmax(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmax(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fmin(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmin(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fma(double __x, double __y, double __z) noexcept(true);
extern double __fma(double __x, double __y, double __z) noexcept(true);

extern double roundeven(double __x) noexcept(true) __attribute__((__const__));
extern double __roundeven(double __x) noexcept(true) __attribute__((__const__));

extern __intmax_t fromfp(double __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfp(double __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfp(double __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfp(double __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpx(double __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpx(double __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpx(double __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpx(double __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalize(double *__cx, const double *__x) noexcept(true);

extern double fmaxmag(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmaxmag(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fminmag(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fminmag(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fmaximum(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmaximum(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fminimum(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fminimum(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fmaximum_num(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmaximum_num(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fminimum_num(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fminimum_num(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fmaximum_mag(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmaximum_mag(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fminimum_mag(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fminimum_mag(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fmaximum_mag_num(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fmaximum_mag_num(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern double fminimum_mag_num(double __x, double __y) noexcept(true)
__attribute__((__const__));
extern double __fminimum_mag_num(double __x, double __y) noexcept(true)
__attribute__((__const__));

extern int totalorder(const double *__x, const double *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermag(const double *__x, const double *__y) noexcept(true)

__attribute__((__pure__));

extern double getpayload(const double *__x) noexcept(true);
extern double __getpayload(const double *__x) noexcept(true);

extern int setpayload(double *__x, double __payload) noexcept(true);

extern int setpayloadsig(double *__x, double __payload) noexcept(true);

extern double scalb(double __x, double __n) noexcept(true);
extern double __scalb(double __x, double __n) noexcept(true);
extern int __fpclassifyf(float __value) noexcept(true)
__attribute__((__const__));

extern int __signbitf(float __value) noexcept(true) __attribute__((__const__));

extern int __isinff(float __value) noexcept(true) __attribute__((__const__));

extern int __finitef(float __value) noexcept(true) __attribute__((__const__));

extern int __isnanf(float __value) noexcept(true) __attribute__((__const__));

extern int __iseqsigf(float __x, float __y) noexcept(true);

extern int __issignalingf(float __value) noexcept(true)
__attribute__((__const__));
extern float acosf(float __x) noexcept(true);
extern float __acosf(float __x) noexcept(true);

extern float asinf(float __x) noexcept(true);
extern float __asinf(float __x) noexcept(true);

extern float atanf(float __x) noexcept(true);
extern float __atanf(float __x) noexcept(true);

extern float atan2f(float __y, float __x) noexcept(true);
extern float __atan2f(float __y, float __x) noexcept(true);

extern float cosf(float __x) noexcept(true);
extern float __cosf(float __x) noexcept(true);

extern float sinf(float __x) noexcept(true);
extern float __sinf(float __x) noexcept(true);

extern float tanf(float __x) noexcept(true);
extern float __tanf(float __x) noexcept(true);

extern float coshf(float __x) noexcept(true);
extern float __coshf(float __x) noexcept(true);

extern float sinhf(float __x) noexcept(true);
extern float __sinhf(float __x) noexcept(true);

extern float tanhf(float __x) noexcept(true);
extern float __tanhf(float __x) noexcept(true);

extern void sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
extern void __sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);

extern float acoshf(float __x) noexcept(true);
extern float __acoshf(float __x) noexcept(true);

extern float asinhf(float __x) noexcept(true);
extern float __asinhf(float __x) noexcept(true);

extern float atanhf(float __x) noexcept(true);
extern float __atanhf(float __x) noexcept(true);

extern float expf(float __x) noexcept(true);
extern float __expf(float __x) noexcept(true);

extern float frexpf(float __x, int *__exponent) noexcept(true);
extern float __frexpf(float __x, int *__exponent) noexcept(true);

extern float ldexpf(float __x, int __exponent) noexcept(true);
extern float __ldexpf(float __x, int __exponent) noexcept(true);

extern float logf(float __x) noexcept(true);
extern float __logf(float __x) noexcept(true);

extern float log10f(float __x) noexcept(true);
extern float __log10f(float __x) noexcept(true);

extern float modff(float __x, float *__iptr) noexcept(true);
extern float __modff(float __x, float *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern float exp10f(float __x) noexcept(true);
extern float __exp10f(float __x) noexcept(true);

extern float expm1f(float __x) noexcept(true);
extern float __expm1f(float __x) noexcept(true);

extern float log1pf(float __x) noexcept(true);
extern float __log1pf(float __x) noexcept(true);

extern float logbf(float __x) noexcept(true);
extern float __logbf(float __x) noexcept(true);

extern float exp2f(float __x) noexcept(true);
extern float __exp2f(float __x) noexcept(true);

extern float log2f(float __x) noexcept(true);
extern float __log2f(float __x) noexcept(true);

extern float powf(float __x, float __y) noexcept(true);
extern float __powf(float __x, float __y) noexcept(true);

extern float sqrtf(float __x) noexcept(true);
extern float __sqrtf(float __x) noexcept(true);

extern float hypotf(float __x, float __y) noexcept(true);
extern float __hypotf(float __x, float __y) noexcept(true);

extern float cbrtf(float __x) noexcept(true);
extern float __cbrtf(float __x) noexcept(true);

extern float ceilf(float __x) noexcept(true) __attribute__((__const__));
extern float __ceilf(float __x) noexcept(true) __attribute__((__const__));

extern float fabsf(float __x) noexcept(true) __attribute__((__const__));
extern float __fabsf(float __x) noexcept(true) __attribute__((__const__));

extern float floorf(float __x) noexcept(true) __attribute__((__const__));
extern float __floorf(float __x) noexcept(true) __attribute__((__const__));

extern float fmodf(float __x, float __y) noexcept(true);
extern float __fmodf(float __x, float __y) noexcept(true);
extern int isinff(float __value) noexcept(true) __attribute__((__const__));

extern int finitef(float __value) noexcept(true) __attribute__((__const__));

extern float dremf(float __x, float __y) noexcept(true);
extern float __dremf(float __x, float __y) noexcept(true);

extern float significandf(float __x) noexcept(true);
extern float __significandf(float __x) noexcept(true);

extern float copysignf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __copysignf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float nanf(const char *__tagb) noexcept(true);
extern float __nanf(const char *__tagb) noexcept(true);
extern int isnanf(float __value) noexcept(true) __attribute__((__const__));

extern float j0f(float) noexcept(true);
extern float __j0f(float) noexcept(true);
extern float j1f(float) noexcept(true);
extern float __j1f(float) noexcept(true);
extern float jnf(int, float) noexcept(true);
extern float __jnf(int, float) noexcept(true);
extern float y0f(float) noexcept(true);
extern float __y0f(float) noexcept(true);
extern float y1f(float) noexcept(true);
extern float __y1f(float) noexcept(true);
extern float ynf(int, float) noexcept(true);
extern float __ynf(int, float) noexcept(true);

extern float erff(float) noexcept(true);
extern float __erff(float) noexcept(true);
extern float erfcf(float) noexcept(true);
extern float __erfcf(float) noexcept(true);
extern float lgammaf(float) noexcept(true);
extern float __lgammaf(float) noexcept(true);

extern float tgammaf(float) noexcept(true);
extern float __tgammaf(float) noexcept(true);

extern float gammaf(float) noexcept(true);
extern float __gammaf(float) noexcept(true);

extern float lgammaf_r(float, int *__signgamp) noexcept(true);
extern float __lgammaf_r(float, int *__signgamp) noexcept(true);

extern float rintf(float __x) noexcept(true);
extern float __rintf(float __x) noexcept(true);

extern float nextafterf(float __x, float __y) noexcept(true);
extern float __nextafterf(float __x, float __y) noexcept(true);

extern float nexttowardf(float __x, long double __y) noexcept(true);
extern float __nexttowardf(float __x, long double __y) noexcept(true);

extern float nextdownf(float __x) noexcept(true);
extern float __nextdownf(float __x) noexcept(true);

extern float nextupf(float __x) noexcept(true);
extern float __nextupf(float __x) noexcept(true);

extern float remainderf(float __x, float __y) noexcept(true);
extern float __remainderf(float __x, float __y) noexcept(true);

extern float scalbnf(float __x, int __n) noexcept(true);
extern float __scalbnf(float __x, int __n) noexcept(true);

extern int ilogbf(float __x) noexcept(true);
extern int __ilogbf(float __x) noexcept(true);

extern long int llogbf(float __x) noexcept(true);
extern long int __llogbf(float __x) noexcept(true);

extern float scalblnf(float __x, long int __n) noexcept(true);
extern float __scalblnf(float __x, long int __n) noexcept(true);

extern float nearbyintf(float __x) noexcept(true);
extern float __nearbyintf(float __x) noexcept(true);

extern float roundf(float __x) noexcept(true) __attribute__((__const__));
extern float __roundf(float __x) noexcept(true) __attribute__((__const__));

extern float truncf(float __x) noexcept(true) __attribute__((__const__));
extern float __truncf(float __x) noexcept(true) __attribute__((__const__));

extern float remquof(float __x, float __y, int *__quo) noexcept(true);
extern float __remquof(float __x, float __y, int *__quo) noexcept(true);

extern long int lrintf(float __x) noexcept(true);
extern long int __lrintf(float __x) noexcept(true);
__extension__ extern long long int llrintf(float __x) noexcept(true);
extern long long int __llrintf(float __x) noexcept(true);

extern long int lroundf(float __x) noexcept(true);
extern long int __lroundf(float __x) noexcept(true);
__extension__ extern long long int llroundf(float __x) noexcept(true);
extern long long int __llroundf(float __x) noexcept(true);

extern float fdimf(float __x, float __y) noexcept(true);
extern float __fdimf(float __x, float __y) noexcept(true);

extern float fmaxf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaxf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fmaf(float __x, float __y, float __z) noexcept(true);
extern float __fmaf(float __x, float __y, float __z) noexcept(true);

extern float roundevenf(float __x) noexcept(true) __attribute__((__const__));
extern float __roundevenf(float __x) noexcept(true) __attribute__((__const__));

extern __intmax_t fromfpf(float __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf(float __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf(float __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf(float __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf(float __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf(float __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf(float __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf(float __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef(float *__cx, const float *__x) noexcept(true);

extern float fmaxmagf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaxmagf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminmagf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminmagf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fmaximumf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaximumf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminimumf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminimumf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fmaximum_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaximum_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminimum_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminimum_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fmaximum_magf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaximum_magf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminimum_magf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminimum_magf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fmaximum_mag_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fmaximum_mag_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern float fminimum_mag_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));
extern float __fminimum_mag_numf(float __x, float __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf(const float *__x, const float *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf(const float *__x, const float *__y) noexcept(true)

__attribute__((__pure__));

extern float getpayloadf(const float *__x) noexcept(true);
extern float __getpayloadf(const float *__x) noexcept(true);

extern int setpayloadf(float *__x, float __payload) noexcept(true);

extern int setpayloadsigf(float *__x, float __payload) noexcept(true);

extern float scalbf(float __x, float __n) noexcept(true);
extern float __scalbf(float __x, float __n) noexcept(true);
extern int __fpclassifyl(long double __value) noexcept(true)
__attribute__((__const__));

extern int __signbitl(long double __value) noexcept(true)
__attribute__((__const__));

extern int __isinfl(long double __value) noexcept(true)
__attribute__((__const__));

extern int __finitel(long double __value) noexcept(true)
__attribute__((__const__));

extern int __isnanl(long double __value) noexcept(true)
__attribute__((__const__));

extern int __iseqsigl(long double __x, long double __y) noexcept(true);

extern int __issignalingl(long double __value) noexcept(true)
__attribute__((__const__));
extern long double acosl(long double __x) noexcept(true);
extern long double __acosl(long double __x) noexcept(true);

extern long double asinl(long double __x) noexcept(true);
extern long double __asinl(long double __x) noexcept(true);

extern long double atanl(long double __x) noexcept(true);
extern long double __atanl(long double __x) noexcept(true);

extern long double atan2l(long double __y, long double __x) noexcept(true);
extern long double __atan2l(long double __y, long double __x) noexcept(true);

extern long double cosl(long double __x) noexcept(true);
extern long double __cosl(long double __x) noexcept(true);

extern long double sinl(long double __x) noexcept(true);
extern long double __sinl(long double __x) noexcept(true);

extern long double tanl(long double __x) noexcept(true);
extern long double __tanl(long double __x) noexcept(true);

extern long double coshl(long double __x) noexcept(true);
extern long double __coshl(long double __x) noexcept(true);

extern long double sinhl(long double __x) noexcept(true);
extern long double __sinhl(long double __x) noexcept(true);

extern long double tanhl(long double __x) noexcept(true);
extern long double __tanhl(long double __x) noexcept(true);

extern void sincosl(long double __x, long double *__sinx,
long double *__cosx) noexcept(true);
extern void __sincosl(long double __x, long double *__sinx,
long double *__cosx) noexcept(true);

extern long double acoshl(long double __x) noexcept(true);
extern long double __acoshl(long double __x) noexcept(true);

extern long double asinhl(long double __x) noexcept(true);
extern long double __asinhl(long double __x) noexcept(true);

extern long double atanhl(long double __x) noexcept(true);
extern long double __atanhl(long double __x) noexcept(true);

extern long double expl(long double __x) noexcept(true);
extern long double __expl(long double __x) noexcept(true);

extern long double frexpl(long double __x, int *__exponent) noexcept(true);
extern long double __frexpl(long double __x, int *__exponent) noexcept(true);

extern long double ldexpl(long double __x, int __exponent) noexcept(true);
extern long double __ldexpl(long double __x, int __exponent) noexcept(true);

extern long double logl(long double __x) noexcept(true);
extern long double __logl(long double __x) noexcept(true);

extern long double log10l(long double __x) noexcept(true);
extern long double __log10l(long double __x) noexcept(true);

extern long double modfl(long double __x, long double *__iptr) noexcept(true);
extern long double __modfl(long double __x, long double *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern long double exp10l(long double __x) noexcept(true);
extern long double __exp10l(long double __x) noexcept(true);

extern long double expm1l(long double __x) noexcept(true);
extern long double __expm1l(long double __x) noexcept(true);

extern long double log1pl(long double __x) noexcept(true);
extern long double __log1pl(long double __x) noexcept(true);

extern long double logbl(long double __x) noexcept(true);
extern long double __logbl(long double __x) noexcept(true);

extern long double exp2l(long double __x) noexcept(true);
extern long double __exp2l(long double __x) noexcept(true);

extern long double log2l(long double __x) noexcept(true);
extern long double __log2l(long double __x) noexcept(true);

extern long double powl(long double __x, long double __y) noexcept(true);
extern long double __powl(long double __x, long double __y) noexcept(true);

extern long double sqrtl(long double __x) noexcept(true);
extern long double __sqrtl(long double __x) noexcept(true);

extern long double hypotl(long double __x, long double __y) noexcept(true);
extern long double __hypotl(long double __x, long double __y) noexcept(true);

extern long double cbrtl(long double __x) noexcept(true);
extern long double __cbrtl(long double __x) noexcept(true);

extern long double ceill(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __ceill(long double __x) noexcept(true)
__attribute__((__const__));

extern long double fabsl(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __fabsl(long double __x) noexcept(true)
__attribute__((__const__));

extern long double floorl(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __floorl(long double __x) noexcept(true)
__attribute__((__const__));

extern long double fmodl(long double __x, long double __y) noexcept(true);
extern long double __fmodl(long double __x, long double __y) noexcept(true);
extern int isinfl(long double __value) noexcept(true)
__attribute__((__const__));

extern int finitel(long double __value) noexcept(true)
__attribute__((__const__));

extern long double dreml(long double __x, long double __y) noexcept(true);
extern long double __dreml(long double __x, long double __y) noexcept(true);

extern long double significandl(long double __x) noexcept(true);
extern long double __significandl(long double __x) noexcept(true);

extern long double copysignl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __copysignl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double nanl(const char *__tagb) noexcept(true);
extern long double __nanl(const char *__tagb) noexcept(true);
extern int isnanl(long double __value) noexcept(true)
__attribute__((__const__));

extern long double j0l(long double) noexcept(true);
extern long double __j0l(long double) noexcept(true);
extern long double j1l(long double) noexcept(true);
extern long double __j1l(long double) noexcept(true);
extern long double jnl(int, long double) noexcept(true);
extern long double __jnl(int, long double) noexcept(true);
extern long double y0l(long double) noexcept(true);
extern long double __y0l(long double) noexcept(true);
extern long double y1l(long double) noexcept(true);
extern long double __y1l(long double) noexcept(true);
extern long double ynl(int, long double) noexcept(true);
extern long double __ynl(int, long double) noexcept(true);

extern long double erfl(long double) noexcept(true);
extern long double __erfl(long double) noexcept(true);
extern long double erfcl(long double) noexcept(true);
extern long double __erfcl(long double) noexcept(true);
extern long double lgammal(long double) noexcept(true);
extern long double __lgammal(long double) noexcept(true);

extern long double tgammal(long double) noexcept(true);
extern long double __tgammal(long double) noexcept(true);

extern long double gammal(long double) noexcept(true);
extern long double __gammal(long double) noexcept(true);

extern long double lgammal_r(long double, int *__signgamp) noexcept(true);
extern long double __lgammal_r(long double, int *__signgamp) noexcept(true);

extern long double rintl(long double __x) noexcept(true);
extern long double __rintl(long double __x) noexcept(true);

extern long double nextafterl(long double __x, long double __y) noexcept(true);
extern long double __nextafterl(long double __x,
long double __y) noexcept(true);

extern long double nexttowardl(long double __x, long double __y) noexcept(true);
extern long double __nexttowardl(long double __x,
long double __y) noexcept(true);

extern long double nextdownl(long double __x) noexcept(true);
extern long double __nextdownl(long double __x) noexcept(true);

extern long double nextupl(long double __x) noexcept(true);
extern long double __nextupl(long double __x) noexcept(true);

extern long double remainderl(long double __x, long double __y) noexcept(true);
extern long double __remainderl(long double __x,
long double __y) noexcept(true);

extern long double scalbnl(long double __x, int __n) noexcept(true);
extern long double __scalbnl(long double __x, int __n) noexcept(true);

extern int ilogbl(long double __x) noexcept(true);
extern int __ilogbl(long double __x) noexcept(true);

extern long int llogbl(long double __x) noexcept(true);
extern long int __llogbl(long double __x) noexcept(true);

extern long double scalblnl(long double __x, long int __n) noexcept(true);
extern long double __scalblnl(long double __x, long int __n) noexcept(true);

extern long double nearbyintl(long double __x) noexcept(true);
extern long double __nearbyintl(long double __x) noexcept(true);

extern long double roundl(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __roundl(long double __x) noexcept(true)
__attribute__((__const__));

extern long double truncl(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __truncl(long double __x) noexcept(true)
__attribute__((__const__));

extern long double remquol(long double __x, long double __y,
int *__quo) noexcept(true);
extern long double __remquol(long double __x, long double __y,
int *__quo) noexcept(true);

extern long int lrintl(long double __x) noexcept(true);
extern long int __lrintl(long double __x) noexcept(true);
__extension__ extern long long int llrintl(long double __x) noexcept(true);
extern long long int __llrintl(long double __x) noexcept(true);

extern long int lroundl(long double __x) noexcept(true);
extern long int __lroundl(long double __x) noexcept(true);
__extension__ extern long long int llroundl(long double __x) noexcept(true);
extern long long int __llroundl(long double __x) noexcept(true);

extern long double fdiml(long double __x, long double __y) noexcept(true);
extern long double __fdiml(long double __x, long double __y) noexcept(true);

extern long double fmaxl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaxl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fmal(long double __x, long double __y,
long double __z) noexcept(true);
extern long double __fmal(long double __x, long double __y,
long double __z) noexcept(true);

extern long double roundevenl(long double __x) noexcept(true)
__attribute__((__const__));
extern long double __roundevenl(long double __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpl(long double __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpl(long double __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpl(long double __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpl(long double __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxl(long double __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxl(long double __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxl(long double __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxl(long double __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizel(long double *__cx,
const long double *__x) noexcept(true);

extern long double fmaxmagl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaxmagl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminmagl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminmagl(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fmaximuml(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaximuml(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminimuml(long double __x, long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminimuml(long double __x, long double __y) noexcept(true)
__attribute__((__const__));

extern long double fmaximum_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaximum_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminimum_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminimum_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern long double fmaximum_magl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaximum_magl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminimum_magl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminimum_magl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern long double fmaximum_mag_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fmaximum_mag_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern long double fminimum_mag_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));
extern long double __fminimum_mag_numl(long double __x,
long double __y) noexcept(true)
__attribute__((__const__));

extern int totalorderl(const long double *__x,
const long double *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagl(const long double *__x,
const long double *__y) noexcept(true)

__attribute__((__pure__));

extern long double getpayloadl(const long double *__x) noexcept(true);
extern long double __getpayloadl(const long double *__x) noexcept(true);

extern int setpayloadl(long double *__x, long double __payload) noexcept(true);

extern int setpayloadsigl(long double *__x,
long double __payload) noexcept(true);

extern long double scalbl(long double __x, long double __n) noexcept(true);
extern long double __scalbl(long double __x, long double __n) noexcept(true);
extern _Float32 acosf32(_Float32 __x) noexcept(true);
extern _Float32 __acosf32(_Float32 __x) noexcept(true);

extern _Float32 asinf32(_Float32 __x) noexcept(true);
extern _Float32 __asinf32(_Float32 __x) noexcept(true);

extern _Float32 atanf32(_Float32 __x) noexcept(true);
extern _Float32 __atanf32(_Float32 __x) noexcept(true);

extern _Float32 atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) noexcept(true);

extern _Float32 cosf32(_Float32 __x) noexcept(true);
extern _Float32 __cosf32(_Float32 __x) noexcept(true);

extern _Float32 sinf32(_Float32 __x) noexcept(true);
extern _Float32 __sinf32(_Float32 __x) noexcept(true);

extern _Float32 tanf32(_Float32 __x) noexcept(true);
extern _Float32 __tanf32(_Float32 __x) noexcept(true);

extern _Float32 coshf32(_Float32 __x) noexcept(true);
extern _Float32 __coshf32(_Float32 __x) noexcept(true);

extern _Float32 sinhf32(_Float32 __x) noexcept(true);
extern _Float32 __sinhf32(_Float32 __x) noexcept(true);

extern _Float32 tanhf32(_Float32 __x) noexcept(true);
extern _Float32 __tanhf32(_Float32 __x) noexcept(true);

extern void sincosf32(_Float32 __x, _Float32 *__sinx,
_Float32 *__cosx) noexcept(true);
extern void __sincosf32(_Float32 __x, _Float32 *__sinx,
_Float32 *__cosx) noexcept(true);

extern _Float32 acoshf32(_Float32 __x) noexcept(true);
extern _Float32 __acoshf32(_Float32 __x) noexcept(true);

extern _Float32 asinhf32(_Float32 __x) noexcept(true);
extern _Float32 __asinhf32(_Float32 __x) noexcept(true);

extern _Float32 atanhf32(_Float32 __x) noexcept(true);
extern _Float32 __atanhf32(_Float32 __x) noexcept(true);

extern _Float32 expf32(_Float32 __x) noexcept(true);
extern _Float32 __expf32(_Float32 __x) noexcept(true);

extern _Float32 frexpf32(_Float32 __x, int *__exponent) noexcept(true);
extern _Float32 __frexpf32(_Float32 __x, int *__exponent) noexcept(true);

extern _Float32 ldexpf32(_Float32 __x, int __exponent) noexcept(true);
extern _Float32 __ldexpf32(_Float32 __x, int __exponent) noexcept(true);

extern _Float32 logf32(_Float32 __x) noexcept(true);
extern _Float32 __logf32(_Float32 __x) noexcept(true);

extern _Float32 log10f32(_Float32 __x) noexcept(true);
extern _Float32 __log10f32(_Float32 __x) noexcept(true);

extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) noexcept(true);
extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern _Float32 exp10f32(_Float32 __x) noexcept(true);
extern _Float32 __exp10f32(_Float32 __x) noexcept(true);

extern _Float32 expm1f32(_Float32 __x) noexcept(true);
extern _Float32 __expm1f32(_Float32 __x) noexcept(true);

extern _Float32 log1pf32(_Float32 __x) noexcept(true);
extern _Float32 __log1pf32(_Float32 __x) noexcept(true);

extern _Float32 logbf32(_Float32 __x) noexcept(true);
extern _Float32 __logbf32(_Float32 __x) noexcept(true);

extern _Float32 exp2f32(_Float32 __x) noexcept(true);
extern _Float32 __exp2f32(_Float32 __x) noexcept(true);

extern _Float32 log2f32(_Float32 __x) noexcept(true);
extern _Float32 __log2f32(_Float32 __x) noexcept(true);

extern _Float32 powf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __powf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 sqrtf32(_Float32 __x) noexcept(true);
extern _Float32 __sqrtf32(_Float32 __x) noexcept(true);

extern _Float32 hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 cbrtf32(_Float32 __x) noexcept(true);
extern _Float32 __cbrtf32(_Float32 __x) noexcept(true);

extern _Float32 ceilf32(_Float32 __x) noexcept(true) __attribute__((__const__));
extern _Float32 __ceilf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern _Float32 fabsf32(_Float32 __x) noexcept(true) __attribute__((__const__));
extern _Float32 __fabsf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern _Float32 floorf32(_Float32 __x) noexcept(true)
__attribute__((__const__));
extern _Float32 __floorf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern _Float32 fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 nanf32(const char *__tagb) noexcept(true);
extern _Float32 __nanf32(const char *__tagb) noexcept(true);
extern _Float32 j0f32(_Float32) noexcept(true);
extern _Float32 __j0f32(_Float32) noexcept(true);
extern _Float32 j1f32(_Float32) noexcept(true);
extern _Float32 __j1f32(_Float32) noexcept(true);
extern _Float32 jnf32(int, _Float32) noexcept(true);
extern _Float32 __jnf32(int, _Float32) noexcept(true);
extern _Float32 y0f32(_Float32) noexcept(true);
extern _Float32 __y0f32(_Float32) noexcept(true);
extern _Float32 y1f32(_Float32) noexcept(true);
extern _Float32 __y1f32(_Float32) noexcept(true);
extern _Float32 ynf32(int, _Float32) noexcept(true);
extern _Float32 __ynf32(int, _Float32) noexcept(true);

extern _Float32 erff32(_Float32) noexcept(true);
extern _Float32 __erff32(_Float32) noexcept(true);
extern _Float32 erfcf32(_Float32) noexcept(true);
extern _Float32 __erfcf32(_Float32) noexcept(true);
extern _Float32 lgammaf32(_Float32) noexcept(true);
extern _Float32 __lgammaf32(_Float32) noexcept(true);

extern _Float32 tgammaf32(_Float32) noexcept(true);
extern _Float32 __tgammaf32(_Float32) noexcept(true);
extern _Float32 lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) noexcept(true);

extern _Float32 rintf32(_Float32 __x) noexcept(true);
extern _Float32 __rintf32(_Float32 __x) noexcept(true);

extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 nextdownf32(_Float32 __x) noexcept(true);
extern _Float32 __nextdownf32(_Float32 __x) noexcept(true);

extern _Float32 nextupf32(_Float32 __x) noexcept(true);
extern _Float32 __nextupf32(_Float32 __x) noexcept(true);

extern _Float32 remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 scalbnf32(_Float32 __x, int __n) noexcept(true);
extern _Float32 __scalbnf32(_Float32 __x, int __n) noexcept(true);

extern int ilogbf32(_Float32 __x) noexcept(true);
extern int __ilogbf32(_Float32 __x) noexcept(true);

extern long int llogbf32(_Float32 __x) noexcept(true);
extern long int __llogbf32(_Float32 __x) noexcept(true);

extern _Float32 scalblnf32(_Float32 __x, long int __n) noexcept(true);
extern _Float32 __scalblnf32(_Float32 __x, long int __n) noexcept(true);

extern _Float32 nearbyintf32(_Float32 __x) noexcept(true);
extern _Float32 __nearbyintf32(_Float32 __x) noexcept(true);

extern _Float32 roundf32(_Float32 __x) noexcept(true)
__attribute__((__const__));
extern _Float32 __roundf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern _Float32 truncf32(_Float32 __x) noexcept(true)
__attribute__((__const__));
extern _Float32 __truncf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern _Float32 remquof32(_Float32 __x, _Float32 __y,
int *__quo) noexcept(true);
extern _Float32 __remquof32(_Float32 __x, _Float32 __y,
int *__quo) noexcept(true);

extern long int lrintf32(_Float32 __x) noexcept(true);
extern long int __lrintf32(_Float32 __x) noexcept(true);
__extension__ extern long long int llrintf32(_Float32 __x) noexcept(true);
extern long long int __llrintf32(_Float32 __x) noexcept(true);

extern long int lroundf32(_Float32 __x) noexcept(true);
extern long int __lroundf32(_Float32 __x) noexcept(true);
__extension__ extern long long int llroundf32(_Float32 __x) noexcept(true);
extern long long int __llroundf32(_Float32 __x) noexcept(true);

extern _Float32 fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
extern _Float32 __fmaf32(_Float32 __x, _Float32 __y,
_Float32 __z) noexcept(true);

extern _Float32 roundevenf32(_Float32 __x) noexcept(true)
__attribute__((__const__));
extern _Float32 __roundevenf32(_Float32 __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(true);

extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern _Float32 fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));
extern _Float32 __fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf32(const _Float32 *__x,
const _Float32 *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf32(const _Float32 *__x,
const _Float32 *__y) noexcept(true)

__attribute__((__pure__));

extern _Float32 getpayloadf32(const _Float32 *__x) noexcept(true);
extern _Float32 __getpayloadf32(const _Float32 *__x) noexcept(true);

extern int setpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(true);

extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(true);
extern _Float64 acosf64(_Float64 __x) noexcept(true);
extern _Float64 __acosf64(_Float64 __x) noexcept(true);

extern _Float64 asinf64(_Float64 __x) noexcept(true);
extern _Float64 __asinf64(_Float64 __x) noexcept(true);

extern _Float64 atanf64(_Float64 __x) noexcept(true);
extern _Float64 __atanf64(_Float64 __x) noexcept(true);

extern _Float64 atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) noexcept(true);

extern _Float64 cosf64(_Float64 __x) noexcept(true);
extern _Float64 __cosf64(_Float64 __x) noexcept(true);

extern _Float64 sinf64(_Float64 __x) noexcept(true);
extern _Float64 __sinf64(_Float64 __x) noexcept(true);

extern _Float64 tanf64(_Float64 __x) noexcept(true);
extern _Float64 __tanf64(_Float64 __x) noexcept(true);

extern _Float64 coshf64(_Float64 __x) noexcept(true);
extern _Float64 __coshf64(_Float64 __x) noexcept(true);

extern _Float64 sinhf64(_Float64 __x) noexcept(true);
extern _Float64 __sinhf64(_Float64 __x) noexcept(true);

extern _Float64 tanhf64(_Float64 __x) noexcept(true);
extern _Float64 __tanhf64(_Float64 __x) noexcept(true);

extern void sincosf64(_Float64 __x, _Float64 *__sinx,
_Float64 *__cosx) noexcept(true);
extern void __sincosf64(_Float64 __x, _Float64 *__sinx,
_Float64 *__cosx) noexcept(true);

extern _Float64 acoshf64(_Float64 __x) noexcept(true);
extern _Float64 __acoshf64(_Float64 __x) noexcept(true);

extern _Float64 asinhf64(_Float64 __x) noexcept(true);
extern _Float64 __asinhf64(_Float64 __x) noexcept(true);

extern _Float64 atanhf64(_Float64 __x) noexcept(true);
extern _Float64 __atanhf64(_Float64 __x) noexcept(true);

extern _Float64 expf64(_Float64 __x) noexcept(true);
extern _Float64 __expf64(_Float64 __x) noexcept(true);

extern _Float64 frexpf64(_Float64 __x, int *__exponent) noexcept(true);
extern _Float64 __frexpf64(_Float64 __x, int *__exponent) noexcept(true);

extern _Float64 ldexpf64(_Float64 __x, int __exponent) noexcept(true);
extern _Float64 __ldexpf64(_Float64 __x, int __exponent) noexcept(true);

extern _Float64 logf64(_Float64 __x) noexcept(true);
extern _Float64 __logf64(_Float64 __x) noexcept(true);

extern _Float64 log10f64(_Float64 __x) noexcept(true);
extern _Float64 __log10f64(_Float64 __x) noexcept(true);

extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) noexcept(true);
extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern _Float64 exp10f64(_Float64 __x) noexcept(true);
extern _Float64 __exp10f64(_Float64 __x) noexcept(true);

extern _Float64 expm1f64(_Float64 __x) noexcept(true);
extern _Float64 __expm1f64(_Float64 __x) noexcept(true);

extern _Float64 log1pf64(_Float64 __x) noexcept(true);
extern _Float64 __log1pf64(_Float64 __x) noexcept(true);

extern _Float64 logbf64(_Float64 __x) noexcept(true);
extern _Float64 __logbf64(_Float64 __x) noexcept(true);

extern _Float64 exp2f64(_Float64 __x) noexcept(true);
extern _Float64 __exp2f64(_Float64 __x) noexcept(true);

extern _Float64 log2f64(_Float64 __x) noexcept(true);
extern _Float64 __log2f64(_Float64 __x) noexcept(true);

extern _Float64 powf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __powf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 sqrtf64(_Float64 __x) noexcept(true);
extern _Float64 __sqrtf64(_Float64 __x) noexcept(true);

extern _Float64 hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 cbrtf64(_Float64 __x) noexcept(true);
extern _Float64 __cbrtf64(_Float64 __x) noexcept(true);

extern _Float64 ceilf64(_Float64 __x) noexcept(true) __attribute__((__const__));
extern _Float64 __ceilf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern _Float64 fabsf64(_Float64 __x) noexcept(true) __attribute__((__const__));
extern _Float64 __fabsf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern _Float64 floorf64(_Float64 __x) noexcept(true)
__attribute__((__const__));
extern _Float64 __floorf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern _Float64 fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 nanf64(const char *__tagb) noexcept(true);
extern _Float64 __nanf64(const char *__tagb) noexcept(true);
extern _Float64 j0f64(_Float64) noexcept(true);
extern _Float64 __j0f64(_Float64) noexcept(true);
extern _Float64 j1f64(_Float64) noexcept(true);
extern _Float64 __j1f64(_Float64) noexcept(true);
extern _Float64 jnf64(int, _Float64) noexcept(true);
extern _Float64 __jnf64(int, _Float64) noexcept(true);
extern _Float64 y0f64(_Float64) noexcept(true);
extern _Float64 __y0f64(_Float64) noexcept(true);
extern _Float64 y1f64(_Float64) noexcept(true);
extern _Float64 __y1f64(_Float64) noexcept(true);
extern _Float64 ynf64(int, _Float64) noexcept(true);
extern _Float64 __ynf64(int, _Float64) noexcept(true);

extern _Float64 erff64(_Float64) noexcept(true);
extern _Float64 __erff64(_Float64) noexcept(true);
extern _Float64 erfcf64(_Float64) noexcept(true);
extern _Float64 __erfcf64(_Float64) noexcept(true);
extern _Float64 lgammaf64(_Float64) noexcept(true);
extern _Float64 __lgammaf64(_Float64) noexcept(true);

extern _Float64 tgammaf64(_Float64) noexcept(true);
extern _Float64 __tgammaf64(_Float64) noexcept(true);
extern _Float64 lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) noexcept(true);

extern _Float64 rintf64(_Float64 __x) noexcept(true);
extern _Float64 __rintf64(_Float64 __x) noexcept(true);

extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 nextdownf64(_Float64 __x) noexcept(true);
extern _Float64 __nextdownf64(_Float64 __x) noexcept(true);

extern _Float64 nextupf64(_Float64 __x) noexcept(true);
extern _Float64 __nextupf64(_Float64 __x) noexcept(true);

extern _Float64 remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 scalbnf64(_Float64 __x, int __n) noexcept(true);
extern _Float64 __scalbnf64(_Float64 __x, int __n) noexcept(true);

extern int ilogbf64(_Float64 __x) noexcept(true);
extern int __ilogbf64(_Float64 __x) noexcept(true);

extern long int llogbf64(_Float64 __x) noexcept(true);
extern long int __llogbf64(_Float64 __x) noexcept(true);

extern _Float64 scalblnf64(_Float64 __x, long int __n) noexcept(true);
extern _Float64 __scalblnf64(_Float64 __x, long int __n) noexcept(true);

extern _Float64 nearbyintf64(_Float64 __x) noexcept(true);
extern _Float64 __nearbyintf64(_Float64 __x) noexcept(true);

extern _Float64 roundf64(_Float64 __x) noexcept(true)
__attribute__((__const__));
extern _Float64 __roundf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern _Float64 truncf64(_Float64 __x) noexcept(true)
__attribute__((__const__));
extern _Float64 __truncf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern _Float64 remquof64(_Float64 __x, _Float64 __y,
int *__quo) noexcept(true);
extern _Float64 __remquof64(_Float64 __x, _Float64 __y,
int *__quo) noexcept(true);

extern long int lrintf64(_Float64 __x) noexcept(true);
extern long int __lrintf64(_Float64 __x) noexcept(true);
__extension__ extern long long int llrintf64(_Float64 __x) noexcept(true);
extern long long int __llrintf64(_Float64 __x) noexcept(true);

extern long int lroundf64(_Float64 __x) noexcept(true);
extern long int __lroundf64(_Float64 __x) noexcept(true);
__extension__ extern long long int llroundf64(_Float64 __x) noexcept(true);
extern long long int __llroundf64(_Float64 __x) noexcept(true);

extern _Float64 fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
extern _Float64 __fmaf64(_Float64 __x, _Float64 __y,
_Float64 __z) noexcept(true);

extern _Float64 roundevenf64(_Float64 __x) noexcept(true)
__attribute__((__const__));
extern _Float64 __roundevenf64(_Float64 __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(true);

extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern _Float64 fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));
extern _Float64 __fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf64(const _Float64 *__x,
const _Float64 *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf64(const _Float64 *__x,
const _Float64 *__y) noexcept(true)

__attribute__((__pure__));

extern _Float64 getpayloadf64(const _Float64 *__x) noexcept(true);
extern _Float64 __getpayloadf64(const _Float64 *__x) noexcept(true);

extern int setpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(true);

extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(true);
extern int __fpclassifyf128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern int __signbitf128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern int __isinff128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern int __finitef128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern int __isnanf128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern int __iseqsigf128(_Float128 __x, _Float128 __y) noexcept(true);

extern int __issignalingf128(_Float128 __value) noexcept(true)
__attribute__((__const__));

extern _Float128 acosf128(_Float128 __x) noexcept(true);
extern _Float128 __acosf128(_Float128 __x) noexcept(true);

extern _Float128 asinf128(_Float128 __x) noexcept(true);
extern _Float128 __asinf128(_Float128 __x) noexcept(true);

extern _Float128 atanf128(_Float128 __x) noexcept(true);
extern _Float128 __atanf128(_Float128 __x) noexcept(true);

extern _Float128 atan2f128(_Float128 __y, _Float128 __x) noexcept(true);
extern _Float128 __atan2f128(_Float128 __y, _Float128 __x) noexcept(true);

extern _Float128 cosf128(_Float128 __x) noexcept(true);
extern _Float128 __cosf128(_Float128 __x) noexcept(true);

extern _Float128 sinf128(_Float128 __x) noexcept(true);
extern _Float128 __sinf128(_Float128 __x) noexcept(true);

extern _Float128 tanf128(_Float128 __x) noexcept(true);
extern _Float128 __tanf128(_Float128 __x) noexcept(true);

extern _Float128 coshf128(_Float128 __x) noexcept(true);
extern _Float128 __coshf128(_Float128 __x) noexcept(true);

extern _Float128 sinhf128(_Float128 __x) noexcept(true);
extern _Float128 __sinhf128(_Float128 __x) noexcept(true);

extern _Float128 tanhf128(_Float128 __x) noexcept(true);
extern _Float128 __tanhf128(_Float128 __x) noexcept(true);

extern void sincosf128(_Float128 __x, _Float128 *__sinx,
_Float128 *__cosx) noexcept(true);
extern void __sincosf128(_Float128 __x, _Float128 *__sinx,
_Float128 *__cosx) noexcept(true);

extern _Float128 acoshf128(_Float128 __x) noexcept(true);
extern _Float128 __acoshf128(_Float128 __x) noexcept(true);

extern _Float128 asinhf128(_Float128 __x) noexcept(true);
extern _Float128 __asinhf128(_Float128 __x) noexcept(true);

extern _Float128 atanhf128(_Float128 __x) noexcept(true);
extern _Float128 __atanhf128(_Float128 __x) noexcept(true);

extern _Float128 expf128(_Float128 __x) noexcept(true);
extern _Float128 __expf128(_Float128 __x) noexcept(true);

extern _Float128 frexpf128(_Float128 __x, int *__exponent) noexcept(true);
extern _Float128 __frexpf128(_Float128 __x, int *__exponent) noexcept(true);

extern _Float128 ldexpf128(_Float128 __x, int __exponent) noexcept(true);
extern _Float128 __ldexpf128(_Float128 __x, int __exponent) noexcept(true);

extern _Float128 logf128(_Float128 __x) noexcept(true);
extern _Float128 __logf128(_Float128 __x) noexcept(true);

extern _Float128 log10f128(_Float128 __x) noexcept(true);
extern _Float128 __log10f128(_Float128 __x) noexcept(true);

extern _Float128 modff128(_Float128 __x, _Float128 *__iptr) noexcept(true);
extern _Float128 __modff128(_Float128 __x, _Float128 *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern _Float128 exp10f128(_Float128 __x) noexcept(true);
extern _Float128 __exp10f128(_Float128 __x) noexcept(true);

extern _Float128 expm1f128(_Float128 __x) noexcept(true);
extern _Float128 __expm1f128(_Float128 __x) noexcept(true);

extern _Float128 log1pf128(_Float128 __x) noexcept(true);
extern _Float128 __log1pf128(_Float128 __x) noexcept(true);

extern _Float128 logbf128(_Float128 __x) noexcept(true);
extern _Float128 __logbf128(_Float128 __x) noexcept(true);

extern _Float128 exp2f128(_Float128 __x) noexcept(true);
extern _Float128 __exp2f128(_Float128 __x) noexcept(true);

extern _Float128 log2f128(_Float128 __x) noexcept(true);
extern _Float128 __log2f128(_Float128 __x) noexcept(true);

extern _Float128 powf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __powf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float128 sqrtf128(_Float128 __x) noexcept(true);
extern _Float128 __sqrtf128(_Float128 __x) noexcept(true);

extern _Float128 hypotf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __hypotf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float128 cbrtf128(_Float128 __x) noexcept(true);
extern _Float128 __cbrtf128(_Float128 __x) noexcept(true);

extern _Float128 ceilf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __ceilf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern _Float128 fabsf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __fabsf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern _Float128 floorf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __floorf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern _Float128 fmodf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __fmodf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 copysignf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __copysignf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 nanf128(const char *__tagb) noexcept(true);
extern _Float128 __nanf128(const char *__tagb) noexcept(true);
extern _Float128 j0f128(_Float128) noexcept(true);
extern _Float128 __j0f128(_Float128) noexcept(true);
extern _Float128 j1f128(_Float128) noexcept(true);
extern _Float128 __j1f128(_Float128) noexcept(true);
extern _Float128 jnf128(int, _Float128) noexcept(true);
extern _Float128 __jnf128(int, _Float128) noexcept(true);
extern _Float128 y0f128(_Float128) noexcept(true);
extern _Float128 __y0f128(_Float128) noexcept(true);
extern _Float128 y1f128(_Float128) noexcept(true);
extern _Float128 __y1f128(_Float128) noexcept(true);
extern _Float128 ynf128(int, _Float128) noexcept(true);
extern _Float128 __ynf128(int, _Float128) noexcept(true);

extern _Float128 erff128(_Float128) noexcept(true);
extern _Float128 __erff128(_Float128) noexcept(true);
extern _Float128 erfcf128(_Float128) noexcept(true);
extern _Float128 __erfcf128(_Float128) noexcept(true);
extern _Float128 lgammaf128(_Float128) noexcept(true);
extern _Float128 __lgammaf128(_Float128) noexcept(true);

extern _Float128 tgammaf128(_Float128) noexcept(true);
extern _Float128 __tgammaf128(_Float128) noexcept(true);
extern _Float128 lgammaf128_r(_Float128, int *__signgamp) noexcept(true);
extern _Float128 __lgammaf128_r(_Float128, int *__signgamp) noexcept(true);

extern _Float128 rintf128(_Float128 __x) noexcept(true);
extern _Float128 __rintf128(_Float128 __x) noexcept(true);

extern _Float128 nextafterf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __nextafterf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float128 nextdownf128(_Float128 __x) noexcept(true);
extern _Float128 __nextdownf128(_Float128 __x) noexcept(true);

extern _Float128 nextupf128(_Float128 __x) noexcept(true);
extern _Float128 __nextupf128(_Float128 __x) noexcept(true);

extern _Float128 remainderf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __remainderf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float128 scalbnf128(_Float128 __x, int __n) noexcept(true);
extern _Float128 __scalbnf128(_Float128 __x, int __n) noexcept(true);

extern int ilogbf128(_Float128 __x) noexcept(true);
extern int __ilogbf128(_Float128 __x) noexcept(true);

extern long int llogbf128(_Float128 __x) noexcept(true);
extern long int __llogbf128(_Float128 __x) noexcept(true);

extern _Float128 scalblnf128(_Float128 __x, long int __n) noexcept(true);
extern _Float128 __scalblnf128(_Float128 __x, long int __n) noexcept(true);

extern _Float128 nearbyintf128(_Float128 __x) noexcept(true);
extern _Float128 __nearbyintf128(_Float128 __x) noexcept(true);

extern _Float128 roundf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __roundf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern _Float128 truncf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __truncf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern _Float128 remquof128(_Float128 __x, _Float128 __y,
int *__quo) noexcept(true);
extern _Float128 __remquof128(_Float128 __x, _Float128 __y,
int *__quo) noexcept(true);

extern long int lrintf128(_Float128 __x) noexcept(true);
extern long int __lrintf128(_Float128 __x) noexcept(true);
__extension__ extern long long int llrintf128(_Float128 __x) noexcept(true);
extern long long int __llrintf128(_Float128 __x) noexcept(true);

extern long int lroundf128(_Float128 __x) noexcept(true);
extern long int __lroundf128(_Float128 __x) noexcept(true);
__extension__ extern long long int llroundf128(_Float128 __x) noexcept(true);
extern long long int __llroundf128(_Float128 __x) noexcept(true);

extern _Float128 fdimf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float128 __fdimf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float128 fmaxf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaxf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);
extern _Float128 __fmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);

extern _Float128 roundevenf128(_Float128 __x) noexcept(true)
__attribute__((__const__));
extern _Float128 __roundevenf128(_Float128 __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf128(_Float128 __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef128(_Float128 *__cx,
const _Float128 *__x) noexcept(true);

extern _Float128 fmaxmagf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaxmagf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminmagf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminmagf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fmaximumf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaximumf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminimumf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminimumf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fmaximum_numf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaximum_numf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminimum_numf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminimum_numf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fmaximum_magf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaximum_magf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminimum_magf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminimum_magf128(_Float128 __x, _Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fmaximum_mag_numf128(_Float128 __x,
_Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fmaximum_mag_numf128(_Float128 __x,
_Float128 __y) noexcept(true)
__attribute__((__const__));

extern _Float128 fminimum_mag_numf128(_Float128 __x,
_Float128 __y) noexcept(true)
__attribute__((__const__));
extern _Float128 __fminimum_mag_numf128(_Float128 __x,
_Float128 __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf128(const _Float128 *__x,
const _Float128 *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf128(const _Float128 *__x,
const _Float128 *__y) noexcept(true)

__attribute__((__pure__));

extern _Float128 getpayloadf128(const _Float128 *__x) noexcept(true);
extern _Float128 __getpayloadf128(const _Float128 *__x) noexcept(true);

extern int setpayloadf128(_Float128 *__x, _Float128 __payload) noexcept(true);

extern int setpayloadsigf128(_Float128 *__x,
_Float128 __payload) noexcept(true);
extern _Float32x acosf32x(_Float32x __x) noexcept(true);
extern _Float32x __acosf32x(_Float32x __x) noexcept(true);

extern _Float32x asinf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinf32x(_Float32x __x) noexcept(true);

extern _Float32x atanf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanf32x(_Float32x __x) noexcept(true);

extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);

extern _Float32x cosf32x(_Float32x __x) noexcept(true);
extern _Float32x __cosf32x(_Float32x __x) noexcept(true);

extern _Float32x sinf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinf32x(_Float32x __x) noexcept(true);

extern _Float32x tanf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanf32x(_Float32x __x) noexcept(true);

extern _Float32x coshf32x(_Float32x __x) noexcept(true);
extern _Float32x __coshf32x(_Float32x __x) noexcept(true);

extern _Float32x sinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinhf32x(_Float32x __x) noexcept(true);

extern _Float32x tanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanhf32x(_Float32x __x) noexcept(true);

extern void sincosf32x(_Float32x __x, _Float32x *__sinx,
_Float32x *__cosx) noexcept(true);
extern void __sincosf32x(_Float32x __x, _Float32x *__sinx,
_Float32x *__cosx) noexcept(true);

extern _Float32x acoshf32x(_Float32x __x) noexcept(true);
extern _Float32x __acoshf32x(_Float32x __x) noexcept(true);

extern _Float32x asinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinhf32x(_Float32x __x) noexcept(true);

extern _Float32x atanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanhf32x(_Float32x __x) noexcept(true);

extern _Float32x expf32x(_Float32x __x) noexcept(true);
extern _Float32x __expf32x(_Float32x __x) noexcept(true);

extern _Float32x frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) noexcept(true);

extern _Float32x ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) noexcept(true);

extern _Float32x logf32x(_Float32x __x) noexcept(true);
extern _Float32x __logf32x(_Float32x __x) noexcept(true);

extern _Float32x log10f32x(_Float32x __x) noexcept(true);
extern _Float32x __log10f32x(_Float32x __x) noexcept(true);

extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true);
extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern _Float32x exp10f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp10f32x(_Float32x __x) noexcept(true);

extern _Float32x expm1f32x(_Float32x __x) noexcept(true);
extern _Float32x __expm1f32x(_Float32x __x) noexcept(true);

extern _Float32x log1pf32x(_Float32x __x) noexcept(true);
extern _Float32x __log1pf32x(_Float32x __x) noexcept(true);

extern _Float32x logbf32x(_Float32x __x) noexcept(true);
extern _Float32x __logbf32x(_Float32x __x) noexcept(true);

extern _Float32x exp2f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp2f32x(_Float32x __x) noexcept(true);

extern _Float32x log2f32x(_Float32x __x) noexcept(true);
extern _Float32x __log2f32x(_Float32x __x) noexcept(true);

extern _Float32x powf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __powf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x sqrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __sqrtf32x(_Float32x __x) noexcept(true);

extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x cbrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __cbrtf32x(_Float32x __x) noexcept(true);

extern _Float32x ceilf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __ceilf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern _Float32x fabsf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __fabsf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern _Float32x floorf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __floorf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x nanf32x(const char *__tagb) noexcept(true);
extern _Float32x __nanf32x(const char *__tagb) noexcept(true);
extern _Float32x j0f32x(_Float32x) noexcept(true);
extern _Float32x __j0f32x(_Float32x) noexcept(true);
extern _Float32x j1f32x(_Float32x) noexcept(true);
extern _Float32x __j1f32x(_Float32x) noexcept(true);
extern _Float32x jnf32x(int, _Float32x) noexcept(true);
extern _Float32x __jnf32x(int, _Float32x) noexcept(true);
extern _Float32x y0f32x(_Float32x) noexcept(true);
extern _Float32x __y0f32x(_Float32x) noexcept(true);
extern _Float32x y1f32x(_Float32x) noexcept(true);
extern _Float32x __y1f32x(_Float32x) noexcept(true);
extern _Float32x ynf32x(int, _Float32x) noexcept(true);
extern _Float32x __ynf32x(int, _Float32x) noexcept(true);

extern _Float32x erff32x(_Float32x) noexcept(true);
extern _Float32x __erff32x(_Float32x) noexcept(true);
extern _Float32x erfcf32x(_Float32x) noexcept(true);
extern _Float32x __erfcf32x(_Float32x) noexcept(true);
extern _Float32x lgammaf32x(_Float32x) noexcept(true);
extern _Float32x __lgammaf32x(_Float32x) noexcept(true);

extern _Float32x tgammaf32x(_Float32x) noexcept(true);
extern _Float32x __tgammaf32x(_Float32x) noexcept(true);
extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);

extern _Float32x rintf32x(_Float32x __x) noexcept(true);
extern _Float32x __rintf32x(_Float32x __x) noexcept(true);

extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x nextdownf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextdownf32x(_Float32x __x) noexcept(true);

extern _Float32x nextupf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextupf32x(_Float32x __x) noexcept(true);

extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x scalbnf32x(_Float32x __x, int __n) noexcept(true);
extern _Float32x __scalbnf32x(_Float32x __x, int __n) noexcept(true);

extern int ilogbf32x(_Float32x __x) noexcept(true);
extern int __ilogbf32x(_Float32x __x) noexcept(true);

extern long int llogbf32x(_Float32x __x) noexcept(true);
extern long int __llogbf32x(_Float32x __x) noexcept(true);

extern _Float32x scalblnf32x(_Float32x __x, long int __n) noexcept(true);
extern _Float32x __scalblnf32x(_Float32x __x, long int __n) noexcept(true);

extern _Float32x nearbyintf32x(_Float32x __x) noexcept(true);
extern _Float32x __nearbyintf32x(_Float32x __x) noexcept(true);

extern _Float32x roundf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __roundf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern _Float32x truncf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __truncf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern _Float32x remquof32x(_Float32x __x, _Float32x __y,
int *__quo) noexcept(true);
extern _Float32x __remquof32x(_Float32x __x, _Float32x __y,
int *__quo) noexcept(true);

extern long int lrintf32x(_Float32x __x) noexcept(true);
extern long int __lrintf32x(_Float32x __x) noexcept(true);
__extension__ extern long long int llrintf32x(_Float32x __x) noexcept(true);
extern long long int __llrintf32x(_Float32x __x) noexcept(true);

extern long int lroundf32x(_Float32x __x) noexcept(true);
extern long int __lroundf32x(_Float32x __x) noexcept(true);
__extension__ extern long long int llroundf32x(_Float32x __x) noexcept(true);
extern long long int __llroundf32x(_Float32x __x) noexcept(true);

extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fmaf32x(_Float32x __x, _Float32x __y,
_Float32x __z) noexcept(true);
extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y,
_Float32x __z) noexcept(true);

extern _Float32x roundevenf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));
extern _Float32x __roundevenf32x(_Float32x __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef32x(_Float32x *__cx,
const _Float32x *__x) noexcept(true);

extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fmaximum_mag_numf32x(_Float32x __x,
_Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fmaximum_mag_numf32x(_Float32x __x,
_Float32x __y) noexcept(true)
__attribute__((__const__));

extern _Float32x fminimum_mag_numf32x(_Float32x __x,
_Float32x __y) noexcept(true)
__attribute__((__const__));
extern _Float32x __fminimum_mag_numf32x(_Float32x __x,
_Float32x __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf32x(const _Float32x *__x,
const _Float32x *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf32x(const _Float32x *__x,
const _Float32x *__y) noexcept(true)

__attribute__((__pure__));

extern _Float32x getpayloadf32x(const _Float32x *__x) noexcept(true);
extern _Float32x __getpayloadf32x(const _Float32x *__x) noexcept(true);

extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(true);

extern int setpayloadsigf32x(_Float32x *__x,
_Float32x __payload) noexcept(true);
extern _Float64x acosf64x(_Float64x __x) noexcept(true);
extern _Float64x __acosf64x(_Float64x __x) noexcept(true);

extern _Float64x asinf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinf64x(_Float64x __x) noexcept(true);

extern _Float64x atanf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanf64x(_Float64x __x) noexcept(true);

extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);

extern _Float64x cosf64x(_Float64x __x) noexcept(true);
extern _Float64x __cosf64x(_Float64x __x) noexcept(true);

extern _Float64x sinf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinf64x(_Float64x __x) noexcept(true);

extern _Float64x tanf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanf64x(_Float64x __x) noexcept(true);

extern _Float64x coshf64x(_Float64x __x) noexcept(true);
extern _Float64x __coshf64x(_Float64x __x) noexcept(true);

extern _Float64x sinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinhf64x(_Float64x __x) noexcept(true);

extern _Float64x tanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanhf64x(_Float64x __x) noexcept(true);

extern void sincosf64x(_Float64x __x, _Float64x *__sinx,
_Float64x *__cosx) noexcept(true);
extern void __sincosf64x(_Float64x __x, _Float64x *__sinx,
_Float64x *__cosx) noexcept(true);

extern _Float64x acoshf64x(_Float64x __x) noexcept(true);
extern _Float64x __acoshf64x(_Float64x __x) noexcept(true);

extern _Float64x asinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinhf64x(_Float64x __x) noexcept(true);

extern _Float64x atanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanhf64x(_Float64x __x) noexcept(true);

extern _Float64x expf64x(_Float64x __x) noexcept(true);
extern _Float64x __expf64x(_Float64x __x) noexcept(true);

extern _Float64x frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) noexcept(true);

extern _Float64x ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) noexcept(true);

extern _Float64x logf64x(_Float64x __x) noexcept(true);
extern _Float64x __logf64x(_Float64x __x) noexcept(true);

extern _Float64x log10f64x(_Float64x __x) noexcept(true);
extern _Float64x __log10f64x(_Float64x __x) noexcept(true);

extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true);
extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true)
__attribute__((__nonnull__(2)));

extern _Float64x exp10f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp10f64x(_Float64x __x) noexcept(true);

extern _Float64x expm1f64x(_Float64x __x) noexcept(true);
extern _Float64x __expm1f64x(_Float64x __x) noexcept(true);

extern _Float64x log1pf64x(_Float64x __x) noexcept(true);
extern _Float64x __log1pf64x(_Float64x __x) noexcept(true);

extern _Float64x logbf64x(_Float64x __x) noexcept(true);
extern _Float64x __logbf64x(_Float64x __x) noexcept(true);

extern _Float64x exp2f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp2f64x(_Float64x __x) noexcept(true);

extern _Float64x log2f64x(_Float64x __x) noexcept(true);
extern _Float64x __log2f64x(_Float64x __x) noexcept(true);

extern _Float64x powf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __powf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x sqrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __sqrtf64x(_Float64x __x) noexcept(true);

extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x cbrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __cbrtf64x(_Float64x __x) noexcept(true);

extern _Float64x ceilf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __ceilf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern _Float64x fabsf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __fabsf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern _Float64x floorf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __floorf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x nanf64x(const char *__tagb) noexcept(true);
extern _Float64x __nanf64x(const char *__tagb) noexcept(true);
extern _Float64x j0f64x(_Float64x) noexcept(true);
extern _Float64x __j0f64x(_Float64x) noexcept(true);
extern _Float64x j1f64x(_Float64x) noexcept(true);
extern _Float64x __j1f64x(_Float64x) noexcept(true);
extern _Float64x jnf64x(int, _Float64x) noexcept(true);
extern _Float64x __jnf64x(int, _Float64x) noexcept(true);
extern _Float64x y0f64x(_Float64x) noexcept(true);
extern _Float64x __y0f64x(_Float64x) noexcept(true);
extern _Float64x y1f64x(_Float64x) noexcept(true);
extern _Float64x __y1f64x(_Float64x) noexcept(true);
extern _Float64x ynf64x(int, _Float64x) noexcept(true);
extern _Float64x __ynf64x(int, _Float64x) noexcept(true);

extern _Float64x erff64x(_Float64x) noexcept(true);
extern _Float64x __erff64x(_Float64x) noexcept(true);
extern _Float64x erfcf64x(_Float64x) noexcept(true);
extern _Float64x __erfcf64x(_Float64x) noexcept(true);
extern _Float64x lgammaf64x(_Float64x) noexcept(true);
extern _Float64x __lgammaf64x(_Float64x) noexcept(true);

extern _Float64x tgammaf64x(_Float64x) noexcept(true);
extern _Float64x __tgammaf64x(_Float64x) noexcept(true);
extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);

extern _Float64x rintf64x(_Float64x __x) noexcept(true);
extern _Float64x __rintf64x(_Float64x __x) noexcept(true);

extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x nextdownf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextdownf64x(_Float64x __x) noexcept(true);

extern _Float64x nextupf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextupf64x(_Float64x __x) noexcept(true);

extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x scalbnf64x(_Float64x __x, int __n) noexcept(true);
extern _Float64x __scalbnf64x(_Float64x __x, int __n) noexcept(true);

extern int ilogbf64x(_Float64x __x) noexcept(true);
extern int __ilogbf64x(_Float64x __x) noexcept(true);

extern long int llogbf64x(_Float64x __x) noexcept(true);
extern long int __llogbf64x(_Float64x __x) noexcept(true);

extern _Float64x scalblnf64x(_Float64x __x, long int __n) noexcept(true);
extern _Float64x __scalblnf64x(_Float64x __x, long int __n) noexcept(true);

extern _Float64x nearbyintf64x(_Float64x __x) noexcept(true);
extern _Float64x __nearbyintf64x(_Float64x __x) noexcept(true);

extern _Float64x roundf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __roundf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern _Float64x truncf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __truncf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern _Float64x remquof64x(_Float64x __x, _Float64x __y,
int *__quo) noexcept(true);
extern _Float64x __remquof64x(_Float64x __x, _Float64x __y,
int *__quo) noexcept(true);

extern long int lrintf64x(_Float64x __x) noexcept(true);
extern long int __lrintf64x(_Float64x __x) noexcept(true);
__extension__ extern long long int llrintf64x(_Float64x __x) noexcept(true);
extern long long int __llrintf64x(_Float64x __x) noexcept(true);

extern long int lroundf64x(_Float64x __x) noexcept(true);
extern long int __lroundf64x(_Float64x __x) noexcept(true);
__extension__ extern long long int llroundf64x(_Float64x __x) noexcept(true);
extern long long int __llroundf64x(_Float64x __x) noexcept(true);

extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fmaf64x(_Float64x __x, _Float64x __y,
_Float64x __z) noexcept(true);
extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y,
_Float64x __z) noexcept(true);

extern _Float64x roundevenf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));
extern _Float64x __roundevenf64x(_Float64x __x) noexcept(true)
__attribute__((__const__));

extern __intmax_t fromfpf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round,
unsigned int __width) noexcept(true);

extern int canonicalizef64x(_Float64x *__cx,
const _Float64x *__x) noexcept(true);

extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fmaximum_mag_numf64x(_Float64x __x,
_Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fmaximum_mag_numf64x(_Float64x __x,
_Float64x __y) noexcept(true)
__attribute__((__const__));

extern _Float64x fminimum_mag_numf64x(_Float64x __x,
_Float64x __y) noexcept(true)
__attribute__((__const__));
extern _Float64x __fminimum_mag_numf64x(_Float64x __x,
_Float64x __y) noexcept(true)
__attribute__((__const__));

extern int totalorderf64x(const _Float64x *__x,
const _Float64x *__y) noexcept(true)

__attribute__((__pure__));

extern int totalordermagf64x(const _Float64x *__x,
const _Float64x *__y) noexcept(true)

__attribute__((__pure__));

extern _Float64x getpayloadf64x(const _Float64x *__x) noexcept(true);
extern _Float64x __getpayloadf64x(const _Float64x *__x) noexcept(true);

extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(true);

extern int setpayloadsigf64x(_Float64x *__x,
_Float64x __payload) noexcept(true);
extern float fadd(double __x, double __y) noexcept(true);

extern float fdiv(double __x, double __y) noexcept(true);

extern float ffma(double __x, double __y, double __z) noexcept(true);

extern float fmul(double __x, double __y) noexcept(true);

extern float fsqrt(double __x) noexcept(true);

extern float fsub(double __x, double __y) noexcept(true);
extern float faddl(long double __x, long double __y) noexcept(true);

extern float fdivl(long double __x, long double __y) noexcept(true);

extern float ffmal(long double __x, long double __y,
long double __z) noexcept(true);

extern float fmull(long double __x, long double __y) noexcept(true);

extern float fsqrtl(long double __x) noexcept(true);

extern float fsubl(long double __x, long double __y) noexcept(true);
extern double daddl(long double __x, long double __y) noexcept(true);

extern double ddivl(long double __x, long double __y) noexcept(true);

extern double dfmal(long double __x, long double __y,
long double __z) noexcept(true);

extern double dmull(long double __x, long double __y) noexcept(true);

extern double dsqrtl(long double __x) noexcept(true);

extern double dsubl(long double __x, long double __y) noexcept(true);
extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32fmaf32x(_Float32x __x, _Float32x __y,
_Float32x __z) noexcept(true);

extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32sqrtf32x(_Float32x __x) noexcept(true);

extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32 f32addf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32divf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32fmaf64(_Float64 __x, _Float64 __y,
_Float64 __z) noexcept(true);

extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32sqrtf64(_Float64 __x) noexcept(true);

extern _Float32 f32subf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32fmaf64x(_Float64x __x, _Float64x __y,
_Float64x __z) noexcept(true);

extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32sqrtf64x(_Float64x __x) noexcept(true);

extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32 f32addf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32 f32divf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32 f32fmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);

extern _Float32 f32mulf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32 f32sqrtf128(_Float128 __x) noexcept(true);

extern _Float32 f32subf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xfmaf64(_Float64 __x, _Float64 __y,
_Float64 __z) noexcept(true);

extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xsqrtf64(_Float64 __x) noexcept(true);

extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xfmaf64x(_Float64x __x, _Float64x __y,
_Float64x __z) noexcept(true);

extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xsqrtf64x(_Float64x __x) noexcept(true);

extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float32x f32xaddf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32x f32xdivf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32x f32xfmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);

extern _Float32x f32xmulf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float32x f32xsqrtf128(_Float128 __x) noexcept(true);

extern _Float32x f32xsubf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64fmaf64x(_Float64x __x, _Float64x __y,
_Float64x __z) noexcept(true);

extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64sqrtf64x(_Float64x __x) noexcept(true);

extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64 f64addf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64 f64divf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64 f64fmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);

extern _Float64 f64mulf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64 f64sqrtf128(_Float128 __x) noexcept(true);

extern _Float64 f64subf128(_Float128 __x, _Float128 __y) noexcept(true);
extern _Float64x f64xaddf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64x f64xdivf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64x f64xfmaf128(_Float128 __x, _Float128 __y,
_Float128 __z) noexcept(true);

extern _Float64x f64xmulf128(_Float128 __x, _Float128 __y) noexcept(true);

extern _Float64x f64xsqrtf128(_Float128 __x) noexcept(true);

extern _Float64x f64xsubf128(_Float128 __x, _Float128 __y) noexcept(true);
extern int signgam;
enum {
FP_NAN =

0,
FP_INFINITE =

1,
FP_ZERO =

2,
FP_SUBNORMAL =

3,
FP_NORMAL =

4
};
extern int __iscanonicall(long double __x) noexcept(true)
__attribute__((__const__));
extern "C++" {
inline int iscanonical(float __val) {
return ((void)(__typeof(__val))(__val), 1);
}
inline int iscanonical(double __val) {
return ((void)(__typeof(__val))(__val), 1);
}
inline int iscanonical(long double __val) { return __iscanonicall(__val); }

inline int iscanonical(_Float128 __val) {
return ((void)(__typeof(__val))(__val), 1);
}
}
extern "C++" {
inline int issignaling(float __val) { return __issignalingf(__val); }
inline int issignaling(double __val) { return __issignaling(__val); }
inline int issignaling(long double __val) { return __issignalingl(__val); }

inline int issignaling(_Float128 __val) { return __issignalingf128(__val); }
}
extern "C++" {
template <class __T> inline bool iszero(__T __val) { return __val == 0; }
}
extern "C++" {
template <typename> struct __iseqsig_type;

template <> struct __iseqsig_type<float> {
static int __call(float __x, float __y) throw() {
return __iseqsigf(__x, __y);
}
};

template <> struct __iseqsig_type<double> {
static int __call(double __x, double __y) throw() {
return __iseqsig(__x, __y);
}
};

template <> struct __iseqsig_type<long double> {
static int __call(long double __x, long double __y) throw() {

return __iseqsigl(__x, __y);
}
};
template <> struct __iseqsig_type<_Float128> {
static int __call(_Float128 __x, _Float128 __y) throw() {

return __iseqsigf128(__x, __y);
}
};
template <typename _T1, typename _T2>
inline int iseqsig(_T1 __x, _T2 __y) throw() {

typedef decltype(((__x) + (__y) + 0.0f)) _T3;

return __iseqsig_type<_T3>::__call(__x, __y);
}
}
}
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

using ::acos;

inline constexpr float acos(float __x) { return __builtin_acosf(__x); }

inline constexpr long double acos(long double __x) {
return __builtin_acosl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
acos(_Tp __x) {
return __builtin_acos(__x);
}

using ::asin;

inline constexpr float asin(float __x) { return __builtin_asinf(__x); }

inline constexpr long double asin(long double __x) {
return __builtin_asinl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
asin(_Tp __x) {
return __builtin_asin(__x);
}

using ::atan;

inline constexpr float atan(float __x) { return __builtin_atanf(__x); }

inline constexpr long double atan(long double __x) {
return __builtin_atanl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
atan(_Tp __x) {
return __builtin_atan(__x);
}

using ::atan2;

inline constexpr float atan2(float __y, float __x) {
return __builtin_atan2f(__y, __x);
}

inline constexpr long double atan2(long double __y, long double __x) {
return __builtin_atan2l(__y, __x);
}

template <typename _Tp, typename _Up>
inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(
_Tp __y, _Up __x) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return atan2(__type(__y), __type(__x));
}

using ::ceil;

inline constexpr float ceil(float __x) { return __builtin_ceilf(__x); }

inline constexpr long double ceil(long double __x) {
return __builtin_ceill(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
ceil(_Tp __x) {
return __builtin_ceil(__x);
}

using ::cos;

inline constexpr float cos(float __x) { return __builtin_cosf(__x); }

inline constexpr long double cos(long double __x) {
return __builtin_cosl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
cos(_Tp __x) {
return __builtin_cos(__x);
}

using ::cosh;

inline constexpr float cosh(float __x) { return __builtin_coshf(__x); }

inline constexpr long double cosh(long double __x) {
return __builtin_coshl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
cosh(_Tp __x) {
return __builtin_cosh(__x);
}

using ::exp;

inline constexpr float exp(float __x) { return __builtin_expf(__x); }

inline constexpr long double exp(long double __x) {
return __builtin_expl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
exp(_Tp __x) {
return __builtin_exp(__x);
}

using ::fabs;

inline constexpr float fabs(float __x) { return __builtin_fabsf(__x); }

inline constexpr long double fabs(long double __x) {
return __builtin_fabsl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
fabs(_Tp __x) {
return __builtin_fabs(__x);
}

using ::floor;

inline constexpr float floor(float __x) { return __builtin_floorf(__x); }

inline constexpr long double floor(long double __x) {
return __builtin_floorl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
floor(_Tp __x) {
return __builtin_floor(__x);
}

using ::fmod;

inline constexpr float fmod(float __x, float __y) {
return __builtin_fmodf(__x, __y);
}

inline constexpr long double fmod(long double __x, long double __y) {
return __builtin_fmodl(__x, __y);
}

template <typename _Tp, typename _Up>
inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(
_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return fmod(__type(__x), __type(__y));
}

using ::frexp;

inline float frexp(float __x, int *__exp) {
return __builtin_frexpf(__x, __exp);
}

inline long double frexp(long double __x, int *__exp) {
return __builtin_frexpl(__x, __exp);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
frexp(_Tp __x, int *__exp) {
return __builtin_frexp(__x, __exp);
}

using ::ldexp;

inline constexpr float ldexp(float __x, int __exp) {
return __builtin_ldexpf(__x, __exp);
}

inline constexpr long double ldexp(long double __x, int __exp) {
return __builtin_ldexpl(__x, __exp);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
ldexp(_Tp __x, int __exp) {
return __builtin_ldexp(__x, __exp);
}

using ::log;

inline constexpr float log(float __x) { return __builtin_logf(__x); }

inline constexpr long double log(long double __x) {
return __builtin_logl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
log(_Tp __x) {
return __builtin_log(__x);
}

using ::log10;

inline constexpr float log10(float __x) { return __builtin_log10f(__x); }

inline constexpr long double log10(long double __x) {
return __builtin_log10l(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
log10(_Tp __x) {
return __builtin_log10(__x);
}

using ::modf;

inline float modf(float __x, float *__iptr) {
return __builtin_modff(__x, __iptr);
}

inline long double modf(long double __x, long double *__iptr) {
return __builtin_modfl(__x, __iptr);
}

using ::pow;

inline constexpr float pow(float __x, float __y) {
return __builtin_powf(__x, __y);
}

inline constexpr long double pow(long double __x, long double __y) {
return __builtin_powl(__x, __y);
}
template <typename _Tp, typename _Up>
inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(
_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return pow(__type(__x), __type(__y));
}

using ::sin;

inline constexpr float sin(float __x) { return __builtin_sinf(__x); }

inline constexpr long double sin(long double __x) {
return __builtin_sinl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
sin(_Tp __x) {
return __builtin_sin(__x);
}

using ::sinh;

inline constexpr float sinh(float __x) { return __builtin_sinhf(__x); }

inline constexpr long double sinh(long double __x) {
return __builtin_sinhl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
sinh(_Tp __x) {
return __builtin_sinh(__x);
}

using ::sqrt;

inline constexpr float sqrt(float __x) { return __builtin_sqrtf(__x); }

inline constexpr long double sqrt(long double __x) {
return __builtin_sqrtl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
sqrt(_Tp __x) {
return __builtin_sqrt(__x);
}

using ::tan;

inline constexpr float tan(float __x) { return __builtin_tanf(__x); }

inline constexpr long double tan(long double __x) {
return __builtin_tanl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
tan(_Tp __x) {
return __builtin_tan(__x);
}

using ::tanh;

inline constexpr float tanh(float __x) { return __builtin_tanhf(__x); }

inline constexpr long double tanh(long double __x) {
return __builtin_tanhl(__x);
}

template <typename _Tp>
inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
tanh(_Tp __x) {
return __builtin_tanh(__x);
}
constexpr int fpclassify(float __x) {
return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
}

constexpr int fpclassify(double __x) {
return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
}

constexpr int fpclassify(long double __x) {
return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
}

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type
fpclassify(_Tp __x) {
return __x != 0 ? 4 : 2;
}

constexpr bool isfinite(float __x) { return __builtin_isfinite(__x); }

constexpr bool isfinite(double __x) { return __builtin_isfinite(__x); }

constexpr bool isfinite(long double __x) { return __builtin_isfinite(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
isfinite(_Tp __x) {
return true;
}

constexpr bool isinf(float __x) { return __builtin_isinf(__x); }

constexpr bool isinf(double __x) { return __builtin_isinf(__x); }

constexpr bool isinf(long double __x) { return __builtin_isinf(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
isinf(_Tp __x) {
return false;
}

constexpr bool isnan(float __x) { return __builtin_isnan(__x); }

constexpr bool isnan(double __x) { return __builtin_isnan(__x); }

constexpr bool isnan(long double __x) { return __builtin_isnan(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
isnan(_Tp __x) {
return false;
}

constexpr bool isnormal(float __x) { return __builtin_isnormal(__x); }

constexpr bool isnormal(double __x) { return __builtin_isnormal(__x); }

constexpr bool isnormal(long double __x) { return __builtin_isnormal(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
isnormal(_Tp __x) {
return __x != 0 ? true : false;
}

constexpr bool signbit(float __x) { return __builtin_signbit(__x); }

constexpr bool signbit(double __x) { return __builtin_signbit(__x); }

constexpr bool signbit(long double __x) { return __builtin_signbit(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
signbit(_Tp __x) {
return __x < 0 ? true : false;
}

constexpr bool isgreater(float __x, float __y) {
return __builtin_isgreater(__x, __y);
}

constexpr bool isgreater(double __x, double __y) {
return __builtin_isgreater(__x, __y);
}

constexpr bool isgreater(long double __x, long double __y) {
return __builtin_isgreater(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
isgreater(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_isgreater(__type(__x), __type(__y));
}

constexpr bool isgreaterequal(float __x, float __y) {
return __builtin_isgreaterequal(__x, __y);
}

constexpr bool isgreaterequal(double __x, double __y) {
return __builtin_isgreaterequal(__x, __y);
}

constexpr bool isgreaterequal(long double __x, long double __y) {
return __builtin_isgreaterequal(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
isgreaterequal(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_isgreaterequal(__type(__x), __type(__y));
}

constexpr bool isless(float __x, float __y) {
return __builtin_isless(__x, __y);
}

constexpr bool isless(double __x, double __y) {
return __builtin_isless(__x, __y);
}

constexpr bool isless(long double __x, long double __y) {
return __builtin_isless(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
isless(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_isless(__type(__x), __type(__y));
}

constexpr bool islessequal(float __x, float __y) {
return __builtin_islessequal(__x, __y);
}

constexpr bool islessequal(double __x, double __y) {
return __builtin_islessequal(__x, __y);
}

constexpr bool islessequal(long double __x, long double __y) {
return __builtin_islessequal(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
islessequal(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_islessequal(__type(__x), __type(__y));
}

constexpr bool islessgreater(float __x, float __y) {
return __builtin_islessgreater(__x, __y);
}

constexpr bool islessgreater(double __x, double __y) {
return __builtin_islessgreater(__x, __y);
}

constexpr bool islessgreater(long double __x, long double __y) {
return __builtin_islessgreater(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
islessgreater(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_islessgreater(__type(__x), __type(__y));
}

constexpr bool isunordered(float __x, float __y) {
return __builtin_isunordered(__x, __y);
}

constexpr bool isunordered(double __x, double __y) {
return __builtin_isunordered(__x, __y);
}

constexpr bool isunordered(long double __x, long double __y) {
return __builtin_isunordered(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
__is_arithmetic<_Up>::__value),
bool>::__type
isunordered(_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return __builtin_isunordered(__type(__x), __type(__y));
}
using ::double_t;
using ::float_t;

using ::acosh;
using ::acoshf;
using ::acoshl;

using ::asinh;
using ::asinhf;
using ::asinhl;

using ::atanh;
using ::atanhf;
using ::atanhl;

using ::cbrt;
using ::cbrtf;
using ::cbrtl;

using ::copysign;
using ::copysignf;
using ::copysignl;

using ::erf;
using ::erff;
using ::erfl;

using ::erfc;
using ::erfcf;
using ::erfcl;

using ::exp2;
using ::exp2f;
using ::exp2l;

using ::expm1;
using ::expm1f;
using ::expm1l;

using ::fdim;
using ::fdimf;
using ::fdiml;

using ::fma;
using ::fmaf;
using ::fmal;

using ::fmax;
using ::fmaxf;
using ::fmaxl;

using ::fmin;
using ::fminf;
using ::fminl;

using ::hypot;
using ::hypotf;
using ::hypotl;

using ::ilogb;
using ::ilogbf;
using ::ilogbl;

using ::lgamma;
using ::lgammaf;
using ::lgammal;

using ::llrint;
using ::llrintf;
using ::llrintl;

using ::llround;
using ::llroundf;
using ::llroundl;

using ::log1p;
using ::log1pf;
using ::log1pl;

using ::log2;
using ::log2f;
using ::log2l;

using ::logb;
using ::logbf;
using ::logbl;

using ::lrint;
using ::lrintf;
using ::lrintl;

using ::lround;
using ::lroundf;
using ::lroundl;

using ::nan;
using ::nanf;
using ::nanl;

using ::nearbyint;
using ::nearbyintf;
using ::nearbyintl;

using ::nextafter;
using ::nextafterf;
using ::nextafterl;

using ::nexttoward;
using ::nexttowardf;
using ::nexttowardl;

using ::remainder;
using ::remainderf;
using ::remainderl;

using ::remquo;
using ::remquof;
using ::remquol;

using ::rint;
using ::rintf;
using ::rintl;

using ::round;
using ::roundf;
using ::roundl;

using ::scalbln;
using ::scalblnf;
using ::scalblnl;

using ::scalbn;
using ::scalbnf;
using ::scalbnl;

using ::tgamma;
using ::tgammaf;
using ::tgammal;

using ::trunc;
using ::truncf;
using ::truncl;

constexpr float acosh(float __x) { return __builtin_acoshf(__x); }

constexpr long double acosh(long double __x) { return __builtin_acoshl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
acosh(_Tp __x) {
return __builtin_acosh(__x);
}

constexpr float asinh(float __x) { return __builtin_asinhf(__x); }

constexpr long double asinh(long double __x) { return __builtin_asinhl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
asinh(_Tp __x) {
return __builtin_asinh(__x);
}

constexpr float atanh(float __x) { return __builtin_atanhf(__x); }

constexpr long double atanh(long double __x) { return __builtin_atanhl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
atanh(_Tp __x) {
return __builtin_atanh(__x);
}

constexpr float cbrt(float __x) { return __builtin_cbrtf(__x); }

constexpr long double cbrt(long double __x) { return __builtin_cbrtl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
cbrt(_Tp __x) {
return __builtin_cbrt(__x);
}

constexpr float copysign(float __x, float __y) {
return __builtin_copysignf(__x, __y);
}

constexpr long double copysign(long double __x, long double __y) {
return __builtin_copysignl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(
_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return copysign(__type(__x), __type(__y));
}

constexpr float erf(float __x) { return __builtin_erff(__x); }

constexpr long double erf(long double __x) { return __builtin_erfl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
erf(_Tp __x) {
return __builtin_erf(__x);
}

constexpr float erfc(float __x) { return __builtin_erfcf(__x); }

constexpr long double erfc(long double __x) { return __builtin_erfcl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
erfc(_Tp __x) {
return __builtin_erfc(__x);
}

constexpr float exp2(float __x) { return __builtin_exp2f(__x); }

constexpr long double exp2(long double __x) { return __builtin_exp2l(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
exp2(_Tp __x) {
return __builtin_exp2(__x);
}

constexpr float expm1(float __x) { return __builtin_expm1f(__x); }

constexpr long double expm1(long double __x) { return __builtin_expm1l(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
expm1(_Tp __x) {
return __builtin_expm1(__x);
}

constexpr float fdim(float __x, float __y) {
return __builtin_fdimf(__x, __y);
}

constexpr long double fdim(long double __x, long double __y) {
return __builtin_fdiml(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x,
_Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return fdim(__type(__x), __type(__y));
}

constexpr float fma(float __x, float __y, float __z) {
return __builtin_fmaf(__x, __y, __z);
}

constexpr long double fma(long double __x, long double __y, long double __z) {
return __builtin_fmal(__x, __y, __z);
}

template <typename _Tp, typename _Up, typename _Vp>
constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(
_Tp __x, _Up __y, _Vp __z) {
typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
return fma(__type(__x), __type(__y), __type(__z));
}

constexpr float fmax(float __x, float __y) {
return __builtin_fmaxf(__x, __y);
}

constexpr long double fmax(long double __x, long double __y) {
return __builtin_fmaxl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x,
_Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return fmax(__type(__x), __type(__y));
}

constexpr float fmin(float __x, float __y) {
return __builtin_fminf(__x, __y);
}

constexpr long double fmin(long double __x, long double __y) {
return __builtin_fminl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x,
_Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return fmin(__type(__x), __type(__y));
}

constexpr float hypot(float __x, float __y) {
return __builtin_hypotf(__x, __y);
}

constexpr long double hypot(long double __x, long double __y) {
return __builtin_hypotl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x,
_Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return hypot(__type(__x), __type(__y));
}

constexpr int ilogb(float __x) { return __builtin_ilogbf(__x); }

constexpr int ilogb(long double __x) { return __builtin_ilogbl(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type
ilogb(_Tp __x) {
return __builtin_ilogb(__x);
}

constexpr float lgamma(float __x) { return __builtin_lgammaf(__x); }

constexpr long double lgamma(long double __x) {
return __builtin_lgammal(__x);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
lgamma(_Tp __x) {
return __builtin_lgamma(__x);
}

constexpr long long llrint(float __x) { return __builtin_llrintf(__x); }

constexpr long long llrint(long double __x) { return __builtin_llrintl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
long long>::__type
llrint(_Tp __x) {
return __builtin_llrint(__x);
}

constexpr long long llround(float __x) { return __builtin_llroundf(__x); }

constexpr long long llround(long double __x) {
return __builtin_llroundl(__x);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
long long>::__type
llround(_Tp __x) {
return __builtin_llround(__x);
}

constexpr float log1p(float __x) { return __builtin_log1pf(__x); }

constexpr long double log1p(long double __x) { return __builtin_log1pl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
log1p(_Tp __x) {
return __builtin_log1p(__x);
}

constexpr float log2(float __x) { return __builtin_log2f(__x); }

constexpr long double log2(long double __x) { return __builtin_log2l(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
log2(_Tp __x) {
return __builtin_log2(__x);
}

constexpr float logb(float __x) { return __builtin_logbf(__x); }

constexpr long double logb(long double __x) { return __builtin_logbl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
logb(_Tp __x) {
return __builtin_logb(__x);
}

constexpr long lrint(float __x) { return __builtin_lrintf(__x); }

constexpr long lrint(long double __x) { return __builtin_lrintl(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type
lrint(_Tp __x) {
return __builtin_lrint(__x);
}

constexpr long lround(float __x) { return __builtin_lroundf(__x); }

constexpr long lround(long double __x) { return __builtin_lroundl(__x); }

template <typename _Tp>
constexpr
typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type
lround(_Tp __x) {
return __builtin_lround(__x);
}

constexpr float nearbyint(float __x) { return __builtin_nearbyintf(__x); }

constexpr long double nearbyint(long double __x) {
return __builtin_nearbyintl(__x);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
nearbyint(_Tp __x) {
return __builtin_nearbyint(__x);
}

constexpr float nextafter(float __x, float __y) {
return __builtin_nextafterf(__x, __y);
}

constexpr long double nextafter(long double __x, long double __y) {
return __builtin_nextafterl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(
_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return nextafter(__type(__x), __type(__y));
}

constexpr float nexttoward(float __x, long double __y) {
return __builtin_nexttowardf(__x, __y);
}

constexpr long double nexttoward(long double __x, long double __y) {
return __builtin_nexttowardl(__x, __y);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
nexttoward(_Tp __x, long double __y) {
return __builtin_nexttoward(__x, __y);
}

constexpr float remainder(float __x, float __y) {
return __builtin_remainderf(__x, __y);
}

constexpr long double remainder(long double __x, long double __y) {
return __builtin_remainderl(__x, __y);
}

template <typename _Tp, typename _Up>
constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(
_Tp __x, _Up __y) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return remainder(__type(__x), __type(__y));
}

inline float remquo(float __x, float __y, int *__pquo) {
return __builtin_remquof(__x, __y, __pquo);
}

inline long double remquo(long double __x, long double __y, int *__pquo) {
return __builtin_remquol(__x, __y, __pquo);
}

template <typename _Tp, typename _Up>
inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(
_Tp __x, _Up __y, int *__pquo) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
return remquo(__type(__x), __type(__y), __pquo);
}

constexpr float rint(float __x) { return __builtin_rintf(__x); }

constexpr long double rint(long double __x) { return __builtin_rintl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
rint(_Tp __x) {
return __builtin_rint(__x);
}

constexpr float round(float __x) { return __builtin_roundf(__x); }

constexpr long double round(long double __x) { return __builtin_roundl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
round(_Tp __x) {
return __builtin_round(__x);
}

constexpr float scalbln(float __x, long __ex) {
return __builtin_scalblnf(__x, __ex);
}

constexpr long double scalbln(long double __x, long __ex) {
return __builtin_scalblnl(__x, __ex);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
scalbln(_Tp __x, long __ex) {
return __builtin_scalbln(__x, __ex);
}

constexpr float scalbn(float __x, int __ex) {
return __builtin_scalbnf(__x, __ex);
}

constexpr long double scalbn(long double __x, int __ex) {
return __builtin_scalbnl(__x, __ex);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
scalbn(_Tp __x, int __ex) {
return __builtin_scalbn(__x, __ex);
}

constexpr float tgamma(float __x) { return __builtin_tgammaf(__x); }

constexpr long double tgamma(long double __x) {
return __builtin_tgammal(__x);
}

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
tgamma(_Tp __x) {
return __builtin_tgamma(__x);
}

constexpr float trunc(float __x) { return __builtin_truncf(__x); }

constexpr long double trunc(long double __x) { return __builtin_truncl(__x); }

template <typename _Tp>
constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
double>::__type
trunc(_Tp __x) {
return __builtin_trunc(__x);
}
template <typename _Tp> inline _Tp __hypot3(_Tp __x, _Tp __y, _Tp __z) {
__x = std::abs(__x);
__y = std::abs(__y);
__z = std::abs(__z);
if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
return __a *
std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) +
(__z / __a) * (__z / __a));
else
return {};
}

inline float hypot(float __x, float __y, float __z) {
return std::__hypot3<float>(__x, __y, __z);
}

inline double hypot(double __x, double __y, double __z) {
return std::__hypot3<double>(__x, __y, __z);
}

inline long double hypot(long double __x, long double __y, long double __z) {
return std::__hypot3<long double>(__x, __y, __z);
}

template <typename _Tp, typename _Up, typename _Vp>
__gnu_cxx::__promoted_t<_Tp, _Up, _Vp> hypot(_Tp __x, _Up __y, _Vp __z) {
using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
return std::__hypot3<__type>(__x, __y, __z);
}

} // namespace std

#pragma GCC visibility push(default)

namespace std __attribute__((__visibility__("default"))) {

enum float_round_style {
round_indeterminate = -1,
round_toward_zero = 0,
round_to_nearest = 1,
round_toward_infinity = 2,
round_toward_neg_infinity = 3
};

enum float_denorm_style {

denorm_indeterminate = -1,

denorm_absent = 0,

denorm_present = 1
};
struct __numeric_limits_base {

static constexpr bool is_specialized = false;

static constexpr int digits = 0;

static constexpr int digits10 = 0;

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;

static constexpr bool is_integer = false;

static constexpr bool is_exact = false;

static constexpr int radix = 0;

static constexpr int min_exponent = 0;

static constexpr int min_exponent10 = 0;

static constexpr int max_exponent = 0;

static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;

static constexpr bool has_quiet_NaN = false;

static constexpr bool has_signaling_NaN = false;

static constexpr float_denorm_style has_denorm = denorm_absent;

static constexpr bool has_denorm_loss = false;

static constexpr bool is_iec559 = false;

static constexpr bool is_bounded = false;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;

static constexpr bool tinyness_before = false;

static constexpr float_round_style round_style = round_toward_zero;
};
template <typename _Tp> struct numeric_limits : public __numeric_limits_base {

static constexpr _Tp min() noexcept { return _Tp(); }

static constexpr _Tp max() noexcept { return _Tp(); }

static constexpr _Tp lowest() noexcept { return _Tp(); }

static constexpr _Tp epsilon() noexcept { return _Tp(); }

static constexpr _Tp round_error() noexcept { return _Tp(); }

static constexpr _Tp infinity() noexcept { return _Tp(); }

static constexpr _Tp quiet_NaN() noexcept { return _Tp(); }

static constexpr _Tp signaling_NaN() noexcept { return _Tp(); }

static constexpr _Tp denorm_min() noexcept { return _Tp(); }
};

template <typename _Tp>
struct numeric_limits<const _Tp> : public numeric_limits<_Tp> {};

template <typename _Tp>
struct numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {};

template <typename _Tp>
struct numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {};
template <> struct numeric_limits<bool> {
static constexpr bool is_specialized = true;

static constexpr bool min() noexcept { return false; }

static constexpr bool max() noexcept { return true; }

static constexpr bool lowest() noexcept { return min(); }

static constexpr int digits = 1;
static constexpr int digits10 = 0;

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr bool epsilon() noexcept { return false; }

static constexpr bool round_error() noexcept { return false; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr bool infinity() noexcept { return false; }

static constexpr bool quiet_NaN() noexcept { return false; }

static constexpr bool signaling_NaN() noexcept { return false; }

static constexpr bool denorm_min() noexcept { return false; }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<char> {
static constexpr bool is_specialized = true;

static constexpr char min() noexcept {
return (
((char)(-1) < 0)
? -(((char)(-1) < 0)
? (((((char)1
<< ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(char)0) -
1
: (char)0);
}

static constexpr char max() noexcept {
return (
((char)(-1) < 0)
? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1)
<< 1) +
1)
: ~(char)0);
}

static constexpr char lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
static constexpr int digits10 =
((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = ((char)(-1) < 0);
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr char epsilon() noexcept { return 0; }

static constexpr char round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr char infinity() noexcept { return char(); }

static constexpr char quiet_NaN() noexcept { return char(); }

static constexpr char signaling_NaN() noexcept { return char(); }

static constexpr char denorm_min() noexcept { return static_cast<char>(0); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = !is_signed;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<signed char> {
static constexpr bool is_specialized = true;

static constexpr signed char min() noexcept { return -0x7f - 1; }

static constexpr signed char max() noexcept { return 0x7f; }

static constexpr signed char lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(signed char) * 8 - ((signed char)(-1) < 0));
static constexpr int digits10 =
((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr signed char epsilon() noexcept { return 0; }

static constexpr signed char round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr signed char infinity() noexcept {
return static_cast<signed char>(0);
}

static constexpr signed char quiet_NaN() noexcept {
return static_cast<signed char>(0);
}

static constexpr signed char signaling_NaN() noexcept {
return static_cast<signed char>(0);
}

static constexpr signed char denorm_min() noexcept {
return static_cast<signed char>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<unsigned char> {
static constexpr bool is_specialized = true;

static constexpr unsigned char min() noexcept { return 0; }

static constexpr unsigned char max() noexcept { return 0x7f * 2U + 1; }

static constexpr unsigned char lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
static constexpr int digits10 =
((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr unsigned char epsilon() noexcept { return 0; }

static constexpr unsigned char round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr unsigned char infinity() noexcept {
return static_cast<unsigned char>(0);
}

static constexpr unsigned char quiet_NaN() noexcept {
return static_cast<unsigned char>(0);
}

static constexpr unsigned char signaling_NaN() noexcept {
return static_cast<unsigned char>(0);
}

static constexpr unsigned char denorm_min() noexcept {
return static_cast<unsigned char>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<wchar_t> {
static constexpr bool is_specialized = true;

static constexpr wchar_t min() noexcept {
return (((wchar_t)(-1) < 0)
? -(((wchar_t)(-1) < 0)
? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 -
((wchar_t)(-1) < 0)) -
1)) -
1)
<< 1) +
1)
: ~(wchar_t)0) -
1
: (wchar_t)0);
}

static constexpr wchar_t max() noexcept {
return (((wchar_t)(-1) < 0)
? (((((wchar_t)1
<< ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(wchar_t)0);
}

static constexpr wchar_t lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
static constexpr int digits10 =
((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = ((wchar_t)(-1) < 0);
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr wchar_t epsilon() noexcept { return 0; }

static constexpr wchar_t round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr wchar_t infinity() noexcept { return wchar_t(); }

static constexpr wchar_t quiet_NaN() noexcept { return wchar_t(); }

static constexpr wchar_t signaling_NaN() noexcept { return wchar_t(); }

static constexpr wchar_t denorm_min() noexcept { return wchar_t(); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = !is_signed;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
template <> struct numeric_limits<char16_t> {
static constexpr bool is_specialized = true;

static constexpr char16_t min() noexcept {
return (((char16_t)(-1) < 0)
? -(((char16_t)(-1) < 0)
? (((((char16_t)1 << ((sizeof(char16_t) * 8 -
((char16_t)(-1) < 0)) -
1)) -
1)
<< 1) +
1)
: ~(char16_t)0) -
1
: (char16_t)0);
}

static constexpr char16_t max() noexcept {
return (
((char16_t)(-1) < 0)
? (((((char16_t)1
<< ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(char16_t)0);
}

static constexpr char16_t lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
static constexpr int digits10 =
((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
static constexpr int max_digits10 = 0;
static constexpr bool is_signed = ((char16_t)(-1) < 0);
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr char16_t epsilon() noexcept { return 0; }

static constexpr char16_t round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr char16_t infinity() noexcept { return char16_t(); }

static constexpr char16_t quiet_NaN() noexcept { return char16_t(); }

static constexpr char16_t signaling_NaN() noexcept { return char16_t(); }

static constexpr char16_t denorm_min() noexcept { return char16_t(); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = !is_signed;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<char32_t> {
static constexpr bool is_specialized = true;

static constexpr char32_t min() noexcept {
return (((char32_t)(-1) < 0)
? -(((char32_t)(-1) < 0)
? (((((char32_t)1 << ((sizeof(char32_t) * 8 -
((char32_t)(-1) < 0)) -
1)) -
1)
<< 1) +
1)
: ~(char32_t)0) -
1
: (char32_t)0);
}

static constexpr char32_t max() noexcept {
return (
((char32_t)(-1) < 0)
? (((((char32_t)1
<< ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(char32_t)0);
}

static constexpr char32_t lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
static constexpr int digits10 =
((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
static constexpr int max_digits10 = 0;
static constexpr bool is_signed = ((char32_t)(-1) < 0);
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr char32_t epsilon() noexcept { return 0; }

static constexpr char32_t round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr char32_t infinity() noexcept { return char32_t(); }

static constexpr char32_t quiet_NaN() noexcept { return char32_t(); }

static constexpr char32_t signaling_NaN() noexcept { return char32_t(); }

static constexpr char32_t denorm_min() noexcept { return char32_t(); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = !is_signed;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<short> {
static constexpr bool is_specialized = true;

static constexpr short min() noexcept { return -0x7fff - 1; }

static constexpr short max() noexcept { return 0x7fff; }

static constexpr short lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
static constexpr int digits10 =
((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr short epsilon() noexcept { return 0; }

static constexpr short round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr short infinity() noexcept { return short(); }

static constexpr short quiet_NaN() noexcept { return short(); }

static constexpr short signaling_NaN() noexcept { return short(); }

static constexpr short denorm_min() noexcept { return short(); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<unsigned short> {
static constexpr bool is_specialized = true;

static constexpr unsigned short min() noexcept { return 0; }

static constexpr unsigned short max() noexcept { return 0x7fff * 2U + 1; }

static constexpr unsigned short lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
static constexpr int digits10 =
((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L /
2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr unsigned short epsilon() noexcept { return 0; }

static constexpr unsigned short round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr unsigned short infinity() noexcept {
return static_cast<unsigned short>(0);
}

static constexpr unsigned short quiet_NaN() noexcept {
return static_cast<unsigned short>(0);
}

static constexpr unsigned short signaling_NaN() noexcept {
return static_cast<unsigned short>(0);
}

static constexpr unsigned short denorm_min() noexcept {
return static_cast<unsigned short>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<int> {
static constexpr bool is_specialized = true;

static constexpr int min() noexcept { return -0x7fffffff - 1; }

static constexpr int max() noexcept { return 0x7fffffff; }

static constexpr int lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
static constexpr int digits10 =
((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr int epsilon() noexcept { return 0; }

static constexpr int round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr int infinity() noexcept { return static_cast<int>(0); }

static constexpr int quiet_NaN() noexcept { return static_cast<int>(0); }

static constexpr int signaling_NaN() noexcept {
return static_cast<int>(0);
}

static constexpr int denorm_min() noexcept { return static_cast<int>(0); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<unsigned int> {
static constexpr bool is_specialized = true;

static constexpr unsigned int min() noexcept { return 0; }

static constexpr unsigned int max() noexcept { return 0x7fffffff * 2U + 1; }

static constexpr unsigned int lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
static constexpr int digits10 =
((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr unsigned int epsilon() noexcept { return 0; }

static constexpr unsigned int round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr unsigned int infinity() noexcept {
return static_cast<unsigned int>(0);
}

static constexpr unsigned int quiet_NaN() noexcept {
return static_cast<unsigned int>(0);
}

static constexpr unsigned int signaling_NaN() noexcept {
return static_cast<unsigned int>(0);
}

static constexpr unsigned int denorm_min() noexcept {
return static_cast<unsigned int>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<long> {
static constexpr bool is_specialized = true;

static constexpr long min() noexcept { return -0x7fffffffffffffffL - 1; }

static constexpr long max() noexcept { return 0x7fffffffffffffffL; }

static constexpr long lowest() noexcept { return min(); }

static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
static constexpr int digits10 =
((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr long epsilon() noexcept { return 0; }

static constexpr long round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr long infinity() noexcept { return static_cast<long>(0); }

static constexpr long quiet_NaN() noexcept { return static_cast<long>(0); }

static constexpr long signaling_NaN() noexcept {
return static_cast<long>(0);
}

static constexpr long denorm_min() noexcept { return static_cast<long>(0); }

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<unsigned long> {
static constexpr bool is_specialized = true;

static constexpr unsigned long min() noexcept { return 0; }

static constexpr unsigned long max() noexcept {
return 0x7fffffffffffffffL * 2UL + 1;
}

static constexpr unsigned long lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
static constexpr int digits10 =
((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr unsigned long epsilon() noexcept { return 0; }

static constexpr unsigned long round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr unsigned long infinity() noexcept {
return static_cast<unsigned long>(0);
}

static constexpr unsigned long quiet_NaN() noexcept {
return static_cast<unsigned long>(0);
}

static constexpr unsigned long signaling_NaN() noexcept {
return static_cast<unsigned long>(0);
}

static constexpr unsigned long denorm_min() noexcept {
return static_cast<unsigned long>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<long long> {
static constexpr bool is_specialized = true;

static constexpr long long min() noexcept {
return -0x7fffffffffffffffLL - 1;
}

static constexpr long long max() noexcept { return 0x7fffffffffffffffLL; }

static constexpr long long lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(long long) * 8 - ((long long)(-1) < 0));
static constexpr int digits10 =
((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr long long epsilon() noexcept { return 0; }

static constexpr long long round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr long long infinity() noexcept {
return static_cast<long long>(0);
}

static constexpr long long quiet_NaN() noexcept {
return static_cast<long long>(0);
}

static constexpr long long signaling_NaN() noexcept {
return static_cast<long long>(0);
}

static constexpr long long denorm_min() noexcept {
return static_cast<long long>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};

template <> struct numeric_limits<unsigned long long> {
static constexpr bool is_specialized = true;

static constexpr unsigned long long min() noexcept { return 0; }

static constexpr unsigned long long max() noexcept {
return 0x7fffffffffffffffLL * 2ULL + 1;
}

static constexpr unsigned long long lowest() noexcept { return min(); }

static constexpr int digits =
(sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
static constexpr int digits10 =
((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) *
643L / 2136);

static constexpr int max_digits10 = 0;

static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;

static constexpr unsigned long long epsilon() noexcept { return 0; }

static constexpr unsigned long long round_error() noexcept { return 0; }

static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;

static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr unsigned long long infinity() noexcept {
return static_cast<unsigned long long>(0);
}

static constexpr unsigned long long quiet_NaN() noexcept {
return static_cast<unsigned long long>(0);
}

static constexpr unsigned long long signaling_NaN() noexcept {
return static_cast<unsigned long long>(0);
}

static constexpr unsigned long long denorm_min() noexcept {
return static_cast<unsigned long long>(0);
}

static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;

static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
__extension__ template <> struct numeric_limits<__int128> {
static constexpr bool is_specialized = true;
static constexpr __int128 min() noexcept {
return (
((__int128)(-1) < 0)
? -(((__int128)(-1) < 0)
? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(__int128)0) -
1
: (__int128)0);
}
static constexpr __int128 max() noexcept {
return (((__int128)(-1) < 0)
? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1)
<< 1) +
1)
: ~(__int128)0);
}
static constexpr int digits = 128 - 1;
static constexpr int digits10 = (128 - 1) * 643L / 2136;
static constexpr bool is_signed = true;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;
static constexpr __int128 epsilon() noexcept { return 0; }
static constexpr __int128 round_error() noexcept { return 0; }
static constexpr __int128 lowest() noexcept { return min(); }
static constexpr int max_digits10 = 0;
static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;
static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;
static constexpr __int128 infinity() noexcept {
return static_cast<__int128>(0);
}
static constexpr __int128 quiet_NaN() noexcept {
return static_cast<__int128>(0);
}
static constexpr __int128 signaling_NaN() noexcept {
return static_cast<__int128>(0);
}
static constexpr __int128 denorm_min() noexcept {
return static_cast<__int128>(0);
}
static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;
static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
__extension__ template <> struct numeric_limits<unsigned __int128> {
static constexpr bool is_specialized = true;
static constexpr unsigned __int128 min() noexcept { return 0; }
static constexpr unsigned __int128 max() noexcept {
return (((unsigned __int128)(-1) < 0)
? (((((unsigned __int128)1
<< ((128 - ((unsigned __int128)(-1) < 0)) - 1)) -
1)
<< 1) +
1)
: ~(unsigned __int128)0);
}
static constexpr unsigned __int128 lowest() noexcept { return min(); }
static constexpr int max_digits10 = 0;
static constexpr int digits = 128;
static constexpr int digits10 = 128 * 643L / 2136;
static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;
static constexpr unsigned __int128 epsilon() noexcept { return 0; }
static constexpr unsigned __int128 round_error() noexcept { return 0; }
static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;
static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr float_denorm_style has_denorm = denorm_absent;
static constexpr bool has_denorm_loss = false;
static constexpr unsigned __int128 infinity() noexcept {
return static_cast<unsigned __int128>(0);
}
static constexpr unsigned __int128 quiet_NaN() noexcept {
return static_cast<unsigned __int128>(0);
}
static constexpr unsigned __int128 signaling_NaN() noexcept {
return static_cast<unsigned __int128>(0);
}
static constexpr unsigned __int128 denorm_min() noexcept {
return static_cast<unsigned __int128>(0);
}
static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = true;
static constexpr bool traps = true;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
template <> struct numeric_limits<float> {
static constexpr bool is_specialized = true;

static constexpr float min() noexcept {
return 1.17549435082228750796873653722224568e-38F;
}

static constexpr float max() noexcept {
return 3.40282346638528859811704183484516925e+38F;
}

static constexpr float lowest() noexcept {
return -3.40282346638528859811704183484516925e+38F;
}

static constexpr int digits = 24;
static constexpr int digits10 = 6;

static constexpr int max_digits10 = (2 + (24) * 643L / 2136);

static constexpr bool is_signed = true;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int radix = 2;

static constexpr float epsilon() noexcept {
return 1.19209289550781250000000000000000000e-7F;
}

static constexpr float round_error() noexcept { return 0.5F; }

static constexpr int min_exponent = (-125);
static constexpr int min_exponent10 = (-37);
static constexpr int max_exponent = 128;
static constexpr int max_exponent10 = 38;

static constexpr bool has_infinity = 1;
static constexpr bool has_quiet_NaN = 1;
static constexpr bool has_signaling_NaN = has_quiet_NaN;
static constexpr float_denorm_style has_denorm =
bool(1) ? denorm_present : denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr float infinity() noexcept { return __builtin_huge_valf(); }

static constexpr float quiet_NaN() noexcept { return __builtin_nanf(""); }

static constexpr float signaling_NaN() noexcept {
return __builtin_nansf("");
}

static constexpr float denorm_min() noexcept {
return 1.40129846432481707092372958328991613e-45F;
}

static constexpr bool is_iec559 =
has_infinity && has_quiet_NaN && has_denorm == denorm_present;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_to_nearest;
};

template <> struct numeric_limits<double> {
static constexpr bool is_specialized = true;

static constexpr double min() noexcept {
return double(2.22507385850720138309023271733240406e-308L);
}

static constexpr double max() noexcept {
return double(1.79769313486231570814527423731704357e+308L);
}

static constexpr double lowest() noexcept {
return -double(1.79769313486231570814527423731704357e+308L);
}

static constexpr int digits = 53;
static constexpr int digits10 = 15;

static constexpr int max_digits10 = (2 + (53) * 643L / 2136);

static constexpr bool is_signed = true;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int radix = 2;

static constexpr double epsilon() noexcept {
return double(2.22044604925031308084726333618164062e-16L);
}

static constexpr double round_error() noexcept { return 0.5; }

static constexpr int min_exponent = (-1021);
static constexpr int min_exponent10 = (-307);
static constexpr int max_exponent = 1024;
static constexpr int max_exponent10 = 308;

static constexpr bool has_infinity = 1;
static constexpr bool has_quiet_NaN = 1;
static constexpr bool has_signaling_NaN = has_quiet_NaN;
static constexpr float_denorm_style has_denorm =
bool(1) ? denorm_present : denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr double infinity() noexcept { return __builtin_huge_val(); }

static constexpr double quiet_NaN() noexcept { return __builtin_nan(""); }

static constexpr double signaling_NaN() noexcept {
return __builtin_nans("");
}

static constexpr double denorm_min() noexcept {
return double(4.94065645841246544176568792868221372e-324L);
}

static constexpr bool is_iec559 =
has_infinity && has_quiet_NaN && has_denorm == denorm_present;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_to_nearest;
};

template <> struct numeric_limits<long double> {
static constexpr bool is_specialized = true;

static constexpr long double min() noexcept {
return 3.36210314311209350626267781732175260e-4932L;
}

static constexpr long double max() noexcept {
return 1.18973149535723176502126385303097021e+4932L;
}

static constexpr long double lowest() noexcept {
return -1.18973149535723176502126385303097021e+4932L;
}

static constexpr int digits = 64;
static constexpr int digits10 = 18;

static constexpr int max_digits10 = (2 + (64) * 643L / 2136);

static constexpr bool is_signed = true;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int radix = 2;

static constexpr long double epsilon() noexcept {
return 1.08420217248550443400745280086994171e-19L;
}

static constexpr long double round_error() noexcept { return 0.5L; }

static constexpr int min_exponent = (-16381);
static constexpr int min_exponent10 = (-4931);
static constexpr int max_exponent = 16384;
static constexpr int max_exponent10 = 4932;

static constexpr bool has_infinity = 1;
static constexpr bool has_quiet_NaN = 1;
static constexpr bool has_signaling_NaN = has_quiet_NaN;
static constexpr float_denorm_style has_denorm =
bool(1) ? denorm_present : denorm_absent;
static constexpr bool has_denorm_loss = false;

static constexpr long double infinity() noexcept {
return __builtin_huge_vall();
}

static constexpr long double quiet_NaN() noexcept {
return __builtin_nanl("");
}

static constexpr long double signaling_NaN() noexcept {
return __builtin_nansl("");
}

static constexpr long double denorm_min() noexcept {
return 3.64519953188247460252840593361941982e-4951L;
}

static constexpr bool is_iec559 =
has_infinity && has_quiet_NaN && has_denorm == denorm_present;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;

static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_to_nearest;
};

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __detail {

template <typename _Tp> struct __floating_point_constant {
static const _Tp __value;
};

template <typename _Tp> struct __numeric_constants {

static _Tp __pi() throw() {
return static_cast<_Tp>(3.1415926535897932384626433832795029L);
}

static _Tp __pi_2() throw() {
return static_cast<_Tp>(1.5707963267948966192313216916397514L);
}

static _Tp __pi_3() throw() {
return static_cast<_Tp>(1.0471975511965977461542144610931676L);
}

static _Tp __pi_4() throw() {
return static_cast<_Tp>(0.7853981633974483096156608458198757L);
}

static _Tp __1_pi() throw() {
return static_cast<_Tp>(0.3183098861837906715377675267450287L);
}

static _Tp __2_sqrtpi() throw() {
return static_cast<_Tp>(1.1283791670955125738961589031215452L);
}

static _Tp __sqrt2() throw() {
return static_cast<_Tp>(1.4142135623730950488016887242096981L);
}

static _Tp __sqrt3() throw() {
return static_cast<_Tp>(1.7320508075688772935274463415058723L);
}

static _Tp __sqrtpio2() throw() {
return static_cast<_Tp>(1.2533141373155002512078826424055226L);
}

static _Tp __sqrt1_2() throw() {
return static_cast<_Tp>(0.7071067811865475244008443621048490L);
}

static _Tp __lnpi() throw() {
return static_cast<_Tp>(1.1447298858494001741434273513530587L);
}

static _Tp __gamma_e() throw() {
return static_cast<_Tp>(0.5772156649015328606065120900824024L);
}

static _Tp __euler() throw() {
return static_cast<_Tp>(2.7182818284590452353602874713526625L);
}
};
template <typename _Tp> inline bool __isnan(_Tp __x) {
return std::isnan(__x);
}
} // namespace __detail

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __bernoulli_series(unsigned int __n) {

static const _Tp __num[28] = {_Tp(1UL),
-_Tp(1UL) / _Tp(2UL),
_Tp(1UL) / _Tp(6UL),
_Tp(0UL),
-_Tp(1UL) / _Tp(30UL),
_Tp(0UL),
_Tp(1UL) / _Tp(42UL),
_Tp(0UL),
-_Tp(1UL) / _Tp(30UL),
_Tp(0UL),
_Tp(5UL) / _Tp(66UL),
_Tp(0UL),
-_Tp(691UL) / _Tp(2730UL),
_Tp(0UL),
_Tp(7UL) / _Tp(6UL),
_Tp(0UL),
-_Tp(3617UL) / _Tp(510UL),
_Tp(0UL),
_Tp(43867UL) / _Tp(798UL),
_Tp(0UL),
-_Tp(174611) / _Tp(330UL),
_Tp(0UL),
_Tp(854513UL) / _Tp(138UL),
_Tp(0UL),
-_Tp(236364091UL) / _Tp(2730UL),
_Tp(0UL),
_Tp(8553103UL) / _Tp(6UL),
_Tp(0UL)};

if (__n == 0)
return _Tp(1);

if (__n == 1)
return -_Tp(1) / _Tp(2);

if (__n % 2 == 1)
return _Tp(0);

if (__n < 28)
return __num[__n];

_Tp __fact = _Tp(1);
if ((__n / 2) % 2 == 0)
__fact *= _Tp(-1);
for (unsigned int __k = 1; __k <= __n; ++__k)
__fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
__fact *= _Tp(2);

_Tp __sum = _Tp(0);
for (unsigned int __i = 1; __i < 1000; ++__i) {
_Tp __term = std::pow(_Tp(__i), -_Tp(__n));
if (__term < std::numeric_limits<_Tp>::epsilon())
break;
__sum += __term;
}

return __fact * __sum;
}
template <typename _Tp> inline _Tp __bernoulli(int __n) {
return __bernoulli_series<_Tp>(__n);
}
template <typename _Tp> _Tp __log_gamma_bernoulli(_Tp __x) {
_Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x +
_Tp(0.5L) * std::log(_Tp(2) * __numeric_constants<_Tp>::__pi());

const _Tp __xx = __x * __x;
_Tp __help = _Tp(1) / __x;
for (unsigned int __i = 1; __i < 20; ++__i) {
const _Tp __2i = _Tp(2 * __i);
__help /= __2i * (__2i - _Tp(1)) * __xx;
__lg += __bernoulli<_Tp>(2 * __i) * __help;
}

return __lg;
}
template <typename _Tp> _Tp __log_gamma_lanczos(_Tp __x) {
const _Tp __xm1 = __x - _Tp(1);

static const _Tp __lanczos_cheb_7[9] = {
_Tp(0.99999999999980993227684700473478L),
_Tp(676.520368121885098567009190444019L),
_Tp(-1259.13921672240287047156078755283L),
_Tp(771.3234287776530788486528258894L),
_Tp(-176.61502916214059906584551354L),
_Tp(12.507343278686904814458936853L),
_Tp(-0.13857109526572011689554707L),
_Tp(9.984369578019570859563e-6L),
_Tp(1.50563273514931155834e-7L)};

static const _Tp __LOGROOT2PI = _Tp(0.9189385332046727417803297364056176L);

_Tp __sum = __lanczos_cheb_7[0];
for (unsigned int __k = 1; __k < 9; ++__k)
__sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

const _Tp __term1 =
(__xm1 + _Tp(0.5L)) *
std::log((__xm1 + _Tp(7.5L)) / __numeric_constants<_Tp>::__euler());
const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
const _Tp __result = __term1 + (__term2 - _Tp(7));

return __result;
}
template <typename _Tp> _Tp __log_gamma(_Tp __x) {
if (__x > _Tp(0.5L))
return __log_gamma_lanczos(__x);
else {
const _Tp __sin_fact =
std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
if (__sin_fact == _Tp(0))
std::__throw_domain_error(("Argument is nonpositive integer "
"in __log_gamma"));
return __numeric_constants<_Tp>::__lnpi() - std::log(__sin_fact) -
__log_gamma_lanczos(_Tp(1) - __x);
}
}
template <typename _Tp> _Tp __log_gamma_sign(_Tp __x) {
if (__x > _Tp(0))
return _Tp(1);
else {
const _Tp __sin_fact = std::sin(__numeric_constants<_Tp>::__pi() * __x);
if (__sin_fact > _Tp(0))
return (1);
else if (__sin_fact < _Tp(0))
return -_Tp(1);
else
return _Tp(0);
}
}
template <typename _Tp>
_Tp __log_bincoef(unsigned int __n, unsigned int __k) {

static const _Tp __max_bincoeff =
std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

_Tp __coeff = ::std::lgamma(_Tp(1 + __n)) - ::std::lgamma(_Tp(1 + __k)) -
::std::lgamma(_Tp(1 + __n - __k));
}
template <typename _Tp> _Tp __bincoef(unsigned int __n, unsigned int __k) {

static const _Tp __max_bincoeff =
std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
if (__log_coeff > __max_bincoeff)
return std::numeric_limits<_Tp>::quiet_NaN();
else
return std::exp(__log_coeff);
}
template <typename _Tp> inline _Tp __gamma(_Tp __x) {
return std::exp(__log_gamma(__x));
}
template <typename _Tp> _Tp __psi_series(_Tp __x) {
_Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
const unsigned int __max_iter = 100000;
for (unsigned int __k = 1; __k < __max_iter; ++__k) {
const _Tp __term = __x / (__k * (__k + __x));
__sum += __term;
if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
break;
}
return __sum;
}
template <typename _Tp> _Tp __psi_asymp(_Tp __x) {
_Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
const _Tp __xx = __x * __x;
_Tp __xp = __xx;
const unsigned int __max_iter = 100;
for (unsigned int __k = 1; __k < __max_iter; ++__k) {
const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
__sum -= __term;
if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
break;
__xp *= __xx;
}
return __sum;
}
template <typename _Tp> _Tp __psi(_Tp __x) {
const int __n = static_cast<int>(__x + 0.5L);
const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x < _Tp(0)) {
const _Tp __pi = __numeric_constants<_Tp>::__pi();
return __psi(_Tp(1) - __x) -
__pi * std::cos(__pi * __x) / std::sin(__pi * __x);
} else if (__x > _Tp(100))
return __psi_asymp(__x);
else
return __psi_series(__x);
}
template <typename _Tp> _Tp __psi(unsigned int __n, _Tp __x) {
if (__x <= _Tp(0))
std::__throw_domain_error(("Argument out of range "
"in __psi"));
else if (__n == 0)
return __psi(__x);
else {
const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));

_Tp __result = std::exp(__ln_nfact) * __hzeta;
if (__n % 2 == 1)
__result = -__result;
return __result;
}
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp>
void __gamma_temme(_Tp __mu, _Tp &__gam1, _Tp &__gam2, _Tp &__gampl,
_Tp &__gammi) {

__gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
__gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);

if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
__gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
else
__gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

__gam2 = (__gammi + __gampl) / (_Tp(2));

return;
}
template <typename _Tp>
void __bessel_jn(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu, _Tp &__Jpnu,
_Tp &__Npnu) {
if (__x == _Tp(0)) {
if (__nu == _Tp(0)) {
__Jnu = _Tp(1);
__Jpnu = _Tp(0);
} else if (__nu == _Tp(1)) {
__Jnu = _Tp(0);
__Jpnu = _Tp(0.5L);
} else {
__Jnu = _Tp(0);
__Jpnu = _Tp(0);
}
__Nnu = -std::numeric_limits<_Tp>::infinity();
__Npnu = std::numeric_limits<_Tp>::infinity();
return;
}

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
const int __max_iter = 15000;
const _Tp __x_min = _Tp(2);

const int __nl =
(__x < __x_min ? static_cast<int>(__nu + _Tp(0.5L))
: std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

const _Tp __mu = __nu - __nl;
const _Tp __mu2 = __mu * __mu;
const _Tp __xi = _Tp(1) / __x;
const _Tp __xi2 = _Tp(2) * __xi;
_Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
int __isign = 1;
_Tp __h = __nu * __xi;
if (__h < __fp_min)
__h = __fp_min;
_Tp __b = __xi2 * __nu;
_Tp __d = _Tp(0);
_Tp __c = __h;
int __i;
for (__i = 1; __i <= __max_iter; ++__i) {
__b += __xi2;
__d = __b - __d;
if (std::abs(__d) < __fp_min)
__d = __fp_min;
__c = __b - _Tp(1) / __c;
if (std::abs(__c) < __fp_min)
__c = __fp_min;
__d = _Tp(1) / __d;
const _Tp __del = __c * __d;
__h *= __del;
if (__d < _Tp(0))
__isign = -__isign;
if (std::abs(__del - _Tp(1)) < __eps)
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Argument x too large in __bessel_jn; "
"try asymptotic expansion."));
_Tp __Jnul = __isign * __fp_min;
_Tp __Jpnul = __h * __Jnul;
_Tp __Jnul1 = __Jnul;
_Tp __Jpnu1 = __Jpnul;
_Tp __fact = __nu * __xi;
for (int __l = __nl; __l >= 1; --__l) {
const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
__fact -= __xi;
__Jpnul = __fact * __Jnutemp - __Jnul;
__Jnul = __Jnutemp;
}
if (__Jnul == _Tp(0))
__Jnul = __eps;
_Tp __f = __Jpnul / __Jnul;
_Tp __Nmu, __Nnu1, __Npmu, __Jmu;
if (__x < __x_min) {
const _Tp __x2 = __x / _Tp(2);
const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
_Tp __fact =
(std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
_Tp __d = -std::log(__x2);
_Tp __e = __mu * __d;
_Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
_Tp __gam1, __gam2, __gampl, __gammi;
__gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
_Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi()) * __fact *
(__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
__e = std::exp(__e);
_Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
_Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
const _Tp __pimu2 = __pimu / _Tp(2);
_Tp __fact3 =
(std::abs(__pimu2) < __eps ? _Tp(1) : std::sin(__pimu2) / __pimu2);
_Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
_Tp __c = _Tp(1);
__d = -__x2 * __x2;
_Tp __sum = __ff + __r * __q;
_Tp __sum1 = __p;
for (__i = 1; __i <= __max_iter; ++__i) {
__ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
__c *= __d / _Tp(__i);
__p /= _Tp(__i) - __mu;
__q /= _Tp(__i) + __mu;
const _Tp __del = __c * (__ff + __r * __q);
__sum += __del;
const _Tp __del1 = __c * __p - __i * __del;
__sum1 += __del1;
if (std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)))
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Bessel y series failed to converge "
"in __bessel_jn."));
__Nmu = -__sum;
__Nnu1 = -__sum1 * __xi2;
__Npmu = __mu * __xi * __Nmu - __Nnu1;
__Jmu = __w / (__Npmu - __f * __Nmu);
} else {
_Tp __a = _Tp(0.25L) - __mu2;
_Tp __q = _Tp(1);
_Tp __p = -__xi / _Tp(2);
_Tp __br = _Tp(2) * __x;
_Tp __bi = _Tp(2);
_Tp __fact = __a * __xi / (__p * __p + __q * __q);
_Tp __cr = __br + __q * __fact;
_Tp __ci = __bi + __p * __fact;
_Tp __den = __br * __br + __bi * __bi;
_Tp __dr = __br / __den;
_Tp __di = -__bi / __den;
_Tp __dlr = __cr * __dr - __ci * __di;
_Tp __dli = __cr * __di + __ci * __dr;
_Tp __temp = __p * __dlr - __q * __dli;
__q = __p * __dli + __q * __dlr;
__p = __temp;
int __i;
for (__i = 2; __i <= __max_iter; ++__i) {
__a += _Tp(2 * (__i - 1));
__bi += _Tp(2);
__dr = __a * __dr + __br;
__di = __a * __di + __bi;
if (std::abs(__dr) + std::abs(__di) < __fp_min)
__dr = __fp_min;
__fact = __a / (__cr * __cr + __ci * __ci);
__cr = __br + __cr * __fact;
__ci = __bi - __ci * __fact;
if (std::abs(__cr) + std::abs(__ci) < __fp_min)
__cr = __fp_min;
__den = __dr * __dr + __di * __di;
__dr /= __den;
__di /= -__den;
__dlr = __cr * __dr - __ci * __di;
__dli = __cr * __di + __ci * __dr;
__temp = __p * __dlr - __q * __dli;
__q = __p * __dli + __q * __dlr;
__p = __temp;
if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Lentz's method failed "
"in __bessel_jn."));
const _Tp __gam = (__p - __f) / __q;
__Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

__Jmu = ::std::copysign(__Jmu, __Jnul);

__Nmu = __gam * __Jmu;
__Npmu = (__p + __q / __gam) * __Nmu;
__Nnu1 = __mu * __xi * __Nmu - __Npmu;
}
__fact = __Jmu / __Jnul;
__Jnu = __fact * __Jnul1;
__Jpnu = __fact * __Jpnu1;
for (__i = 1; __i <= __nl; ++__i) {
const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
__Nmu = __Nnu1;
__Nnu1 = __Nnutemp;
}
__Nnu = __Nmu;
__Npnu = __nu * __xi * __Nmu - __Nnu1;

return;
}
template <typename _Tp>
void __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu) {
const _Tp __mu = _Tp(4) * __nu * __nu;
const _Tp __8x = _Tp(8) * __x;

_Tp __P = _Tp(0);
_Tp __Q = _Tp(0);

_Tp __k = _Tp(0);
_Tp __term = _Tp(1);

int __epsP = 0;
int __epsQ = 0;

_Tp __eps = std::numeric_limits<_Tp>::epsilon();

do {
__term *=
(__k == 0 ? _Tp(1)
: -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

__epsP = std::abs(__term) < __eps * std::abs(__P);
__P += __term;

__k++;

__term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
__epsQ = std::abs(__term) < __eps * std::abs(__Q);
__Q += __term;

if (__epsP && __epsQ && __k > (__nu / 2.))
break;

__k++;
} while (__k < 1000);

const _Tp __chi =
__x - (__nu + _Tp(0.5L)) * __numeric_constants<_Tp>::__pi_2();

const _Tp __c = std::cos(__chi);
const _Tp __s = std::sin(__chi);

const _Tp __coef =
std::sqrt(_Tp(2) / (__numeric_constants<_Tp>::__pi() * __x));

__Jnu = __coef * (__c * __P - __s * __Q);
__Nnu = __coef * (__s * __P + __c * __Q);

return;
}
template <typename _Tp>
_Tp __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
unsigned int __max_iter) {
if (__x == _Tp(0))
return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

const _Tp __x2 = __x / _Tp(2);
_Tp __fact = __nu * std::log(__x2);

__fact -= ::std::lgamma(__nu + _Tp(1));

__fact = std::exp(__fact);
const _Tp __xx4 = __sgn * __x2 * __x2;
_Tp __Jn = _Tp(1);
_Tp __term = _Tp(1);

for (unsigned int __i = 1; __i < __max_iter; ++__i) {
__term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
__Jn += __term;
if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
break;
}

return __fact * __Jn;
}
template <typename _Tp> _Tp __cyl_bessel_j(_Tp __nu, _Tp __x) {
if (__nu < _Tp(0) || __x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __cyl_bessel_j."));
else if (__isnan(__nu) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
else if (__x > _Tp(1000)) {
_Tp __J_nu, __N_nu;
__cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
return __J_nu;
} else {
_Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
__bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
return __J_nu;
}
}
template <typename _Tp> _Tp __cyl_neumann_n(_Tp __nu, _Tp __x) {
if (__nu < _Tp(0) || __x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __cyl_neumann_n."));
else if (__isnan(__nu) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x > _Tp(1000)) {
_Tp __J_nu, __N_nu;
__cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
return __N_nu;
} else {
_Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
__bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
return __N_nu;
}
}
template <typename _Tp>
void __sph_bessel_jn(unsigned int __n, _Tp __x, _Tp &__j_n, _Tp &__n_n,
_Tp &__jp_n, _Tp &__np_n) {
const _Tp __nu = _Tp(__n) + _Tp(0.5L);

_Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
__bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

const _Tp __factor =
__numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);

__j_n = __factor * __J_nu;
__n_n = __factor * __N_nu;
__jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
__np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

return;
}
template <typename _Tp> _Tp __sph_bessel(unsigned int __n, _Tp __x) {
if (__x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __sph_bessel."));
else if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x == _Tp(0)) {
if (__n == 0)
return _Tp(1);
else
return _Tp(0);
} else {
_Tp __j_n, __n_n, __jp_n, __np_n;
__sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
return __j_n;
}
}
template <typename _Tp> _Tp __sph_neumann(unsigned int __n, _Tp __x) {
if (__x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __sph_neumann."));
else if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x == _Tp(0))
return -std::numeric_limits<_Tp>::infinity();
else {
_Tp __j_n, __n_n, __jp_n, __np_n;
__sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
return __n_n;
}
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __beta_gamma(_Tp __x, _Tp __y) {

_Tp __bet;

if (__x > __y) {
__bet = ::std::tgamma(__x) / ::std::tgamma(__x + __y);
__bet *= ::std::tgamma(__y);
} else {
__bet = ::std::tgamma(__y) / ::std::tgamma(__x + __y);
__bet *= ::std::tgamma(__x);
}
return __bet;
}
template <typename _Tp> _Tp __beta_lgamma(_Tp __x, _Tp __y) {

_Tp __bet =
::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);

__bet = std::exp(__bet);
return __bet;
}
template <typename _Tp> _Tp __beta_product(_Tp __x, _Tp __y) {

_Tp __bet = (__x + __y) / (__x * __y);

unsigned int __max_iter = 1000000;
for (unsigned int __k = 1; __k < __max_iter; ++__k) {
_Tp __term = (_Tp(1) + (__x + __y) / __k) /
((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
__bet *= __term;
}

return __bet;
}
template <typename _Tp> inline _Tp __beta(_Tp __x, _Tp __y) {
if (__isnan(__x) || __isnan(__y))
return std::numeric_limits<_Tp>::quiet_NaN();
else
return __beta_lgamma(__x, __y);
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __ellint_rf(_Tp __x, _Tp __y, _Tp __z) {
const _Tp __min = std::numeric_limits<_Tp>::min();
const _Tp __lolim = _Tp(5) * __min;

if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
std::__throw_domain_error(("Argument less than zero "
"in __ellint_rf."));
else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
std::__throw_domain_error(("Argument too small in __ellint_rf"));
else {
const _Tp __c0 = _Tp(1) / _Tp(4);
const _Tp __c1 = _Tp(1) / _Tp(24);
const _Tp __c2 = _Tp(1) / _Tp(10);
const _Tp __c3 = _Tp(3) / _Tp(44);
const _Tp __c4 = _Tp(1) / _Tp(14);

_Tp __xn = __x;
_Tp __yn = __y;
_Tp __zn = __z;

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
_Tp __mu;
_Tp __xndev, __yndev, __zndev;

const unsigned int __max_iter = 100;
for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
__mu = (__xn + __yn + __zn) / _Tp(3);
__xndev = 2 - (__mu + __xn) / __mu;
__yndev = 2 - (__mu + __yn) / __mu;
__zndev = 2 - (__mu + __zn) / __mu;
_Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
__epsilon = std::max(__epsilon, std::abs(__zndev));
if (__epsilon < __errtol)
break;
const _Tp __xnroot = std::sqrt(__xn);
const _Tp __ynroot = std::sqrt(__yn);
const _Tp __znroot = std::sqrt(__zn);
const _Tp __lambda =
__xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
__xn = __c0 * (__xn + __lambda);
__yn = __c0 * (__yn + __lambda);
__zn = __c0 * (__zn + __lambda);
}

const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
const _Tp __e3 = __xndev * __yndev * __zndev;
const _Tp __s =
_Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;

return __s / std::sqrt(__mu);
}
}
template <typename _Tp> _Tp __comp_ellint_1_series(_Tp __k) {

const _Tp __kk = __k * __k;

_Tp __term = __kk / _Tp(4);
_Tp __sum = _Tp(1) + __term;

const unsigned int __max_iter = 1000;
for (unsigned int __i = 2; __i < __max_iter; ++__i) {
__term *= (2 * __i - 1) * __kk / (2 * __i);
if (__term < std::numeric_limits<_Tp>::epsilon())
break;
__sum += __term;
}

return __numeric_constants<_Tp>::__pi_2() * __sum;
}
template <typename _Tp> _Tp __comp_ellint_1(_Tp __k) {

if (__isnan(__k))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (std::abs(__k) >= _Tp(1))
return std::numeric_limits<_Tp>::quiet_NaN();
else
return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
}
template <typename _Tp> _Tp __ellint_1(_Tp __k, _Tp __phi) {

if (__isnan(__k) || __isnan(__phi))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (std::abs(__k) > _Tp(1))
std::__throw_domain_error(("Bad argument in __ellint_1."));
else {

const int __n =
std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

const _Tp __s = std::sin(__phi_red);
const _Tp __c = std::cos(__phi_red);

const _Tp __F =
__s * __ellint_rf(__c * __c, _Tp(1) - __k * __k * __s * __s, _Tp(1));

if (__n == 0)
return __F;
else
return __F + _Tp(2) * __n * __comp_ellint_1(__k);
}
}
template <typename _Tp> _Tp __comp_ellint_2_series(_Tp __k) {

const _Tp __kk = __k * __k;

_Tp __term = __kk;
_Tp __sum = __term;

const unsigned int __max_iter = 1000;
for (unsigned int __i = 2; __i < __max_iter; ++__i) {
const _Tp __i2m = 2 * __i - 1;
const _Tp __i2 = 2 * __i;
__term *= __i2m * __i2m * __kk / (__i2 * __i2);
if (__term < std::numeric_limits<_Tp>::epsilon())
break;
__sum += __term / __i2m;
}

return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
}
template <typename _Tp> _Tp __ellint_rd(_Tp __x, _Tp __y, _Tp __z) {
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
const _Tp __max = std::numeric_limits<_Tp>::max();
const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

if (__x < _Tp(0) || __y < _Tp(0))
std::__throw_domain_error(("Argument less than zero "
"in __ellint_rd."));
else if (__x + __y < __lolim || __z < __lolim)
std::__throw_domain_error(("Argument too small "
"in __ellint_rd."));
else {
const _Tp __c0 = _Tp(1) / _Tp(4);
const _Tp __c1 = _Tp(3) / _Tp(14);
const _Tp __c2 = _Tp(1) / _Tp(6);
const _Tp __c3 = _Tp(9) / _Tp(22);
const _Tp __c4 = _Tp(3) / _Tp(26);

_Tp __xn = __x;
_Tp __yn = __y;
_Tp __zn = __z;
_Tp __sigma = _Tp(0);
_Tp __power4 = _Tp(1);

_Tp __mu;
_Tp __xndev, __yndev, __zndev;

const unsigned int __max_iter = 100;
for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
__mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
__xndev = (__mu - __xn) / __mu;
__yndev = (__mu - __yn) / __mu;
__zndev = (__mu - __zn) / __mu;
_Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
__epsilon = std::max(__epsilon, std::abs(__zndev));
if (__epsilon < __errtol)
break;
_Tp __xnroot = std::sqrt(__xn);
_Tp __ynroot = std::sqrt(__yn);
_Tp __znroot = std::sqrt(__zn);
_Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
__sigma += __power4 / (__znroot * (__zn + __lambda));
__power4 *= __c0;
__xn = __c0 * (__xn + __lambda);
__yn = __c0 * (__yn + __lambda);
__zn = __c0 * (__zn + __lambda);
}

_Tp __ea = __xndev * __yndev;
_Tp __eb = __zndev * __zndev;
_Tp __ec = __ea - __eb;
_Tp __ed = __ea - _Tp(6) * __eb;
_Tp __ef = __ed + __ec + __ec;
_Tp __s1 = __ed * (-__c1 + __c3 * __ed / _Tp(3) -
_Tp(3) * __c4 * __zndev * __ef / _Tp(2));
_Tp __s2 = __zndev * (__c2 * __ef +
__zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

return _Tp(3) * __sigma +
__power4 * (_Tp(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
}
}
template <typename _Tp> _Tp __comp_ellint_2(_Tp __k) {

if (__isnan(__k))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (std::abs(__k) == 1)
return _Tp(1);
else if (std::abs(__k) > _Tp(1))
std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
else {
const _Tp __kk = __k * __k;

return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) -
__kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
}
}
template <typename _Tp> _Tp __ellint_2(_Tp __k, _Tp __phi) {

if (__isnan(__k) || __isnan(__phi))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (std::abs(__k) > _Tp(1))
std::__throw_domain_error(("Bad argument in __ellint_2."));
else {

const int __n =
std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

const _Tp __kk = __k * __k;
const _Tp __s = std::sin(__phi_red);
const _Tp __ss = __s * __s;
const _Tp __sss = __ss * __s;
const _Tp __c = std::cos(__phi_red);
const _Tp __cc = __c * __c;

const _Tp __E = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) -
__kk * __sss *
__ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1)) /
_Tp(3);

if (__n == 0)
return __E;
else
return __E + _Tp(2) * __n * __comp_ellint_2(__k);
}
}
template <typename _Tp> _Tp __ellint_rc(_Tp __x, _Tp __y) {
const _Tp __min = std::numeric_limits<_Tp>::min();
const _Tp __lolim = _Tp(5) * __min;

if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
std::__throw_domain_error(("Argument less than zero "
"in __ellint_rc."));
else {
const _Tp __c0 = _Tp(1) / _Tp(4);
const _Tp __c1 = _Tp(1) / _Tp(7);
const _Tp __c2 = _Tp(9) / _Tp(22);
const _Tp __c3 = _Tp(3) / _Tp(10);
const _Tp __c4 = _Tp(3) / _Tp(8);

_Tp __xn = __x;
_Tp __yn = __y;

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
_Tp __mu;
_Tp __sn;

const unsigned int __max_iter = 100;
for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
__mu = (__xn + _Tp(2) * __yn) / _Tp(3);
__sn = (__yn + __mu) / __mu - _Tp(2);
if (std::abs(__sn) < __errtol)
break;
const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
__xn = __c0 * (__xn + __lambda);
__yn = __c0 * (__yn + __lambda);
}

_Tp __s =
__sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));

return (_Tp(1) + __s) / std::sqrt(__mu);
}
}
template <typename _Tp> _Tp __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p) {
const _Tp __min = std::numeric_limits<_Tp>::min();
const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1) / _Tp(3));

if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
std::__throw_domain_error(("Argument less than zero "
"in __ellint_rj."));
else if (__x + __y < __lolim || __x + __z < __lolim ||
__y + __z < __lolim || __p < __lolim)
std::__throw_domain_error(("Argument too small "
"in __ellint_rj"));
else {
const _Tp __c0 = _Tp(1) / _Tp(4);
const _Tp __c1 = _Tp(3) / _Tp(14);
const _Tp __c2 = _Tp(1) / _Tp(3);
const _Tp __c3 = _Tp(3) / _Tp(22);
const _Tp __c4 = _Tp(3) / _Tp(26);

_Tp __xn = __x;
_Tp __yn = __y;
_Tp __zn = __z;
_Tp __pn = __p;
_Tp __sigma = _Tp(0);
_Tp __power4 = _Tp(1);

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

_Tp __mu;
_Tp __xndev, __yndev, __zndev, __pndev;

const unsigned int __max_iter = 100;
for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
__mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
__xndev = (__mu - __xn) / __mu;
__yndev = (__mu - __yn) / __mu;
__zndev = (__mu - __zn) / __mu;
__pndev = (__mu - __pn) / __mu;
_Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
__epsilon = std::max(__epsilon, std::abs(__zndev));
__epsilon = std::max(__epsilon, std::abs(__pndev));
if (__epsilon < __errtol)
break;
const _Tp __xnroot = std::sqrt(__xn);
const _Tp __ynroot = std::sqrt(__yn);
const _Tp __znroot = std::sqrt(__zn);
const _Tp __lambda =
__xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot) +
__xnroot * __ynroot * __znroot;
const _Tp __alpha2 = __alpha1 * __alpha1;
const _Tp __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
__sigma += __power4 * __ellint_rc(__alpha2, __beta);
__power4 *= __c0;
__xn = __c0 * (__xn + __lambda);
__yn = __c0 * (__yn + __lambda);
__zn = __c0 * (__zn + __lambda);
__pn = __c0 * (__pn + __lambda);
}

_Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
_Tp __eb = __xndev * __yndev * __zndev;
_Tp __ec = __pndev * __pndev;
_Tp __e2 = __ea - _Tp(3) * __ec;
_Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
_Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4) -
_Tp(3) * __c4 * __e3 / _Tp(2));
_Tp __s2 =
__eb * (__c2 / _Tp(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
_Tp __s3 =
__pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;

return _Tp(3) * __sigma +
__power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
}
}
template <typename _Tp> _Tp __comp_ellint_3(_Tp __k, _Tp __nu) {

if (__isnan(__k) || __isnan(__nu))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__nu == _Tp(1))
return std::numeric_limits<_Tp>::infinity();
else if (std::abs(__k) > _Tp(1))
std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
else {
const _Tp __kk = __k * __k;

return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) +
__nu * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu) /
_Tp(3);
}
}
template <typename _Tp> _Tp __ellint_3(_Tp __k, _Tp __nu, _Tp __phi) {

if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (std::abs(__k) > _Tp(1))
std::__throw_domain_error(("Bad argument in __ellint_3."));
else {

const int __n =
std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

const _Tp __kk = __k * __k;
const _Tp __s = std::sin(__phi_red);
const _Tp __ss = __s * __s;
const _Tp __sss = __ss * __s;
const _Tp __c = std::cos(__phi_red);
const _Tp __cc = __c * __c;

const _Tp __Pi = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) +
__nu * __sss *
__ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
_Tp(1) - __nu * __ss) /
_Tp(3);

if (__n == 0)
return __Pi;
else
return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
}
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __expint_E1(_Tp);
template <typename _Tp> _Tp __expint_E1_series(_Tp __x) {
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
_Tp __term = _Tp(1);
_Tp __esum = _Tp(0);
_Tp __osum = _Tp(0);
const unsigned int __max_iter = 1000;
for (unsigned int __i = 1; __i < __max_iter; ++__i) {
__term *= -__x / __i;
if (std::abs(__term) < __eps)
break;
if (__term >= _Tp(0))
__esum += __term / __i;
else
__osum += __term / __i;
}

return -__esum - __osum - __numeric_constants<_Tp>::__gamma_e() -
std::log(__x);
}
template <typename _Tp> _Tp __expint_E1_asymp(_Tp __x) {
_Tp __term = _Tp(1);
_Tp __esum = _Tp(1);
_Tp __osum = _Tp(0);
const unsigned int __max_iter = 1000;
for (unsigned int __i = 1; __i < __max_iter; ++__i) {
_Tp __prev = __term;
__term *= -__i / __x;
if (std::abs(__term) > std::abs(__prev))
break;
if (__term >= _Tp(0))
__esum += __term;
else
__osum += __term;
}

return std::exp(-__x) * (__esum + __osum) / __x;
}
template <typename _Tp> _Tp __expint_En_series(unsigned int __n, _Tp __x) {
const unsigned int __max_iter = 1000;
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const int __nm1 = __n - 1;
_Tp __ans =
(__nm1 != 0 ? _Tp(1) / __nm1
: -std::log(__x) - __numeric_constants<_Tp>::__gamma_e());
_Tp __fact = _Tp(1);
for (int __i = 1; __i <= __max_iter; ++__i) {
__fact *= -__x / _Tp(__i);
_Tp __del;
if (__i != __nm1)
__del = -__fact / _Tp(__i - __nm1);
else {
_Tp __psi = -__numeric_constants<_Tp>::gamma_e();
for (int __ii = 1; __ii <= __nm1; ++__ii)
__psi += _Tp(1) / _Tp(__ii);
__del = __fact * (__psi - std::log(__x));
}
__ans += __del;
if (std::abs(__del) < __eps * std::abs(__ans))
return __ans;
}
std::__throw_runtime_error(("Series summation failed "
"in __expint_En_series."));
}
template <typename _Tp> _Tp __expint_En_cont_frac(unsigned int __n, _Tp __x) {
const unsigned int __max_iter = 1000;
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __fp_min = std::numeric_limits<_Tp>::min();
const int __nm1 = __n - 1;
_Tp __b = __x + _Tp(__n);
_Tp __c = _Tp(1) / __fp_min;
_Tp __d = _Tp(1) / __b;
_Tp __h = __d;
for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
_Tp __a = -_Tp(__i * (__nm1 + __i));
__b += _Tp(2);
__d = _Tp(1) / (__a * __d + __b);
__c = __b + __a / __c;
const _Tp __del = __c * __d;
__h *= __del;
if (std::abs(__del - _Tp(1)) < __eps) {
const _Tp __ans = __h * std::exp(-__x);
return __ans;
}
}
std::__throw_runtime_error(("Continued fraction failed "
"in __expint_En_cont_frac."));
}
template <typename _Tp> _Tp __expint_En_recursion(unsigned int __n, _Tp __x) {
_Tp __En;
_Tp __E1 = __expint_E1(__x);
if (__x < _Tp(__n)) {

__En = __E1;
for (unsigned int __j = 2; __j < __n; ++__j)
__En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
} else {

__En = _Tp(1);
const int __N = __n + 20;
_Tp __save = _Tp(0);
for (int __j = __N; __j > 0; --__j) {
__En = (std::exp(-__x) - __j * __En) / __x;
if (__j == __n)
__save = __En;
}
_Tp __norm = __En / __E1;
__En /= __norm;
}

return __En;
}
template <typename _Tp> _Tp __expint_Ei_series(_Tp __x) {
_Tp __term = _Tp(1);
_Tp __sum = _Tp(0);
const unsigned int __max_iter = 1000;
for (unsigned int __i = 1; __i < __max_iter; ++__i) {
__term *= __x / __i;
__sum += __term / __i;
if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
break;
}

return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
}
template <typename _Tp> _Tp __expint_Ei_asymp(_Tp __x) {
_Tp __term = _Tp(1);
_Tp __sum = _Tp(1);
const unsigned int __max_iter = 1000;
for (unsigned int __i = 1; __i < __max_iter; ++__i) {
_Tp __prev = __term;
__term *= __i / __x;
if (__term < std::numeric_limits<_Tp>::epsilon())
break;
if (__term >= __prev)
break;
__sum += __term;
}

return std::exp(__x) * __sum / __x;
}
template <typename _Tp> _Tp __expint_Ei(_Tp __x) {
if (__x < _Tp(0))
return -__expint_E1(-__x);
else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
return __expint_Ei_series(__x);
else
return __expint_Ei_asymp(__x);
}
template <typename _Tp> _Tp __expint_E1(_Tp __x) {
if (__x < _Tp(0))
return -__expint_Ei(-__x);
else if (__x < _Tp(1))
return __expint_E1_series(__x);
else if (__x < _Tp(100))
return __expint_En_cont_frac(1, __x);
else
return __expint_E1_asymp(__x);
}
template <typename _Tp> _Tp __expint_asymp(unsigned int __n, _Tp __x) {
_Tp __term = _Tp(1);
_Tp __sum = _Tp(1);
for (unsigned int __i = 1; __i <= __n; ++__i) {
_Tp __prev = __term;
__term *= -(__n - __i + 1) / __x;
if (std::abs(__term) > std::abs(__prev))
break;
__sum += __term;
}

return std::exp(-__x) * __sum / __x;
}
template <typename _Tp> _Tp __expint_large_n(unsigned int __n, _Tp __x) {
const _Tp __xpn = __x + __n;
const _Tp __xpn2 = __xpn * __xpn;
_Tp __term = _Tp(1);
_Tp __sum = _Tp(1);
for (unsigned int __i = 1; __i <= __n; ++__i) {
_Tp __prev = __term;
__term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
break;
__sum += __term;
}

return std::exp(-__x) * __sum / __xpn;
}
template <typename _Tp> _Tp __expint(unsigned int __n, _Tp __x) {

if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__n <= 1 && __x == _Tp(0))
return std::numeric_limits<_Tp>::infinity();
else {
_Tp __E0 = std::exp(__x) / __x;
if (__n == 0)
return __E0;

_Tp __E1 = __expint_E1(__x);
if (__n == 1)
return __E1;

if (__x == _Tp(0))
return _Tp(1) / static_cast<_Tp>(__n - 1);

_Tp __En = __expint_En_recursion(__n, __x);

return __En;
}
}
template <typename _Tp> inline _Tp __expint(_Tp __x) {
if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else
return __expint_Ei(__x);
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x) {
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

_Tp __term = _Tp(1);
_Tp __Fac = _Tp(1);
const unsigned int __max_iter = 100000;
unsigned int __i;
for (__i = 0; __i < __max_iter; ++__i) {
__term *= (__a + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
if (std::abs(__term) < __eps) {
break;
}
__Fac += __term;
}
if (__i == __max_iter)
std::__throw_runtime_error(("Series failed to converge "
"in __conf_hyperg_series."));

return __Fac;
}
template <typename _Tp> _Tp __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin) {
const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
const int __nmax = 20000;
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __x = -__xin;
const _Tp __x3 = __x * __x * __x;
const _Tp __t0 = __a / __c;
const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
_Tp __F = _Tp(1);
_Tp __prec;

_Tp __Bnm3 = _Tp(1);
_Tp __Bnm2 = _Tp(1) + __t1 * __x;
_Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

_Tp __Anm3 = _Tp(1);
_Tp __Anm2 = __Bnm2 - __t0 * __x;
_Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x +
__t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

int __n = 3;
while (1) {
_Tp __npam1 = _Tp(__n - 1) + __a;
_Tp __npcm1 = _Tp(__n - 1) + __c;
_Tp __npam2 = _Tp(__n - 2) + __a;
_Tp __npcm2 = _Tp(__n - 2) + __c;
_Tp __tnm1 = _Tp(2 * __n - 1);
_Tp __tnm3 = _Tp(2 * __n - 3);
_Tp __tnm5 = _Tp(2 * __n - 5);
_Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
_Tp __F2 = (_Tp(__n) + __a) * __npam1 /
(_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
_Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a) /
(_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) *
__npcm2 * __npcm1);
_Tp __E = -__npam1 * (_Tp(__n - 1) - __c) /
(_Tp(2) * __tnm3 * __npcm2 * __npcm1);

_Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 +
(__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
_Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 +
(__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
_Tp __r = __An / __Bn;

__prec = std::abs((__F - __r) / __F);
__F = __r;

if (__prec < __eps || __n > __nmax)
break;

if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
__An /= __big;
__Bn /= __big;
__Anm1 /= __big;
__Bnm1 /= __big;
__Anm2 /= __big;
__Bnm2 /= __big;
__Anm3 /= __big;
__Bnm3 /= __big;
} else if (std::abs(__An) < _Tp(1) / __big ||
std::abs(__Bn) < _Tp(1) / __big) {
__An *= __big;
__Bn *= __big;
__Anm1 *= __big;
__Bnm1 *= __big;
__Anm2 *= __big;
__Bnm2 *= __big;
__Anm3 *= __big;
__Bnm3 *= __big;
}

++__n;
__Bnm3 = __Bnm2;
__Bnm2 = __Bnm1;
__Bnm1 = __Bn;
__Anm3 = __Anm2;
__Anm2 = __Anm1;
__Anm1 = __An;
}

if (__n >= __nmax)
std::__throw_runtime_error(("Iteration failed to converge "
"in __conf_hyperg_luke."));

return __F;
}
template <typename _Tp> _Tp __conf_hyperg(_Tp __a, _Tp __c, _Tp __x) {

const _Tp __c_nint = ::std::nearbyint(__c);

if (__isnan(__a) || __isnan(__c) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__c_nint == __c && __c_nint <= 0)
return std::numeric_limits<_Tp>::infinity();
else if (__a == _Tp(0))
return _Tp(1);
else if (__c == __a)
return std::exp(__x);
else if (__x < _Tp(0))
return __conf_hyperg_luke(__a, __c, __x);
else
return __conf_hyperg_series(__a, __c, __x);
}
template <typename _Tp>
_Tp __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

_Tp __term = _Tp(1);
_Tp __Fabc = _Tp(1);
const unsigned int __max_iter = 100000;
unsigned int __i;
for (__i = 0; __i < __max_iter; ++__i) {
__term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x /
((__c + _Tp(__i)) * _Tp(1 + __i));
if (std::abs(__term) < __eps) {
break;
}
__Fabc += __term;
}
if (__i == __max_iter)
std::__throw_runtime_error(("Series failed to converge "
"in __hyperg_series."));

return __Fabc;
}

template <typename _Tp>
_Tp __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin) {
const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
const int __nmax = 20000;
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __x = -__xin;
const _Tp __x3 = __x * __x * __x;
const _Tp __t0 = __a * __b / __c;
const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
const _Tp __t2 =
(__a + _Tp(2)) * (__b + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));

_Tp __F = _Tp(1);

_Tp __Bnm3 = _Tp(1);
_Tp __Bnm2 = _Tp(1) + __t1 * __x;
_Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

_Tp __Anm3 = _Tp(1);
_Tp __Anm2 = __Bnm2 - __t0 * __x;
_Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x +
__t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

int __n = 3;
while (1) {
const _Tp __npam1 = _Tp(__n - 1) + __a;
const _Tp __npbm1 = _Tp(__n - 1) + __b;
const _Tp __npcm1 = _Tp(__n - 1) + __c;
const _Tp __npam2 = _Tp(__n - 2) + __a;
const _Tp __npbm2 = _Tp(__n - 2) + __b;
const _Tp __npcm2 = _Tp(__n - 2) + __c;
const _Tp __tnm1 = _Tp(2 * __n - 1);
const _Tp __tnm3 = _Tp(2 * __n - 3);
const _Tp __tnm5 = _Tp(2 * __n - 5);
const _Tp __n2 = __n * __n;
const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n + _Tp(2) -
__a * __b - _Tp(2) * (__a + __b)) /
(_Tp(2) * __tnm3 * __npcm1);
const _Tp __F2 =
-(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n + _Tp(2) - __a * __b) *
__npam1 * __npbm1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1 *
(_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b)) /
(_Tp(8) * __tnm3 * __tnm3 * __tnm5 *
(_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c) /
(_Tp(2) * __tnm3 * __npcm2 * __npcm1);

_Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 +
(__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
_Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 +
(__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
const _Tp __r = __An / __Bn;

const _Tp __prec = std::abs((__F - __r) / __F);
__F = __r;

if (__prec < __eps || __n > __nmax)
break;

if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
__An /= __big;
__Bn /= __big;
__Anm1 /= __big;
__Bnm1 /= __big;
__Anm2 /= __big;
__Bnm2 /= __big;
__Anm3 /= __big;
__Bnm3 /= __big;
} else if (std::abs(__An) < _Tp(1) / __big ||
std::abs(__Bn) < _Tp(1) / __big) {
__An *= __big;
__Bn *= __big;
__Anm1 *= __big;
__Bnm1 *= __big;
__Anm2 *= __big;
__Bnm2 *= __big;
__Anm3 *= __big;
__Bnm3 *= __big;
}

++__n;
__Bnm3 = __Bnm2;
__Bnm2 = __Bnm1;
__Bnm1 = __Bn;
__Anm3 = __Anm2;
__Anm2 = __Anm1;
__Anm1 = __An;
}

if (__n >= __nmax)
std::__throw_runtime_error(("Iteration failed to converge "
"in __hyperg_luke."));

return __F;
}
template <typename _Tp>
_Tp __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {
const _Tp __d = __c - __a - __b;
const int __intd = std::floor(__d + _Tp(0.5L));
const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __toler = _Tp(1000) * __eps;
const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
const bool __d_integer = (std::abs(__d - __intd) < __toler);

if (__d_integer) {
const _Tp __ln_omx = std::log(_Tp(1) - __x);
const _Tp __ad = std::abs(__d);
_Tp __F1, __F2;

_Tp __d1, __d2;
if (__d >= _Tp(0)) {
__d1 = __d;
__d2 = _Tp(0);
} else {
__d1 = _Tp(0);
__d2 = __d;
}

const _Tp __lng_c = __log_gamma(__c);

if (__ad < __eps) {

__F1 = _Tp(0);
} else {

bool __ok_d1 = true;
_Tp __lng_ad, __lng_ad1, __lng_bd1;
try {
__lng_ad = __log_gamma(__ad);
__lng_ad1 = __log_gamma(__a + __d1);
__lng_bd1 = __log_gamma(__b + __d1);
} catch (...) {
__ok_d1 = false;
}

if (__ok_d1) {

_Tp __sum1 = _Tp(1);
_Tp __term = _Tp(1);
_Tp __ln_pre1 =
__lng_ad + __lng_c + __d2 * __ln_omx - __lng_ad1 - __lng_bd1;

for (int __i = 1; __i < __ad; ++__i) {
const int __j = __i - 1;
__term *= (__a + __d2 + __j) * (__b + __d2 + __j) /
(_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
__sum1 += __term;
}

if (__ln_pre1 > __log_max)
std::__throw_runtime_error(("Overflow of gamma functions"
" in __hyperg_luke."));
else
__F1 = std::exp(__ln_pre1) * __sum1;
} else {

__F1 = _Tp(0);
}
}

bool __ok_d2 = true;
_Tp __lng_ad2, __lng_bd2;
try {
__lng_ad2 = __log_gamma(__a + __d2);
__lng_bd2 = __log_gamma(__b + __d2);
} catch (...) {
__ok_d2 = false;
}

if (__ok_d2) {

const int __maxiter = 2000;
const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
const _Tp __psi_apd1 = __psi(__a + __d1);
const _Tp __psi_bpd1 = __psi(__b + __d1);

_Tp __psi_term =
__psi_1 + __psi_1pd - __psi_apd1 - __psi_bpd1 - __ln_omx;
_Tp __fact = _Tp(1);
_Tp __sum2 = __psi_term;
_Tp __ln_pre2 = __lng_c + __d1 * __ln_omx - __lng_ad2 - __lng_bd2;

int __j;
for (__j = 1; __j < __maxiter; ++__j) {

const _Tp __term1 = _Tp(1) / _Tp(__j) + _Tp(1) / (__ad + __j);
const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1)) +
_Tp(1) / (__b + __d1 + _Tp(__j - 1));
__psi_term += __term1 - __term2;
__fact *= (__a + __d1 + _Tp(__j - 1)) * (__b + __d1 + _Tp(__j - 1)) /
((__ad + __j) * __j) * (_Tp(1) - __x);
const _Tp __delta = __fact * __psi_term;
__sum2 += __delta;
if (std::abs(__delta) < __eps * std::abs(__sum2))
break;
}
if (__j == __maxiter)
std::__throw_runtime_error(("Sum F2 failed to converge "
"in __hyperg_reflect"));

if (__sum2 == _Tp(0))
__F2 = _Tp(0);
else
__F2 = std::exp(__ln_pre2) * __sum2;
} else {

__F2 = _Tp(0);
}

const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
const _Tp __F = __F1 + __sgn_2 * __F2;

return __F;
} else {

bool __ok1 = true;
_Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
_Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
try {
__sgn_g1ca = __log_gamma_sign(__c - __a);
__ln_g1ca = __log_gamma(__c - __a);
__sgn_g1cb = __log_gamma_sign(__c - __b);
__ln_g1cb = __log_gamma(__c - __b);
} catch (...) {
__ok1 = false;
}

bool __ok2 = true;
_Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
_Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
try {
__sgn_g2a = __log_gamma_sign(__a);
__ln_g2a = __log_gamma(__a);
__sgn_g2b = __log_gamma_sign(__b);
__ln_g2b = __log_gamma(__b);
} catch (...) {
__ok2 = false;
}

const _Tp __sgn_gc = __log_gamma_sign(__c);
const _Tp __ln_gc = __log_gamma(__c);
const _Tp __sgn_gd = __log_gamma_sign(__d);
const _Tp __ln_gd = __log_gamma(__d);
const _Tp __sgn_gmd = __log_gamma_sign(-__d);
const _Tp __ln_gmd = __log_gamma(-__d);

const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

_Tp __pre1, __pre2;
if (__ok1 && __ok2) {
_Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
_Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b +
__d * std::log(_Tp(1) - __x);
if (__ln_pre1 < __log_max && __ln_pre2 < __log_max) {
__pre1 = std::exp(__ln_pre1);
__pre2 = std::exp(__ln_pre2);
__pre1 *= __sgn1;
__pre2 *= __sgn2;
} else {
std::__throw_runtime_error(("Overflow of gamma functions "
"in __hyperg_reflect"));
}
} else if (__ok1 && !__ok2) {
_Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
if (__ln_pre1 < __log_max) {
__pre1 = std::exp(__ln_pre1);
__pre1 *= __sgn1;
__pre2 = _Tp(0);
} else {
std::__throw_runtime_error(("Overflow of gamma functions "
"in __hyperg_reflect"));
}
} else if (!__ok1 && __ok2) {
_Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b +
__d * std::log(_Tp(1) - __x);
if (__ln_pre2 < __log_max) {
__pre1 = _Tp(0);
__pre2 = std::exp(__ln_pre2);
__pre2 *= __sgn2;
} else {
std::__throw_runtime_error(("Overflow of gamma functions "
"in __hyperg_reflect"));
}
} else {
__pre1 = _Tp(0);
__pre2 = _Tp(0);
std::__throw_runtime_error(("Underflow of gamma functions "
"in __hyperg_reflect"));
}

const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d, _Tp(1) - __x);
const _Tp __F2 =
__hyperg_series(__c - __a, __c - __b, _Tp(1) + __d, _Tp(1) - __x);

const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

return __F;
}
}
template <typename _Tp> _Tp __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {

const _Tp __a_nint = ::std::nearbyint(__a);
const _Tp __b_nint = ::std::nearbyint(__b);
const _Tp __c_nint = ::std::nearbyint(__c);

const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
if (std::abs(__x) >= _Tp(1))
std::__throw_domain_error(("Argument outside unit circle "
"in __hyperg."));
else if (__isnan(__a) || __isnan(__b) || __isnan(__c) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__c_nint == __c && __c_nint <= _Tp(0))
return std::numeric_limits<_Tp>::infinity();
else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
return std::pow(_Tp(1) - __x, __c - __a - __b);
else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0) && __x >= _Tp(0) &&
__x < _Tp(0.995L))
return __hyperg_series(__a, __b, __c, __x);
else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10)) {

if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
return __hyperg_series(__a_nint, __b, __c, __x);
else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
return __hyperg_series(__a, __b_nint, __c, __x);
else if (__x < -_Tp(0.25L))
return __hyperg_luke(__a, __b, __c, __x);
else if (__x < _Tp(0.5L))
return __hyperg_series(__a, __b, __c, __x);
else if (std::abs(__c) > _Tp(10))
return __hyperg_series(__a, __b, __c, __x);
else
return __hyperg_reflect(__a, __b, __c, __x);
} else
return __hyperg_luke(__a, __b, __c, __x);
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __poly_legendre_p(unsigned int __l, _Tp __x) {

if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x == +_Tp(1))
return +_Tp(1);
else if (__x == -_Tp(1))
return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
else {
_Tp __p_lm2 = _Tp(1);
if (__l == 0)
return __p_lm2;

_Tp __p_lm1 = __x;
if (__l == 1)
return __p_lm1;

_Tp __p_l = 0;
for (unsigned int __ll = 2; __ll <= __l; ++__ll) {

__p_l = _Tp(2) * __x * __p_lm1 - __p_lm2 -
(__x * __p_lm1 - __p_lm2) / _Tp(__ll);
__p_lm2 = __p_lm1;
__p_lm1 = __p_l;
}

return __p_l;
}
}
template <typename _Tp>
_Tp __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
_Tp __phase = _Tp(+1)) {

if (__m > __l)
return _Tp(0);
else if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__m == 0)
return __poly_legendre_p(__l, __x);
else {
_Tp __p_mm = _Tp(1);
if (__m > 0) {

_Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
_Tp __fact = _Tp(1);
for (unsigned int __i = 1; __i <= __m; ++__i) {
__p_mm *= __phase * __fact * __root;
__fact += _Tp(2);
}
}
if (__l == __m)
return __p_mm;

_Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
if (__l == __m + 1)
return __p_mp1m;

_Tp __p_lm2m = __p_mm;
_Tp __P_lm1m = __p_mp1m;
_Tp __p_lm = _Tp(0);
for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
__p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m -
_Tp(__j + __m - 1) * __p_lm2m) /
_Tp(__j - __m);
__p_lm2m = __P_lm1m;
__P_lm1m = __p_lm;
}

return __p_lm;
}
}
template <typename _Tp>
_Tp __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta) {
if (__isnan(__theta))
return std::numeric_limits<_Tp>::quiet_NaN();

const _Tp __x = std::cos(__theta);

if (__m > __l)
return _Tp(0);
else if (__m == 0) {
_Tp __P = __poly_legendre_p(__l, __x);
_Tp __fact = std::sqrt(_Tp(2 * __l + 1) /
(_Tp(4) * __numeric_constants<_Tp>::__pi()));
__P *= __fact;
return __P;
} else if (__x == _Tp(1) || __x == -_Tp(1)) {

return _Tp(0);
} else {

const _Tp __sgn = (__m % 2 == 1 ? -_Tp(1) : _Tp(1));
const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

const _Tp __lncirc = ::std::log1p(-__x * __x);

const _Tp __lnpoch =
::std::lgamma(_Tp(__m + _Tp(0.5L))) - ::std::lgamma(_Tp(__m));

const _Tp __lnpre_val = -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi() +
_Tp(0.5L) * (__lnpoch + __m * __lncirc);
const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m) /
(_Tp(4) * __numeric_constants<_Tp>::__pi()));
_Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
_Tp __y_mp1m = __y_mp1m_factor * __y_mm;

if (__l == __m)
return __y_mm;
else if (__l == __m + 1)
return __y_mp1m;
else {
_Tp __y_lm = _Tp(0);

for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll) {
const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
const _Tp __fact1 =
std::sqrt(__rat1 * _Tp(2 * __ll + 1) * _Tp(2 * __ll - 1));
const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1) /
_Tp(2 * __ll - 3));
__y_lm =
(__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) /
_Tp(__ll - __m);
__y_mm = __y_mp1m;
__y_mp1m = __y_lm;
}

return __y_lm;
}
}
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp>
void __bessel_ik(_Tp __nu, _Tp __x, _Tp &__Inu, _Tp &__Knu, _Tp &__Ipnu,
_Tp &__Kpnu) {
if (__x == _Tp(0)) {
if (__nu == _Tp(0)) {
__Inu = _Tp(1);
__Ipnu = _Tp(0);
} else if (__nu == _Tp(1)) {
__Inu = _Tp(0);
__Ipnu = _Tp(0.5L);
} else {
__Inu = _Tp(0);
__Ipnu = _Tp(0);
}
__Knu = std::numeric_limits<_Tp>::infinity();
__Kpnu = -std::numeric_limits<_Tp>::infinity();
return;
}

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
const int __max_iter = 15000;
const _Tp __x_min = _Tp(2);

const int __nl = static_cast<int>(__nu + _Tp(0.5L));

const _Tp __mu = __nu - __nl;
const _Tp __mu2 = __mu * __mu;
const _Tp __xi = _Tp(1) / __x;
const _Tp __xi2 = _Tp(2) * __xi;
_Tp __h = __nu * __xi;
if (__h < __fp_min)
__h = __fp_min;
_Tp __b = __xi2 * __nu;
_Tp __d = _Tp(0);
_Tp __c = __h;
int __i;
for (__i = 1; __i <= __max_iter; ++__i) {
__b += __xi2;
__d = _Tp(1) / (__b + __d);
__c = __b + _Tp(1) / __c;
const _Tp __del = __c * __d;
__h *= __del;
if (std::abs(__del - _Tp(1)) < __eps)
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Argument x too large "
"in __bessel_ik; "
"try asymptotic expansion.")

);
_Tp __Inul = __fp_min;
_Tp __Ipnul = __h * __Inul;
_Tp __Inul1 = __Inul;
_Tp __Ipnu1 = __Ipnul;
_Tp __fact = __nu * __xi;
for (int __l = __nl; __l >= 1; --__l) {
const _Tp __Inutemp = __fact * __Inul + __Ipnul;
__fact -= __xi;
__Ipnul = __fact * __Inutemp + __Inul;
__Inul = __Inutemp;
}
_Tp __f = __Ipnul / __Inul;
_Tp __Kmu, __Knu1;
if (__x < __x_min) {
const _Tp __x2 = __x / _Tp(2);
const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
const _Tp __fact =
(std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
_Tp __d = -std::log(__x2);
_Tp __e = __mu * __d;
const _Tp __fact2 =
(std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
_Tp __gam1, __gam2, __gampl, __gammi;
__gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
_Tp __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
_Tp __sum = __ff;
__e = std::exp(__e);
_Tp __p = __e / (_Tp(2) * __gampl);
_Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
_Tp __c = _Tp(1);
__d = __x2 * __x2;
_Tp __sum1 = __p;
int __i;
for (__i = 1; __i <= __max_iter; ++__i) {
__ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
__c *= __d / __i;
__p /= __i - __mu;
__q /= __i + __mu;
const _Tp __del = __c * __ff;
__sum += __del;
const _Tp __del1 = __c * (__p - __i * __ff);
__sum1 += __del1;
if (std::abs(__del) < __eps * std::abs(__sum))
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Bessel k series failed to converge "
"in __bessel_ik."));
__Kmu = __sum;
__Knu1 = __sum1 * __xi2;
} else {
_Tp __b = _Tp(2) * (_Tp(1) + __x);
_Tp __d = _Tp(1) / __b;
_Tp __delh = __d;
_Tp __h = __delh;
_Tp __q1 = _Tp(0);
_Tp __q2 = _Tp(1);
_Tp __a1 = _Tp(0.25L) - __mu2;
_Tp __q = __c = __a1;
_Tp __a = -__a1;
_Tp __s = _Tp(1) + __q * __delh;
int __i;
for (__i = 2; __i <= __max_iter; ++__i) {
__a -= 2 * (__i - 1);
__c = -__a * __c / __i;
const _Tp __qnew = (__q1 - __b * __q2) / __a;
__q1 = __q2;
__q2 = __qnew;
__q += __c * __qnew;
__b += _Tp(2);
__d = _Tp(1) / (__b + __a * __d);
__delh = (__b * __d - _Tp(1)) * __delh;
__h += __delh;
const _Tp __dels = __q * __delh;
__s += __dels;
if (std::abs(__dels / __s) < __eps)
break;
}
if (__i > __max_iter)
std::__throw_runtime_error(("Steed's method failed "
"in __bessel_ik."));
__h = __a1 * __h;
__Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x)) *
std::exp(-__x) / __s;
__Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
}

_Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
_Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
__Inu = __Inumu * __Inul1 / __Inul;
__Ipnu = __Inumu * __Ipnu1 / __Inul;
for (__i = 1; __i <= __nl; ++__i) {
const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
__Kmu = __Knu1;
__Knu1 = __Knutemp;
}
__Knu = __Kmu;
__Kpnu = __nu * __xi * __Kmu - __Knu1;

return;
}
template <typename _Tp> _Tp __cyl_bessel_i(_Tp __nu, _Tp __x) {
if (__nu < _Tp(0) || __x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __cyl_bessel_i."));
else if (__isnan(__nu) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
else {
_Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
__bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
return __I_nu;
}
}
template <typename _Tp> _Tp __cyl_bessel_k(_Tp __nu, _Tp __x) {
if (__nu < _Tp(0) || __x < _Tp(0))
std::__throw_domain_error(("Bad argument "
"in __cyl_bessel_k."));
else if (__isnan(__nu) || __isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else {
_Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
__bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
return __K_nu;
}
}
template <typename _Tp>
void __sph_bessel_ik(unsigned int __n, _Tp __x, _Tp &__i_n, _Tp &__k_n,
_Tp &__ip_n, _Tp &__kp_n) {
const _Tp __nu = _Tp(__n) + _Tp(0.5L);

_Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
__bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

const _Tp __factor =
__numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);

__i_n = __factor * __I_nu;
__k_n = __factor * __K_nu;
__ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
__kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

return;
}
template <typename _Tp>
void __airy(_Tp __x, _Tp &__Ai, _Tp &__Bi, _Tp &__Aip, _Tp &__Bip) {
const _Tp __absx = std::abs(__x);
const _Tp __rootx = std::sqrt(__absx);
const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

if (__isnan(__x))
__Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
else if (__z == _S_inf) {
__Aip = __Ai = _Tp(0);
__Bip = __Bi = _S_inf;
} else if (__z == -_S_inf)
__Bip = __Aip = __Bi = __Ai = _Tp(0);
else if (__x > _Tp(0)) {
_Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

__bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
__Ai = __rootx * __K_nu /
(__numeric_constants<_Tp>::__sqrt3() *
__numeric_constants<_Tp>::__pi());
__Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi() +
_Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

__bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
__Aip = -__x * __K_nu /
(__numeric_constants<_Tp>::__sqrt3() *
__numeric_constants<_Tp>::__pi());
__Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi() +
_Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
} else if (__x < _Tp(0)) {
_Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

__bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
__Ai = __rootx * (__J_nu - __N_nu / __numeric_constants<_Tp>::__sqrt3()) /
_Tp(2);
__Bi = -__rootx *
(__N_nu + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

__bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
__Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3() + __J_nu) /
_Tp(2);
__Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3() - __N_nu) /
_Tp(2);
} else {

__Ai = _Tp(0.35502805388781723926L);
__Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();

__Aip = -_Tp(0.25881940379280679840L);
__Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
}

return;
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp>
_Tp __poly_hermite_recursion(unsigned int __n, _Tp __x) {

_Tp __H_0 = 1;
if (__n == 0)
return __H_0;

_Tp __H_1 = 2 * __x;
if (__n == 1)
return __H_1;

_Tp __H_n, __H_nm1, __H_nm2;
unsigned int __i;
for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i) {
__H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
__H_nm2 = __H_nm1;
__H_nm1 = __H_n;
}

return __H_n;
}
template <typename _Tp> inline _Tp __poly_hermite(unsigned int __n, _Tp __x) {
if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else
return __poly_hermite_recursion(__n, __x);
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tpa, typename _Tp>
_Tp __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x) {
const _Tp __a = -_Tp(__n);
const _Tp __b = _Tp(__alpha1) + _Tp(1);
const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
const _Tp __cos2th = __x / __eta;
const _Tp __sin2th = _Tp(1) - __cos2th;
const _Tp __th = std::acos(std::sqrt(__cos2th));
const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2() *
__numeric_constants<_Tp>::__pi_2() * __eta * __eta *
__cos2th * __sin2th;

const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));

_Tp __pre_term1 =
_Tp(0.5L) * (_Tp(1) - __b) * std::log(_Tp(0.25L) * __x * __eta);
_Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
_Tp __lnpre =
__lg_b - __lnfact + _Tp(0.5L) * __x + __pre_term1 - __pre_term2;
_Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
_Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta *
(_Tp(2) * __th - std::sin(_Tp(2) * __th)) +
__numeric_constants<_Tp>::__pi_4());
_Tp __ser = __ser_term1 + __ser_term2;

return std::exp(__lnpre) * __ser;
}
template <typename _Tpa, typename _Tp>
_Tp __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x) {
const _Tp __b = _Tp(__alpha1) + _Tp(1);
const _Tp __mx = -__x;
const _Tp __tc_sgn =
(__x < _Tp(0) ? _Tp(1) : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

_Tp __tc = _Tp(1);
const _Tp __ax = std::abs(__x);
for (unsigned int __k = 1; __k <= __n; ++__k)
__tc *= (__ax / __k);

_Tp __term = __tc * __tc_sgn;
_Tp __sum = __term;
for (int __k = int(__n) - 1; __k >= 0; --__k) {
__term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k)) * _Tp(__k + 1) / __mx;
__sum += __term;
}

return __sum;
}
template <typename _Tpa, typename _Tp>
_Tp __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x) {

_Tp __l_0 = _Tp(1);
if (__n == 0)
return __l_0;

_Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
if (__n == 1)
return __l_1;

_Tp __l_n2 = __l_0;
_Tp __l_n1 = __l_1;
_Tp __l_n = _Tp(0);
for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
__l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x) * __l_n1 / _Tp(__nn) -
(_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
__l_n2 = __l_n1;
__l_n1 = __l_n;
}

return __l_n;
}
template <typename _Tpa, typename _Tp>
_Tp __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x) {
if (__x < _Tp(0))
std::__throw_domain_error(("Negative argument "
"in __poly_laguerre."));

else if (__isnan(__x))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__n == 0)
return _Tp(1);
else if (__n == 1)
return _Tp(1) + _Tp(__alpha1) - __x;
else if (__x == _Tp(0)) {
_Tp __prod = _Tp(__alpha1) + _Tp(1);
for (unsigned int __k = 2; __k <= __n; ++__k)
__prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
return __prod;
} else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1) &&
__x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
return __poly_laguerre_large_n(__n, __alpha1, __x);
else if (_Tp(__alpha1) >= _Tp(0) ||
(__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
return __poly_laguerre_recursion(__n, __alpha1, __x);
else
return __poly_laguerre_hyperg(__n, __alpha1, __x);
}
template <typename _Tp>
inline _Tp __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x) {
return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x);
}
template <typename _Tp> inline _Tp __laguerre(unsigned int __n, _Tp __x) {
return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x);
}
} // namespace __detail

} // namespace std
namespace std __attribute__((__visibility__("default"))) {

namespace __detail {
template <typename _Tp> _Tp __riemann_zeta_sum(_Tp __s) {

if (__s < _Tp(1))
std::__throw_domain_error(("Bad argument in zeta sum."));

const unsigned int max_iter = 10000;
_Tp __zeta = _Tp(0);
for (unsigned int __k = 1; __k < max_iter; ++__k) {
_Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
if (__term < std::numeric_limits<_Tp>::epsilon()) {
break;
}
__zeta += __term;
}

return __zeta;
}
template <typename _Tp> _Tp __riemann_zeta_alt(_Tp __s) {
_Tp __sgn = _Tp(1);
_Tp __zeta = _Tp(0);
for (unsigned int __i = 1; __i < 10000000; ++__i) {
_Tp __term = __sgn / std::pow(__i, __s);
if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
break;
__zeta += __term;
__sgn *= _Tp(-1);
}
__zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

return __zeta;
}
template <typename _Tp> _Tp __riemann_zeta_glob(_Tp __s) {
_Tp __zeta = _Tp(0);

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

const _Tp __max_bincoeff =
std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

if (__s < _Tp(0)) {

if (::std::fmod(__s, _Tp(2)) == _Tp(0))
return _Tp(0);
else

{
_Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
__zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

* std::exp(::std::lgamma(_Tp(1) - __s))

/ __numeric_constants<_Tp>::__pi();
return __zeta;
}
}

_Tp __num = _Tp(0.5L);
const unsigned int __maxit = 10000;
for (unsigned int __i = 0; __i < __maxit; ++__i) {
bool __punt = false;
_Tp __sgn = _Tp(1);
_Tp __term = _Tp(0);
for (unsigned int __j = 0; __j <= __i; ++__j) {

_Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) -
::std::lgamma(_Tp(1 + __j)) -
::std::lgamma(_Tp(1 + __i - __j));

if (__bincoeff > __max_bincoeff) {

__punt = true;
break;
}
__bincoeff = std::exp(__bincoeff);
__term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
__sgn *= _Tp(-1);
}
if (__punt)
break;
__term *= __num;
__zeta += __term;
if (std::abs(__term / __zeta) < __eps)
break;
__num *= _Tp(0.5L);
}

__zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

return __zeta;
}
template <typename _Tp> _Tp __riemann_zeta_product(_Tp __s) {
static const _Tp __prime[] = {
_Tp(2),  _Tp(3),   _Tp(5),   _Tp(7),   _Tp(11), _Tp(13),
_Tp(17), _Tp(19),  _Tp(23),  _Tp(29),  _Tp(31), _Tp(37),
_Tp(41), _Tp(43),  _Tp(47),  _Tp(53),  _Tp(59), _Tp(61),
_Tp(67), _Tp(71),  _Tp(73),  _Tp(79),  _Tp(83), _Tp(89),
_Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)};
static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

_Tp __zeta = _Tp(1);
for (unsigned int __i = 0; __i < __num_primes; ++__i) {
const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
__zeta *= __fact;
if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
break;
}

__zeta = _Tp(1) / __zeta;

return __zeta;
}
template <typename _Tp> _Tp __riemann_zeta(_Tp __s) {
if (__isnan(__s))
return std::numeric_limits<_Tp>::quiet_NaN();
else if (__s == _Tp(1))
return std::numeric_limits<_Tp>::infinity();
else if (__s < -_Tp(19)) {
_Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
__zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

* std::exp(::std::lgamma(_Tp(1) - __s))

/ __numeric_constants<_Tp>::__pi();
return __zeta;
} else if (__s < _Tp(20)) {

bool __glob = true;
if (__glob)
return __riemann_zeta_glob(__s);
else {
if (__s > _Tp(1))
return __riemann_zeta_sum(__s);
else {
_Tp __zeta =
std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

* ::std::tgamma(_Tp(1) - __s)

* __riemann_zeta_sum(_Tp(1) - __s);
return __zeta;
}
}
} else
return __riemann_zeta_product(__s);
}
template <typename _Tp> _Tp __hurwitz_zeta_glob(_Tp __a, _Tp __s) {
_Tp __zeta = _Tp(0);

const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

const _Tp __max_bincoeff =
std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

const unsigned int __maxit = 10000;
for (unsigned int __i = 0; __i < __maxit; ++__i) {
bool __punt = false;
_Tp __sgn = _Tp(1);
_Tp __term = _Tp(0);
for (unsigned int __j = 0; __j <= __i; ++__j) {

_Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) -
::std::lgamma(_Tp(1 + __j)) -
::std::lgamma(_Tp(1 + __i - __j));

if (__bincoeff > __max_bincoeff) {

__punt = true;
break;
}
__bincoeff = std::exp(__bincoeff);
__term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
__sgn *= _Tp(-1);
}
if (__punt)
break;
__term /= _Tp(__i + 1);
if (std::abs(__term / __zeta) < __eps)
break;
__zeta += __term;
}

__zeta /= __s - _Tp(1);

return __zeta;
}
template <typename _Tp> inline _Tp __hurwitz_zeta(_Tp __a, _Tp __s) {
return __hurwitz_zeta_glob(__a, __s);
}
} // namespace __detail

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

inline float assoc_laguerref(unsigned int __n, unsigned int __m, float __x) {
return __detail::__assoc_laguerre<float>(__n, __m, __x);
}

inline long double assoc_laguerrel(unsigned int __n, unsigned int __m,
long double __x) {
return __detail::__assoc_laguerre<long double>(__n, __m, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type assoc_laguerre(
unsigned int __n, unsigned int __m, _Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__assoc_laguerre<__type>(__n, __m, __x);
}
inline float assoc_legendref(unsigned int __l, unsigned int __m, float __x) {
return __detail::__assoc_legendre_p<float>(__l, __m, __x);
}

inline long double assoc_legendrel(unsigned int __l, unsigned int __m,
long double __x) {
return __detail::__assoc_legendre_p<long double>(__l, __m, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type assoc_legendre(
unsigned int __l, unsigned int __m, _Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
}
inline float betaf(float __a, float __b) {
return __detail::__beta<float>(__a, __b);
}

inline long double betal(long double __a, long double __b) {
return __detail::__beta<long double>(__a, __b);
}
template <typename _Tpa, typename _Tpb>
inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type beta(_Tpa __a,
_Tpb __b) {
typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
return __detail::__beta<__type>(__a, __b);
}
inline float comp_ellint_1f(float __k) {
return __detail::__comp_ellint_1<float>(__k);
}

inline long double comp_ellint_1l(long double __k) {
return __detail::__comp_ellint_1<long double>(__k);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_1(_Tp __k) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__comp_ellint_1<__type>(__k);
}
inline float comp_ellint_2f(float __k) {
return __detail::__comp_ellint_2<float>(__k);
}

inline long double comp_ellint_2l(long double __k) {
return __detail::__comp_ellint_2<long double>(__k);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_2(_Tp __k) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__comp_ellint_2<__type>(__k);
}
inline float comp_ellint_3f(float __k, float __nu) {
return __detail::__comp_ellint_3<float>(__k, __nu);
}

inline long double comp_ellint_3l(long double __k, long double __nu) {
return __detail::__comp_ellint_3<long double>(__k, __nu);
}
template <typename _Tp, typename _Tpn>
inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type comp_ellint_3(
_Tp __k, _Tpn __nu) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
return __detail::__comp_ellint_3<__type>(__k, __nu);
}
inline float cyl_bessel_if(float __nu, float __x) {
return __detail::__cyl_bessel_i<float>(__nu, __x);
}

inline long double cyl_bessel_il(long double __nu, long double __x) {
return __detail::__cyl_bessel_i<long double>(__nu, __x);
}
template <typename _Tpnu, typename _Tp>
inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_i(
_Tpnu __nu, _Tp __x) {
typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
return __detail::__cyl_bessel_i<__type>(__nu, __x);
}
inline float cyl_bessel_jf(float __nu, float __x) {
return __detail::__cyl_bessel_j<float>(__nu, __x);
}

inline long double cyl_bessel_jl(long double __nu, long double __x) {
return __detail::__cyl_bessel_j<long double>(__nu, __x);
}
template <typename _Tpnu, typename _Tp>
inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_j(
_Tpnu __nu, _Tp __x) {
typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
return __detail::__cyl_bessel_j<__type>(__nu, __x);
}
inline float cyl_bessel_kf(float __nu, float __x) {
return __detail::__cyl_bessel_k<float>(__nu, __x);
}

inline long double cyl_bessel_kl(long double __nu, long double __x) {
return __detail::__cyl_bessel_k<long double>(__nu, __x);
}
template <typename _Tpnu, typename _Tp>
inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_k(
_Tpnu __nu, _Tp __x) {
typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
return __detail::__cyl_bessel_k<__type>(__nu, __x);
}
inline float cyl_neumannf(float __nu, float __x) {
return __detail::__cyl_neumann_n<float>(__nu, __x);
}

inline long double cyl_neumannl(long double __nu, long double __x) {
return __detail::__cyl_neumann_n<long double>(__nu, __x);
}
template <typename _Tpnu, typename _Tp>
inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_neumann(
_Tpnu __nu, _Tp __x) {
typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
return __detail::__cyl_neumann_n<__type>(__nu, __x);
}
inline float ellint_1f(float __k, float __phi) {
return __detail::__ellint_1<float>(__k, __phi);
}

inline long double ellint_1l(long double __k, long double __phi) {
return __detail::__ellint_1<long double>(__k, __phi);
}
template <typename _Tp, typename _Tpp>
inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_1(
_Tp __k, _Tpp __phi) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
return __detail::__ellint_1<__type>(__k, __phi);
}
inline float ellint_2f(float __k, float __phi) {
return __detail::__ellint_2<float>(__k, __phi);
}

inline long double ellint_2l(long double __k, long double __phi) {
return __detail::__ellint_2<long double>(__k, __phi);
}
template <typename _Tp, typename _Tpp>
inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_2(
_Tp __k, _Tpp __phi) {
typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
return __detail::__ellint_2<__type>(__k, __phi);
}
inline float ellint_3f(float __k, float __nu, float __phi) {
return __detail::__ellint_3<float>(__k, __nu, __phi);
}

inline long double ellint_3l(long double __k, long double __nu,
long double __phi) {
return __detail::__ellint_3<long double>(__k, __nu, __phi);
}
template <typename _Tp, typename _Tpn, typename _Tpp>
inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type ellint_3(
_Tp __k, _Tpn __nu, _Tpp __phi) {
typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
return __detail::__ellint_3<__type>(__k, __nu, __phi);
}
inline float expintf(float __x) { return __detail::__expint<float>(__x); }

inline long double expintl(long double __x) {
return __detail::__expint<long double>(__x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type expint(_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__expint<__type>(__x);
}
inline float hermitef(unsigned int __n, float __x) {
return __detail::__poly_hermite<float>(__n, __x);
}

inline long double hermitel(unsigned int __n, long double __x) {
return __detail::__poly_hermite<long double>(__n, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type hermite(unsigned int __n,
_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__poly_hermite<__type>(__n, __x);
}
inline float laguerref(unsigned int __n, float __x) {
return __detail::__laguerre<float>(__n, __x);
}

inline long double laguerrel(unsigned int __n, long double __x) {
return __detail::__laguerre<long double>(__n, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type laguerre(unsigned int __n,
_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__laguerre<__type>(__n, __x);
}
inline float legendref(unsigned int __l, float __x) {
return __detail::__poly_legendre_p<float>(__l, __x);
}

inline long double legendrel(unsigned int __l, long double __x) {
return __detail::__poly_legendre_p<long double>(__l, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type legendre(unsigned int __l,
_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__poly_legendre_p<__type>(__l, __x);
}
inline float riemann_zetaf(float __s) {
return __detail::__riemann_zeta<float>(__s);
}

inline long double riemann_zetal(long double __s) {
return __detail::__riemann_zeta<long double>(__s);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type riemann_zeta(_Tp __s) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__riemann_zeta<__type>(__s);
}
inline float sph_besself(unsigned int __n, float __x) {
return __detail::__sph_bessel<float>(__n, __x);
}

inline long double sph_bessell(unsigned int __n, long double __x) {
return __detail::__sph_bessel<long double>(__n, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type sph_bessel(unsigned int __n,
_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__sph_bessel<__type>(__n, __x);
}
inline float sph_legendref(unsigned int __l, unsigned int __m,
float __theta) {
return __detail::__sph_legendre<float>(__l, __m, __theta);
}
inline long double sph_legendrel(unsigned int __l, unsigned int __m,
long double __theta) {
return __detail::__sph_legendre<long double>(__l, __m, __theta);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type sph_legendre(
unsigned int __l, unsigned int __m, _Tp __theta) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__sph_legendre<__type>(__l, __m, __theta);
}
inline float sph_neumannf(unsigned int __n, float __x) {
return __detail::__sph_neumann<float>(__n, __x);
}

inline long double sph_neumannl(unsigned int __n, long double __x) {
return __detail::__sph_neumann<long double>(__n, __x);
}
template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type sph_neumann(
unsigned int __n, _Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
return __detail::__sph_neumann<__type>(__n, __x);
}

} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

inline float airy_aif(float __x) {
float __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
return __Ai;
}

inline long double airy_ail(long double __x) {
long double __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
return __Ai;
}

template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type airy_ai(_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
__type __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
return __Ai;
}

inline float airy_bif(float __x) {
float __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
return __Bi;
}

inline long double airy_bil(long double __x) {
long double __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
return __Bi;
}

template <typename _Tp>
inline typename __gnu_cxx::__promote<_Tp>::__type airy_bi(_Tp __x) {
typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
__type __Ai, __Bi, __Aip, __Bip;
std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
return __Bi;
}
inline float conf_hypergf(float __a, float __c, float __x) {
return std::__detail::__conf_hyperg<float>(__a, __c, __x);
}
inline long double conf_hypergl(long double __a, long double __c,
long double __x) {
return std::__detail::__conf_hyperg<long double>(__a, __c, __x);
}
template <typename _Tpa, typename _Tpc, typename _Tp>
inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type conf_hyperg(
_Tpa __a, _Tpc __c, _Tp __x) {
typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
}
inline float hypergf(float __a, float __b, float __c, float __x) {
return std::__detail::__hyperg<float>(__a, __b, __c, __x);
}
inline long double hypergl(long double __a, long double __b, long double __c,
long double __x) {
return std::__detail::__hyperg<long double>(__a, __b, __c, __x);
}
template <typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type hyperg(
_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x) {
typedef
typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type __type;
return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
}

} // namespace __gnu_cxx

#pragma GCC visibility pop
}

enum {
FE_INVALID =

0x01,
__FE_DENORM = 0x02,
FE_DIVBYZERO =

0x04,
FE_OVERFLOW =

0x08,
FE_UNDERFLOW =

0x10,
FE_INEXACT =

0x20
};

enum {
FE_TONEAREST =

0,
FE_DOWNWARD =

0x400,
FE_UPWARD =

0x800,
FE_TOWARDZERO =

0xc00
};

typedef unsigned short int fexcept_t;

typedef struct {
unsigned short int __control_word;
unsigned short int __glibc_reserved1;
unsigned short int __status_word;
unsigned short int __glibc_reserved2;
unsigned short int __tags;
unsigned short int __glibc_reserved3;
unsigned int __eip;
unsigned short int __cs_selector;
unsigned int __opcode : 11;
unsigned int __glibc_reserved4 : 5;
unsigned int __data_offset;
unsigned short int __data_selector;
unsigned short int __glibc_reserved5;

unsigned int __mxcsr;

} fenv_t;
typedef struct {
unsigned short int __control_word;
unsigned short int __glibc_reserved;
unsigned int __mxcsr;
} femode_t;

extern "C" {

extern int feclearexcept(int __excepts) noexcept(true);

extern int fegetexceptflag(fexcept_t *__flagp, int __excepts) noexcept(true);

extern int feraiseexcept(int __excepts) noexcept(true);

extern int fesetexcept(int __excepts) noexcept(true);

extern int fesetexceptflag(const fexcept_t *__flagp,
int __excepts) noexcept(true);

extern int fetestexcept(int __excepts) noexcept(true);

extern int fetestexceptflag(const fexcept_t *__flagp,
int __excepts) noexcept(true);

extern int fegetround(void) noexcept(true) __attribute__((__pure__));

extern int fesetround(int __rounding_direction) noexcept(true);

extern int fegetenv(fenv_t *__envp) noexcept(true);

extern int feholdexcept(fenv_t *__envp) noexcept(true);

extern int fesetenv(const fenv_t *__envp) noexcept(true);

extern int feupdateenv(const fenv_t *__envp) noexcept(true);

extern int fegetmode(femode_t *__modep) noexcept(true);

extern int fesetmode(const femode_t *__modep) noexcept(true);
extern int feenableexcept(int __excepts) noexcept(true);

extern int fedisableexcept(int __excepts) noexcept(true);

extern int fegetexcept(void) noexcept(true);
}
namespace std {

using ::fenv_t;
using ::fexcept_t;

using ::feclearexcept;
using ::fegetexceptflag;
using ::feraiseexcept;
using ::fesetexceptflag;
using ::fetestexcept;

using ::fegetround;
using ::fesetround;

using ::fegetenv;
using ::feholdexcept;
using ::fesetenv;
using ::feupdateenv;
} // namespace std
namespace std {

using ::fenv_t;
using ::fexcept_t;

using ::feclearexcept;
using ::fegetexceptflag;
using ::feraiseexcept;
using ::fesetexceptflag;
using ::fetestexcept;

using ::fegetround;
using ::fesetround;

using ::fegetenv;
using ::feholdexcept;
using ::fesetenv;
using ::feupdateenv;
} // namespace std

template <typename R, typename... Args>
inline static constexpr auto Specialize(R (*)(Args...), R (*b)(Args...))
-> R (*)(Args...) {
return b;
}

typedef long int ptrdiff_t;
typedef struct {
long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
long double __max_align_ld
__attribute__((__aligned__(__alignof__(long double))));
} max_align_t;

typedef decltype(nullptr) nullptr_t;

extern "C++" {

namespace std {

using ::max_align_t;
}

namespace std {

enum class byte : unsigned char {};

template <typename _IntegerType> struct __byte_operand {};
template <> struct __byte_operand<bool> {
using __type = byte;
};
template <> struct __byte_operand<char> {
using __type = byte;
};
template <> struct __byte_operand<signed char> {
using __type = byte;
};
template <> struct __byte_operand<unsigned char> {
using __type = byte;
};
template <> struct __byte_operand<wchar_t> {
using __type = byte;
};

template <> struct __byte_operand<char16_t> {
using __type = byte;
};
template <> struct __byte_operand<char32_t> {
using __type = byte;
};
template <> struct __byte_operand<short> {
using __type = byte;
};
template <> struct __byte_operand<unsigned short> {
using __type = byte;
};
template <> struct __byte_operand<int> {
using __type = byte;
};
template <> struct __byte_operand<unsigned int> {
using __type = byte;
};
template <> struct __byte_operand<long> {
using __type = byte;
};
template <> struct __byte_operand<unsigned long> {
using __type = byte;
};
template <> struct __byte_operand<long long> {
using __type = byte;
};
template <> struct __byte_operand<unsigned long long> {
using __type = byte;
};

template <> struct __byte_operand<__int128> {
using __type = byte;
};
template <> struct __byte_operand<unsigned __int128> {
using __type = byte;
};
template <typename _IntegerType>
struct __byte_operand<const _IntegerType> : __byte_operand<_IntegerType> {};
template <typename _IntegerType>
struct __byte_operand<volatile _IntegerType> : __byte_operand<_IntegerType> {};
template <typename _IntegerType>
struct __byte_operand<const volatile _IntegerType>
: __byte_operand<_IntegerType> {};

template <typename _IntegerType>
using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

template <typename _IntegerType>
constexpr __byte_op_t<_IntegerType> operator<<(byte __b,
_IntegerType __shift) noexcept {
return (byte)(unsigned char)((unsigned)__b << __shift);
}

template <typename _IntegerType>
constexpr __byte_op_t<_IntegerType> operator>>(byte __b,
_IntegerType __shift) noexcept {
return (byte)(unsigned char)((unsigned)__b >> __shift);
}

constexpr byte operator|(byte __l, byte __r) noexcept {
return (byte)(unsigned char)((unsigned)__l | (unsigned)__r);
}

constexpr byte operator&(byte __l, byte __r) noexcept {
return (byte)(unsigned char)((unsigned)__l & (unsigned)__r);
}

constexpr byte operator^(byte __l, byte __r) noexcept {
return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r);
}

constexpr byte operator~(byte __b) noexcept {
return (byte)(unsigned char)~(unsigned)__b;
}

template <typename _IntegerType>
constexpr __byte_op_t<_IntegerType> &
operator<<=(byte &__b, _IntegerType __shift) noexcept {
return __b = __b << __shift;
}

template <typename _IntegerType>
constexpr __byte_op_t<_IntegerType> &
operator>>=(byte &__b, _IntegerType __shift) noexcept {
return __b = __b >> __shift;
}

constexpr byte &operator|=(byte &__l, byte __r) noexcept {
return __l = __l | __r;
}

constexpr byte &operator&=(byte &__l, byte __r) noexcept {
return __l = __l & __r;
}

constexpr byte &operator^=(byte &__l, byte __r) noexcept {
return __l = __l ^ __r;
}

template <typename _IntegerType>
[[nodiscard]] constexpr _IntegerType
to_integer(__byte_op_t<_IntegerType> __b) noexcept {
return _IntegerType(__b);
}

} // namespace std
}

typedef unsigned uint128_t __attribute__((mode(TI)));
typedef int int128_t __attribute__((mode(TI)));
static_assert(sizeof(int128_t) == 16, "Invalid size for `int128_t`.");
static_assert(sizeof(uint128_t) == 16, "Invalid size for `uint128_t`.");

typedef float float32_t;
static_assert(4 == sizeof(float32_t), "Invalid `float32_t` size.");

typedef double float64_t;
static_assert(8 == sizeof(float64_t), "Invalid `float64_t` size.");

typedef double float128_t;
static_assert(8 == sizeof(float128_t), "Invalid `float128_t` size.");
typedef long double native_float80_t;

static_assert(10 <= sizeof(native_float80_t),
"Invalid `native_float80_t` size.");

static const int kEightyBitsInBytes = 10;
union union_ld {
struct {
uint8_t data[kEightyBitsInBytes];
uint8_t padding[sizeof(native_float80_t) - kEightyBitsInBytes];

} lds __attribute__((packed));
native_float80_t ld;
} __attribute__((packed));

static void *memset_impl(void *b, int c, std::size_t len) {
auto *p = static_cast<int *>(b);
for (std::size_t i = 0; i < len; ++i) {
p[i] = c;
}
return b;
}

static void *memcpy_impl(void *dst, const void *src, std::size_t n) {
auto *d = static_cast<int *>(dst);
const auto *s = static_cast<const int *>(src);
for (std::size_t i = 0; i < n; ++i) {
d[i] = s[i];
}
return dst;
}

struct float80_t final {
uint8_t data[kEightyBitsInBytes];

inline ~float80_t(void) = default;
inline float80_t(void)
: data{
0,
} {}

float80_t(const float80_t &) = default;
float80_t &operator=(const float80_t &) = default;

inline float80_t(native_float80_t ld) {
union_ld ldu;
memset_impl(&ldu, 0, sizeof(ldu));
ldu.ld = ld;

memcpy_impl(&data[0], &ldu.lds.data[0], sizeof(data));
}

operator native_float80_t() {
union_ld ldu;
memset_impl(&ldu, 0, sizeof(ldu));

memcpy_impl(&ldu.lds.data[0], &data[0], sizeof(data));

return ldu.ld;
}
} __attribute__((packed));

union nan32_t {
float32_t f;
uint32_t flat;
struct {
uint32_t payload : 22;
uint32_t is_quiet_nan : 1;
uint32_t exponent : 8;
uint32_t is_negative : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(float32_t) == sizeof(nan32_t),
"Invalid packing of `nan32_t`.");

union nan64_t {
float64_t d;
uint64_t flat;
struct {
uint64_t payload : 51;
uint64_t is_quiet_nan : 1;
uint64_t exponent : 11;
uint64_t is_negative : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(float64_t) == sizeof(nan64_t),
"Invalid packing of `nan64_t`.");

union nan80_t {
float80_t d;
struct {
uint64_t payload : 62;
uint64_t is_quiet_nan : 1;
uint64_t interger_bit : 1;
uint64_t exponent : 15;
uint64_t is_negative : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(float80_t) == sizeof(nan80_t),
"Invalid packing of `nan80_t`.");

class SyncHyperCall {
public:
enum Name : uint32_t {
kInvalid,
kAssertPrivileged,

kX86EmulateInstruction = 0x100U,
kAMD64EmulateInstruction,

kX86CPUID,
kX86ReadTSC,
kX86ReadTSCP,
kX86LoadGlobalDescriptorTable,
kX86LoadInterruptDescriptorTable,
kX86ReadModelSpecificRegister,
kX86WriteModelSpecificRegister,
kX86WriteBackInvalidate,

kX86SetSegmentES,
kX86SetSegmentSS,
kX86SetSegmentDS,
kX86SetSegmentFS,
kX86SetSegmentGS,

kX86SetDebugReg,
kAMD64SetDebugReg,

kX86SetControlReg0,
kX86SetControlReg1,
kX86SetControlReg2,
kX86SetControlReg3,
kX86SetControlReg4,
kAMD64SetControlReg0,
kAMD64SetControlReg1,
kAMD64SetControlReg2,
kAMD64SetControlReg3,
kAMD64SetControlReg4,
kAMD64SetControlReg8,

kX86SysCall,
kX86SysEnter,
kX86SysExit,

kAArch64EmulateInstruction = 0x200U,
kAArch64Breakpoint,
kAArch32EmulateInstruction = 0x300U,

kAArch32CheckNotEL2,

kSPARC32EmulateInstruction = 0x400U,
kSPARC64EmulateInstruction,
kSPARCSetAsiRegister,
kSPARCTagOverflow,

kSPARCUnimplementedInstruction,
kSPARCUnhandledDCTI,
kSPARCWindowUnderflow,

kSPARCTrapCondA,
kSPARCTrapCondN,
kSPARCTrapCondNE,
kSPARCTrapCondE,
kSPARCTrapCondG,
kSPARCTrapCondLE,
kSPARCTrapCondGE,
kSPARCTrapCondL,
kSPARCTrapCondGU,
kSPARCTrapCondLEU,
kSPARCTrapCondCC,
kSPARCTrapCondCS,
kSPARCTrapCondPOS,
kSPARCTrapCondNEG,
kSPARCTrapCondVC,
kSPARCTrapCondVS,

kPPCEmulateInstruction,
kPPCSysCall,
};
} __attribute__((packed));

class AsyncHyperCall {
public:
enum Name : uint32_t {
kInvalid,

kX86Int1,
kX86Int3,
kX86IntO,
kX86IntN,
kX86Bound,

kX86IRet,

kX86SysCall,
kX86SysRet,

kX86SysEnter,
kX86SysExit,

kX86JmpFar,

kAArch64SupervisorCall,

kSPARCTagOverflowAdd,
kSPARCTagOverflowSub,

kSPARCUnimplementedInstruction,

kSPARCTrapCondA,
kSPARCTrapCondN,
kSPARCTrapCondNE,
kSPARCTrapCondE,
kSPARCTrapCondG,
kSPARCTrapCondLE,
kSPARCTrapCondGE,
kSPARCTrapCondL,
kSPARCTrapCondGU,
kSPARCTrapCondLEU,
kSPARCTrapCondCC,
kSPARCTrapCondCS,
kSPARCTrapCondPOS,
kSPARCTrapCondNEG,
kSPARCTrapCondVC,
kSPARCTrapCondVS,

kInvalidInstruction
};
} __attribute__((packed));

#pragma clang diagnostic push
#pragma clang diagnostic fatal "-Wpadded"

struct State;
struct Memory;
struct RegisterWindow;

typedef uint16_t addr16_t;
typedef uint32_t addr32_t;
typedef uint64_t addr64_t;
typedef addr64_t addr_t;
typedef int64_t addr_diff_t;

typedef addr64_t addr_t;
typedef int64_t addr_diff_t;
template <typename T> struct is_signed {

static constexpr bool value = std::is_signed<T>::value;
};

template <typename T> struct is_unsigned {

static constexpr bool value = std::is_unsigned<T>::value;
};

template <> struct is_signed<int128_t> {
static constexpr bool value = true;
};

template <> struct is_unsigned<int128_t> {
static constexpr bool value = false;
};

template <> struct is_signed<uint128_t> {
static constexpr bool value = false;
};

template <> struct is_unsigned<uint128_t> {
static constexpr bool value = true;
};

template <typename T> struct VectorType;

template <typename T> struct VectorType<T &> : public VectorType<T> {};

template <typename T> struct VectorType<const T> : public VectorType<T> {};

union vec8_t;
union vec16_t;
union vec32_t;
union vec64_t;
union vec128_t;
union vec256_t;
union vec512_t;
struct uint8v1_t final {
uint8_t elems[1];
} __attribute__((packed));
static_assert(1 == sizeof(uint8v1_t), "Invalid definition of `"
"uint8"
"v"
"1"
"`.");
static_assert((1 * 8) == 8, "Invalid definition of `"
"uint8"
"v"
"1"
"`.");
template <> struct VectorType<uint8v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec8_t T;
typedef vec8_t Type;
};
struct uint8v2_t final {
uint8_t elems[2];
} __attribute__((packed));
static_assert(2 == sizeof(uint8v2_t), "Invalid definition of `"
"uint8"
"v"
"2"
"`.");
static_assert((2 * 8) == 16, "Invalid definition of `"
"uint8"
"v"
"2"
"`.");
template <> struct VectorType<uint8v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec16_t T;
typedef vec16_t Type;
};
struct uint8v4_t final {
uint8_t elems[4];
} __attribute__((packed));
static_assert(4 == sizeof(uint8v4_t), "Invalid definition of `"
"uint8"
"v"
"4"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"uint8"
"v"
"4"
"`.");
template <> struct VectorType<uint8v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct uint8v8_t final {
uint8_t elems[8];
} __attribute__((packed));
static_assert(8 == sizeof(uint8v8_t), "Invalid definition of `"
"uint8"
"v"
"8"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"uint8"
"v"
"8"
"`.");
template <> struct VectorType<uint8v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct uint8v16_t final {
uint8_t elems[16];
} __attribute__((packed));
static_assert(16 == sizeof(uint8v16_t), "Invalid definition of `"
"uint8"
"v"
"16"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"uint8"
"v"
"16"
"`.");
template <> struct VectorType<uint8v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct uint8v32_t final {
uint8_t elems[32];
} __attribute__((packed));
static_assert(32 == sizeof(uint8v32_t), "Invalid definition of `"
"uint8"
"v"
"32"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"uint8"
"v"
"32"
"`.");
template <> struct VectorType<uint8v32_t> {
enum : std::size_t { kNumElems = 32 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct uint8v64_t final {
uint8_t elems[64];
} __attribute__((packed));
static_assert(64 == sizeof(uint8v64_t), "Invalid definition of `"
"uint8"
"v"
"64"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"uint8"
"v"
"64"
"`.");
template <> struct VectorType<uint8v64_t> {
enum : std::size_t { kNumElems = 64 };
typedef uint8_t BT;
typedef uint8_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct uint16v1_t final {
uint16_t elems[1];
} __attribute__((packed));
static_assert(2 == sizeof(uint16v1_t), "Invalid definition of `"
"uint16"
"v"
"1"
"`.");
static_assert((2 * 8) == 16, "Invalid definition of `"
"uint16"
"v"
"1"
"`.");
template <> struct VectorType<uint16v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec16_t T;
typedef vec16_t Type;
};
struct uint16v2_t final {
uint16_t elems[2];
} __attribute__((packed));
static_assert(4 == sizeof(uint16v2_t), "Invalid definition of `"
"uint16"
"v"
"2"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"uint16"
"v"
"2"
"`.");
template <> struct VectorType<uint16v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct uint16v4_t final {
uint16_t elems[4];
} __attribute__((packed));
static_assert(8 == sizeof(uint16v4_t), "Invalid definition of `"
"uint16"
"v"
"4"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"uint16"
"v"
"4"
"`.");
template <> struct VectorType<uint16v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct uint16v8_t final {
uint16_t elems[8];
} __attribute__((packed));
static_assert(16 == sizeof(uint16v8_t), "Invalid definition of `"
"uint16"
"v"
"8"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"uint16"
"v"
"8"
"`.");
template <> struct VectorType<uint16v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct uint16v16_t final {
uint16_t elems[16];
} __attribute__((packed));
static_assert(32 == sizeof(uint16v16_t), "Invalid definition of `"
"uint16"
"v"
"16"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"uint16"
"v"
"16"
"`.");
template <> struct VectorType<uint16v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct uint16v32_t final {
uint16_t elems[32];
} __attribute__((packed));
static_assert(64 == sizeof(uint16v32_t), "Invalid definition of `"
"uint16"
"v"
"32"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"uint16"
"v"
"32"
"`.");
template <> struct VectorType<uint16v32_t> {
enum : std::size_t { kNumElems = 32 };
typedef uint16_t BT;
typedef uint16_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct uint32v1_t final {
uint32_t elems[1];
} __attribute__((packed));
static_assert(4 == sizeof(uint32v1_t), "Invalid definition of `"
"uint32"
"v"
"1"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"uint32"
"v"
"1"
"`.");
template <> struct VectorType<uint32v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef uint32_t BT;
typedef uint32_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct uint32v2_t final {
uint32_t elems[2];
} __attribute__((packed));
static_assert(8 == sizeof(uint32v2_t), "Invalid definition of `"
"uint32"
"v"
"2"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"uint32"
"v"
"2"
"`.");
template <> struct VectorType<uint32v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef uint32_t BT;
typedef uint32_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct uint32v4_t final {
uint32_t elems[4];
} __attribute__((packed));
static_assert(16 == sizeof(uint32v4_t), "Invalid definition of `"
"uint32"
"v"
"4"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"uint32"
"v"
"4"
"`.");
template <> struct VectorType<uint32v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef uint32_t BT;
typedef uint32_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct uint32v8_t final {
uint32_t elems[8];
} __attribute__((packed));
static_assert(32 == sizeof(uint32v8_t), "Invalid definition of `"
"uint32"
"v"
"8"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"uint32"
"v"
"8"
"`.");
template <> struct VectorType<uint32v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef uint32_t BT;
typedef uint32_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct uint32v16_t final {
uint32_t elems[16];
} __attribute__((packed));
static_assert(64 == sizeof(uint32v16_t), "Invalid definition of `"
"uint32"
"v"
"16"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"uint32"
"v"
"16"
"`.");
template <> struct VectorType<uint32v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef uint32_t BT;
typedef uint32_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct uint64v1_t final {
uint64_t elems[1];
} __attribute__((packed));
static_assert(8 == sizeof(uint64v1_t), "Invalid definition of `"
"uint64"
"v"
"1"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"uint64"
"v"
"1"
"`.");
template <> struct VectorType<uint64v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef uint64_t BT;
typedef uint64_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct uint64v2_t final {
uint64_t elems[2];
} __attribute__((packed));
static_assert(16 == sizeof(uint64v2_t), "Invalid definition of `"
"uint64"
"v"
"2"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"uint64"
"v"
"2"
"`.");
template <> struct VectorType<uint64v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef uint64_t BT;
typedef uint64_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct uint64v4_t final {
uint64_t elems[4];
} __attribute__((packed));
static_assert(32 == sizeof(uint64v4_t), "Invalid definition of `"
"uint64"
"v"
"4"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"uint64"
"v"
"4"
"`.");
template <> struct VectorType<uint64v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef uint64_t BT;
typedef uint64_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct uint64v8_t final {
uint64_t elems[8];
} __attribute__((packed));
static_assert(64 == sizeof(uint64v8_t), "Invalid definition of `"
"uint64"
"v"
"8"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"uint64"
"v"
"8"
"`.");
template <> struct VectorType<uint64v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef uint64_t BT;
typedef uint64_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct uint128v1_t final {
uint128_t elems[1];
} __attribute__((packed));
static_assert(16 == sizeof(uint128v1_t), "Invalid definition of `"
"uint128"
"v"
"1"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"uint128"
"v"
"1"
"`.");
template <> struct VectorType<uint128v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef uint128_t BT;
typedef uint128_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct uint128v2_t final {
uint128_t elems[2];
} __attribute__((packed));
static_assert(32 == sizeof(uint128v2_t), "Invalid definition of `"
"uint128"
"v"
"2"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"uint128"
"v"
"2"
"`.");
template <> struct VectorType<uint128v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef uint128_t BT;
typedef uint128_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct uint128v4_t final {
uint128_t elems[4];
} __attribute__((packed));
static_assert(64 == sizeof(uint128v4_t), "Invalid definition of `"
"uint128"
"v"
"4"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"uint128"
"v"
"4"
"`.");
template <> struct VectorType<uint128v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef uint128_t BT;
typedef uint128_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct int8v1_t final {
int8_t elems[1];
} __attribute__((packed));
static_assert(1 == sizeof(int8v1_t), "Invalid definition of `"
"int8"
"v"
"1"
"`.");
static_assert((1 * 8) == 8, "Invalid definition of `"
"int8"
"v"
"1"
"`.");
template <> struct VectorType<int8v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec8_t T;
typedef vec8_t Type;
};
struct int8v2_t final {
int8_t elems[2];
} __attribute__((packed));
static_assert(2 == sizeof(int8v2_t), "Invalid definition of `"
"int8"
"v"
"2"
"`.");
static_assert((2 * 8) == 16, "Invalid definition of `"
"int8"
"v"
"2"
"`.");
template <> struct VectorType<int8v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec16_t T;
typedef vec16_t Type;
};
struct int8v4_t final {
int8_t elems[4];
} __attribute__((packed));
static_assert(4 == sizeof(int8v4_t), "Invalid definition of `"
"int8"
"v"
"4"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"int8"
"v"
"4"
"`.");
template <> struct VectorType<int8v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct int8v8_t final {
int8_t elems[8];
} __attribute__((packed));
static_assert(8 == sizeof(int8v8_t), "Invalid definition of `"
"int8"
"v"
"8"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"int8"
"v"
"8"
"`.");
template <> struct VectorType<int8v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct int8v16_t final {
int8_t elems[16];
} __attribute__((packed));
static_assert(16 == sizeof(int8v16_t), "Invalid definition of `"
"int8"
"v"
"16"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"int8"
"v"
"16"
"`.");
template <> struct VectorType<int8v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct int8v32_t final {
int8_t elems[32];
} __attribute__((packed));
static_assert(32 == sizeof(int8v32_t), "Invalid definition of `"
"int8"
"v"
"32"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"int8"
"v"
"32"
"`.");
template <> struct VectorType<int8v32_t> {
enum : std::size_t { kNumElems = 32 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct int8v64_t final {
int8_t elems[64];
} __attribute__((packed));
static_assert(64 == sizeof(int8v64_t), "Invalid definition of `"
"int8"
"v"
"64"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"int8"
"v"
"64"
"`.");
template <> struct VectorType<int8v64_t> {
enum : std::size_t { kNumElems = 64 };
typedef int8_t BT;
typedef int8_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct int16v1_t final {
int16_t elems[1];
} __attribute__((packed));
static_assert(2 == sizeof(int16v1_t), "Invalid definition of `"
"int16"
"v"
"1"
"`.");
static_assert((2 * 8) == 16, "Invalid definition of `"
"int16"
"v"
"1"
"`.");
template <> struct VectorType<int16v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec16_t T;
typedef vec16_t Type;
};
struct int16v2_t final {
int16_t elems[2];
} __attribute__((packed));
static_assert(4 == sizeof(int16v2_t), "Invalid definition of `"
"int16"
"v"
"2"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"int16"
"v"
"2"
"`.");
template <> struct VectorType<int16v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct int16v4_t final {
int16_t elems[4];
} __attribute__((packed));
static_assert(8 == sizeof(int16v4_t), "Invalid definition of `"
"int16"
"v"
"4"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"int16"
"v"
"4"
"`.");
template <> struct VectorType<int16v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct int16v8_t final {
int16_t elems[8];
} __attribute__((packed));
static_assert(16 == sizeof(int16v8_t), "Invalid definition of `"
"int16"
"v"
"8"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"int16"
"v"
"8"
"`.");
template <> struct VectorType<int16v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct int16v16_t final {
int16_t elems[16];
} __attribute__((packed));
static_assert(32 == sizeof(int16v16_t), "Invalid definition of `"
"int16"
"v"
"16"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"int16"
"v"
"16"
"`.");
template <> struct VectorType<int16v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct int16v32_t final {
int16_t elems[32];
} __attribute__((packed));
static_assert(64 == sizeof(int16v32_t), "Invalid definition of `"
"int16"
"v"
"32"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"int16"
"v"
"32"
"`.");
template <> struct VectorType<int16v32_t> {
enum : std::size_t { kNumElems = 32 };
typedef int16_t BT;
typedef int16_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct int32v1_t final {
int32_t elems[1];
} __attribute__((packed));
static_assert(4 == sizeof(int32v1_t), "Invalid definition of `"
"int32"
"v"
"1"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"int32"
"v"
"1"
"`.");
template <> struct VectorType<int32v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef int32_t BT;
typedef int32_t BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct int32v2_t final {
int32_t elems[2];
} __attribute__((packed));
static_assert(8 == sizeof(int32v2_t), "Invalid definition of `"
"int32"
"v"
"2"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"int32"
"v"
"2"
"`.");
template <> struct VectorType<int32v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef int32_t BT;
typedef int32_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct int32v4_t final {
int32_t elems[4];
} __attribute__((packed));
static_assert(16 == sizeof(int32v4_t), "Invalid definition of `"
"int32"
"v"
"4"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"int32"
"v"
"4"
"`.");
template <> struct VectorType<int32v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef int32_t BT;
typedef int32_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct int32v8_t final {
int32_t elems[8];
} __attribute__((packed));
static_assert(32 == sizeof(int32v8_t), "Invalid definition of `"
"int32"
"v"
"8"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"int32"
"v"
"8"
"`.");
template <> struct VectorType<int32v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef int32_t BT;
typedef int32_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct int32v16_t final {
int32_t elems[16];
} __attribute__((packed));
static_assert(64 == sizeof(int32v16_t), "Invalid definition of `"
"int32"
"v"
"16"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"int32"
"v"
"16"
"`.");
template <> struct VectorType<int32v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef int32_t BT;
typedef int32_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct int64v1_t final {
int64_t elems[1];
} __attribute__((packed));
static_assert(8 == sizeof(int64v1_t), "Invalid definition of `"
"int64"
"v"
"1"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"int64"
"v"
"1"
"`.");
template <> struct VectorType<int64v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef int64_t BT;
typedef int64_t BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct int64v2_t final {
int64_t elems[2];
} __attribute__((packed));
static_assert(16 == sizeof(int64v2_t), "Invalid definition of `"
"int64"
"v"
"2"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"int64"
"v"
"2"
"`.");
template <> struct VectorType<int64v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef int64_t BT;
typedef int64_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct int64v4_t final {
int64_t elems[4];
} __attribute__((packed));
static_assert(32 == sizeof(int64v4_t), "Invalid definition of `"
"int64"
"v"
"4"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"int64"
"v"
"4"
"`.");
template <> struct VectorType<int64v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef int64_t BT;
typedef int64_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct int64v8_t final {
int64_t elems[8];
} __attribute__((packed));
static_assert(64 == sizeof(int64v8_t), "Invalid definition of `"
"int64"
"v"
"8"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"int64"
"v"
"8"
"`.");
template <> struct VectorType<int64v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef int64_t BT;
typedef int64_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct int128v1_t final {
int128_t elems[1];
} __attribute__((packed));
static_assert(16 == sizeof(int128v1_t), "Invalid definition of `"
"int128"
"v"
"1"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"int128"
"v"
"1"
"`.");
template <> struct VectorType<int128v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef int128_t BT;
typedef int128_t BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct int128v2_t final {
int128_t elems[2];
} __attribute__((packed));
static_assert(32 == sizeof(int128v2_t), "Invalid definition of `"
"int128"
"v"
"2"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"int128"
"v"
"2"
"`.");
template <> struct VectorType<int128v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef int128_t BT;
typedef int128_t BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct int128v4_t final {
int128_t elems[4];
} __attribute__((packed));
static_assert(64 == sizeof(int128v4_t), "Invalid definition of `"
"int128"
"v"
"4"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"int128"
"v"
"4"
"`.");
template <> struct VectorType<int128v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef int128_t BT;
typedef int128_t BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct float32v1_t final {
float elems[1];
} __attribute__((packed));
static_assert(4 == sizeof(float32v1_t), "Invalid definition of `"
"float32"
"v"
"1"
"`.");
static_assert((4 * 8) == 32, "Invalid definition of `"
"float32"
"v"
"1"
"`.");
template <> struct VectorType<float32v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef float BT;
typedef float BaseType;
typedef vec32_t T;
typedef vec32_t Type;
};
struct float32v2_t final {
float elems[2];
} __attribute__((packed));
static_assert(8 == sizeof(float32v2_t), "Invalid definition of `"
"float32"
"v"
"2"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"float32"
"v"
"2"
"`.");
template <> struct VectorType<float32v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef float BT;
typedef float BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
struct float32v4_t final {
float elems[4];
} __attribute__((packed));
static_assert(16 == sizeof(float32v4_t), "Invalid definition of `"
"float32"
"v"
"4"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"float32"
"v"
"4"
"`.");
template <> struct VectorType<float32v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef float BT;
typedef float BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
struct float32v8_t final {
float elems[8];
} __attribute__((packed));
static_assert(32 == sizeof(float32v8_t), "Invalid definition of `"
"float32"
"v"
"8"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"float32"
"v"
"8"
"`.");
template <> struct VectorType<float32v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef float BT;
typedef float BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
struct float32v16_t final {
float elems[16];
} __attribute__((packed));
static_assert(64 == sizeof(float32v16_t), "Invalid definition of `"
"float32"
"v"
"16"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"float32"
"v"
"16"
"`.");
template <> struct VectorType<float32v16_t> {
enum : std::size_t { kNumElems = 16 };
typedef float BT;
typedef float BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};

struct float64v1_t final {
double elems[1];
} __attribute__((packed));
static_assert(8 == sizeof(float64v1_t), "Invalid definition of `"
"float64"
"v"
"1"
"`.");
static_assert((8 * 8) == 64, "Invalid definition of `"
"float64"
"v"
"1"
"`.");
template <> struct VectorType<float64v1_t> {
enum : std::size_t { kNumElems = 1 };
typedef double BT;
typedef double BaseType;
typedef vec64_t T;
typedef vec64_t Type;
};
;
struct float64v2_t final {
double elems[2];
} __attribute__((packed));
static_assert(16 == sizeof(float64v2_t), "Invalid definition of `"
"float64"
"v"
"2"
"`.");
static_assert((16 * 8) == 128, "Invalid definition of `"
"float64"
"v"
"2"
"`.");
template <> struct VectorType<float64v2_t> {
enum : std::size_t { kNumElems = 2 };
typedef double BT;
typedef double BaseType;
typedef vec128_t T;
typedef vec128_t Type;
};
;
struct float64v4_t final {
double elems[4];
} __attribute__((packed));
static_assert(32 == sizeof(float64v4_t), "Invalid definition of `"
"float64"
"v"
"4"
"`.");
static_assert((32 * 8) == 256, "Invalid definition of `"
"float64"
"v"
"4"
"`.");
template <> struct VectorType<float64v4_t> {
enum : std::size_t { kNumElems = 4 };
typedef double BT;
typedef double BaseType;
typedef vec256_t T;
typedef vec256_t Type;
};
;
struct float64v8_t final {
double elems[8];
} __attribute__((packed));
static_assert(64 == sizeof(float64v8_t), "Invalid definition of `"
"float64"
"v"
"8"
"`.");
static_assert((64 * 8) == 512, "Invalid definition of `"
"float64"
"v"
"8"
"`.");
template <> struct VectorType<float64v8_t> {
enum : std::size_t { kNumElems = 8 };
typedef double BT;
typedef double BaseType;
typedef vec512_t T;
typedef vec512_t Type;
};
;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"

union vec8_t final {
uint8v1_t bytes;
int8v1_t sbytes;
} __attribute__((packed));

static_assert(1 == sizeof(vec8_t), "Invalid structure packing of `vec8_t`.");

union vec16_t final {
uint8v2_t bytes;
uint16v1_t words;

int8v2_t sbytes;
int16v1_t swords;
} __attribute__((packed));

static_assert(2 == sizeof(vec16_t), "Invalid structure packing of `vec16_t`.");

union vec32_t final {

uint32v1_t dwords;

uint8v4_t bytes;
uint16v2_t words;
float32v1_t floats;

int8v4_t sbytes;
int16v2_t swords;
int32v1_t sdwords;
} __attribute__((packed));

static_assert(4 == sizeof(vec32_t), "Invalid structure packing of `vec32_t`.");

union vec64_t final {

uint64v1_t qwords;

uint8v8_t bytes;
uint16v4_t words;
uint32v2_t dwords;
float32v2_t floats;
float64v1_t doubles;

int8v8_t sbytes;
int16v4_t swords;
int32v2_t sdwords;
int64v1_t sqwords;
} __attribute__((packed));

#pragma clang diagnostic pop

static_assert(8 == sizeof(vec64_t), "Invalid structure packing of `vec64_t`.");

union vec128_t final {

uint128v1_t dqwords;

int128v1_t sdqwords;

uint8v16_t bytes;
uint16v8_t words;
uint32v4_t dwords;
uint64v2_t qwords;
float32v4_t floats;
float64v2_t doubles;

int8v16_t sbytes;
int16v8_t swords;
int32v4_t sdwords;
int64v2_t sqwords;
} __attribute__((packed));

static_assert(16 == sizeof(vec128_t),
"Invalid structure packing of `vec128_t`.");

union vec256_t final {
uint8v32_t bytes;
uint16v16_t words;
uint32v8_t dwords;
uint64v4_t qwords;
float32v8_t floats;
float64v4_t doubles;

int8v32_t sbytes;
int16v16_t swords;
int32v8_t sdwords;
int64v4_t sqwords;

uint128v2_t dqwords;
int128v2_t sdqwords;

} __attribute__((packed));

static_assert(32 == sizeof(vec256_t),
"Invalid structure packing of `vec256_t`.");

union vec512_t final {
uint8v64_t bytes;
uint16v32_t words;
uint32v16_t dwords;
uint64v8_t qwords;
float32v16_t floats;
float64v8_t doubles;

int8v64_t sbytes;
int16v32_t swords;
int32v16_t sdwords;
int64v8_t sqwords;

uint128v4_t dqwords;
int128v4_t sdqwords;

} __attribute__((packed));

static_assert(64 == sizeof(vec512_t),
"Invalid structure packing of `vec512_t`.");

template <typename T> struct Mn final {
addr_t addr;
};

template <typename T> struct MVn final {
addr_t addr;
};

template <typename T> struct MnW final {
addr_t addr;
};

template <typename T> struct MVnW final {
addr_t addr;
};

template <typename T, bool = sizeof(T) <= sizeof(addr_t)> struct Rn;

template <typename T> struct Rn<T, true> final {
const addr_t val;
};

template <typename T> struct Rn<T, false> final {
const T val;
};

template <typename T> struct RnW final {
T *const val_ref;
};

template <> struct Rn<float32_t> final {
const float32_t val;
};

template <> struct Rn<float64_t> final {
const float64_t val;
};

template <> struct Rn<float80_t> final {
const float80_t val;
};

template <> struct RnW<float32_t> final {
float32_t *const val_ref;
};

template <> struct RnW<float64_t> final {
float64_t *const val_ref;
};

template <typename T> struct In final {
const addr_t val;
};

template <typename T> struct RVn;

template <> struct RVn<vec64_t> final {
const uint64_t val;
};

template <> struct RVn<vec32_t> final {
const addr_t val;
};

template <> struct RVn<vec16_t> final {
const addr_t val;
};

template <> struct RVn<vec8_t> final {
const addr_t val;
};

template <typename T> struct RVnW;

template <> struct RVnW<vec32_t> final {
uint32_t *const val_ref;
};

template <> struct RVnW<vec64_t> final {
uint64_t *const val_ref;
};

template <typename T> struct Vn final {
const void *const val;
};

template <typename T> struct VnW final {
void *const val_ref;
};

template <typename T> struct BaseType {
typedef T BT;
};

template <typename T> struct BaseType<volatile T> : public BaseType<T> {};

template <typename T> struct BaseType<const T> : public BaseType<T> {};

template <typename T> struct BaseType<T &> : public BaseType<T> {};

template <typename T> struct BaseType<T *> : public BaseType<T> {};

template <typename T> struct BaseType<Mn<T>> : public BaseType<T> {};

template <typename T> struct BaseType<MnW<T>> : public BaseType<T> {};

template <typename T> struct BaseType<MVn<T>> : public BaseType<T> {};

template <typename T> struct BaseType<MVnW<T>> : public BaseType<T> {};

template <typename T> struct BaseType<Rn<T>> : public BaseType<T> {};

template <typename T> struct BaseType<RnW<T>> : public BaseType<T> {};

template <typename T> struct BaseType<In<T>> : public BaseType<T> {};

template <typename T> struct BaseType<Vn<T>> : public BaseType<T> {};

template <typename T> struct BaseType<VnW<T>> : public BaseType<T> {};

template <typename T> struct BaseType<RVn<T>> : public BaseType<T> {};

template <typename T> struct BaseType<RVnW<T>> : public BaseType<T> {};

template <typename T> struct NextLargerIntegerType;

template <typename T> struct NextSmallerIntegerType;

template <typename T> struct SignedIntegerType;

template <typename T> struct UnsignedIntegerType;
static_assert(sizeof(int8_t) == sizeof(uint8_t),
"Invalid int changer type type.");
static_assert(is_signed<int8_t>::value != is_signed<uint8_t>::value,
"Sign match between int type and next int type.");
template <> struct SignedIntegerType<uint8_t> {
typedef int8_t BT;
};
template <> struct SignedIntegerType<int8_t> {
typedef int8_t BT;
};
template <> struct UnsignedIntegerType<int8_t> {
typedef uint8_t BT;
};
template <> struct UnsignedIntegerType<uint8_t> {
typedef uint8_t BT;
};
static_assert(sizeof(int16_t) == sizeof(uint16_t),
"Invalid int changer type type.");
static_assert(is_signed<int16_t>::value != is_signed<uint16_t>::value,
"Sign match between int type and next int type.");
template <> struct SignedIntegerType<uint16_t> {
typedef int16_t BT;
};
template <> struct SignedIntegerType<int16_t> {
typedef int16_t BT;
};
template <> struct UnsignedIntegerType<int16_t> {
typedef uint16_t BT;
};
template <> struct UnsignedIntegerType<uint16_t> {
typedef uint16_t BT;
};
static_assert(sizeof(int32_t) == sizeof(uint32_t),
"Invalid int changer type type.");
static_assert(is_signed<int32_t>::value != is_signed<uint32_t>::value,
"Sign match between int type and next int type.");
template <> struct SignedIntegerType<uint32_t> {
typedef int32_t BT;
};
template <> struct SignedIntegerType<int32_t> {
typedef int32_t BT;
};
template <> struct UnsignedIntegerType<int32_t> {
typedef uint32_t BT;
};
template <> struct UnsignedIntegerType<uint32_t> {
typedef uint32_t BT;
};
static_assert(sizeof(int64_t) == sizeof(uint64_t),
"Invalid int changer type type.");
static_assert(is_signed<int64_t>::value != is_signed<uint64_t>::value,
"Sign match between int type and next int type.");
template <> struct SignedIntegerType<uint64_t> {
typedef int64_t BT;
};
template <> struct SignedIntegerType<int64_t> {
typedef int64_t BT;
};
template <> struct UnsignedIntegerType<int64_t> {
typedef uint64_t BT;
};
template <> struct UnsignedIntegerType<uint64_t> {
typedef uint64_t BT;
};

static_assert(sizeof(int128_t) == sizeof(uint128_t),
"Invalid int changer type type.");
static_assert(is_signed<int128_t>::value != is_signed<uint128_t>::value,
"Sign match between int type and next int type.");
template <> struct SignedIntegerType<uint128_t> {
typedef int128_t BT;
};
template <> struct SignedIntegerType<int128_t> {
typedef int128_t BT;
};
template <> struct UnsignedIntegerType<int128_t> {
typedef uint128_t BT;
};
template <> struct UnsignedIntegerType<uint128_t> {
typedef uint128_t BT;
};

static_assert(sizeof(int16_t) == (2 * sizeof(int8_t)),
"Invalid next int type.");
static_assert(is_signed<int8_t>::value == is_signed<int16_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<int8_t> {
typedef int16_t BT;
};
template <> struct NextSmallerIntegerType<int16_t> {
typedef int8_t BT;
};
static_assert(sizeof(uint16_t) == (2 * sizeof(uint8_t)),
"Invalid next int type.");
static_assert(is_signed<uint8_t>::value == is_signed<uint16_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<uint8_t> {
typedef uint16_t BT;
};
template <> struct NextSmallerIntegerType<uint16_t> {
typedef uint8_t BT;
};

static_assert(sizeof(int32_t) == (2 * sizeof(int16_t)),
"Invalid next int type.");
static_assert(is_signed<int16_t>::value == is_signed<int32_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<int16_t> {
typedef int32_t BT;
};
template <> struct NextSmallerIntegerType<int32_t> {
typedef int16_t BT;
};
static_assert(sizeof(uint32_t) == (2 * sizeof(uint16_t)),
"Invalid next int type.");
static_assert(is_signed<uint16_t>::value == is_signed<uint32_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<uint16_t> {
typedef uint32_t BT;
};
template <> struct NextSmallerIntegerType<uint32_t> {
typedef uint16_t BT;
};

static_assert(sizeof(int64_t) == (2 * sizeof(int32_t)),
"Invalid next int type.");
static_assert(is_signed<int32_t>::value == is_signed<int64_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<int32_t> {
typedef int64_t BT;
};
template <> struct NextSmallerIntegerType<int64_t> {
typedef int32_t BT;
};
static_assert(sizeof(uint64_t) == (2 * sizeof(uint32_t)),
"Invalid next int type.");
static_assert(is_signed<uint32_t>::value == is_signed<uint64_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<uint32_t> {
typedef uint64_t BT;
};
template <> struct NextSmallerIntegerType<uint64_t> {
typedef uint32_t BT;
};

static_assert(sizeof(int128_t) == (2 * sizeof(int64_t)),
"Invalid next int type.");
static_assert(is_signed<int64_t>::value == is_signed<int128_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<int64_t> {
typedef int128_t BT;
};
template <> struct NextSmallerIntegerType<int128_t> {
typedef int64_t BT;
};
static_assert(sizeof(uint128_t) == (2 * sizeof(uint64_t)),
"Invalid next int type.");
static_assert(is_signed<uint64_t>::value == is_signed<uint128_t>::value,
"Sign mismatch between int type and next int type.");
template <> struct NextLargerIntegerType<uint64_t> {
typedef uint128_t BT;
};
template <> struct NextSmallerIntegerType<uint128_t> {
typedef uint64_t BT;
};

static_assert(sizeof(NextLargerIntegerType<uint8_t>::BT) == 2, "Bad type.");
static_assert(sizeof(NextLargerIntegerType<uint16_t>::BT) == 4, "Bad type.");
static_assert(sizeof(NextLargerIntegerType<uint32_t>::BT) == 8, "Bad type.");

static_assert(sizeof(NextLargerIntegerType<uint64_t>::BT) == 16, "Bad type.");

static_assert(sizeof(NextSmallerIntegerType<uint16_t>::BT) == 1, "Bad type.");
static_assert(sizeof(NextSmallerIntegerType<uint32_t>::BT) == 2, "Bad type.");
static_assert(sizeof(NextSmallerIntegerType<uint64_t>::BT) == 4, "Bad type.");

static_assert(sizeof(NextSmallerIntegerType<uint128_t>::BT) == 8, "Bad type.");

template <> struct NextLargerIntegerType<uint128_t> {
typedef uint128_t BT;
};

template <> struct NextLargerIntegerType<int128_t> {
typedef int128_t BT;
};
template <typename T> struct IntegerType {
typedef typename BaseType<T>::BT BT;
typedef typename UnsignedIntegerType<BT>::BT UT;
typedef typename SignedIntegerType<BT>::BT ST;

typedef typename NextLargerIntegerType<BT>::BT WBT;
typedef typename UnsignedIntegerType<WBT>::BT WUT;
typedef typename SignedIntegerType<WBT>::BT WST;

enum : std::size_t { kNumBits = sizeof(BT) * 8 };
};

template <> struct IntegerType<bool> : public IntegerType<uint8_t> {};
#pragma clang diagnostic pop

extern "C" {

[[gnu::used, gnu::const]] extern uint8_t __remill_read_memory_8(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern uint16_t __remill_read_memory_16(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern uint32_t __remill_read_memory_32(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern uint64_t __remill_read_memory_64(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_8(Memory *, addr_t, uint8_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_16(Memory *, addr_t, uint16_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_32(Memory *, addr_t, uint32_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_64(Memory *, addr_t, uint64_t);

[[gnu::used, gnu::const]] extern float32_t __remill_read_memory_f32(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern float64_t __remill_read_memory_f64(Memory *,
addr_t);

[[gnu::used]] extern Memory *__remill_read_memory_f80(Memory *, addr_t,
native_float80_t &);

[[gnu::used]] extern float128_t __remill_read_memory_f128(Memory *, addr_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_f32(Memory *, addr_t, float32_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_memory_f64(Memory *, addr_t, float64_t);

[[gnu::used]] extern Memory *
__remill_write_memory_f80(Memory *, addr_t, const native_float80_t &);

[[gnu::used]] extern Memory *__remill_write_memory_f128(Memory *, addr_t,
float128_t);

[[gnu::used, gnu::const]] extern uint8_t __remill_undefined_8(void);

[[gnu::used, gnu::const]] extern uint16_t __remill_undefined_16(void);

[[gnu::used, gnu::const]] extern uint32_t __remill_undefined_32(void);

[[gnu::used, gnu::const]] extern uint64_t __remill_undefined_64(void);

[[gnu::used, gnu::const]] extern float32_t __remill_undefined_f32(void);

[[gnu::used, gnu::const]] extern float64_t __remill_undefined_f64(void);

[[gnu::used, gnu::const]] extern float80_t __remill_undefined_f80(void);

[[gnu::used, gnu::const]] extern float128_t __remill_undefined_f128(void);

[[gnu::used, gnu::const]] extern bool
__remill_flag_computation_zero(bool result, ...);

[[gnu::used, gnu::const]] extern bool
__remill_flag_computation_sign(bool result, ...);

[[gnu::used, gnu::const]] extern bool
__remill_flag_computation_overflow(bool result, ...);

[[gnu::used, gnu::const]] extern bool
__remill_flag_computation_carry(bool result, ...);

[[gnu::used, gnu::const]] extern bool __remill_compare_sle(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_slt(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_sge(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_sgt(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_ule(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_ult(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_ugt(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_uge(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_eq(bool result);

[[gnu::used, gnu::const]] extern bool __remill_compare_neq(bool result);

[[gnu::used]] extern Memory *__remill_error(State &, addr_t addr, Memory *);

[[gnu::used]] extern Memory *__remill_function_call(State &, addr_t addr,
Memory *);

[[gnu::used]] extern Memory *__remill_function_return(State &, addr_t addr,
Memory *);

[[gnu::used]] extern Memory *__remill_jump(State &, addr_t addr, Memory *);

[[gnu::used]] extern Memory *__remill_missing_block(State &, addr_t addr,
Memory *);

[[gnu::used]] extern Memory *__remill_async_hyper_call(State &, addr_t ret_addr,
Memory *);
[[gnu::used, gnu::always_inline]] extern Memory *
__remill_sync_hyper_call(State &, Memory *, SyncHyperCall::Name);

[[gnu::used, gnu::const]] extern Memory *__remill_barrier_load_load(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_barrier_load_store(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_barrier_store_load(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_barrier_store_store(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_atomic_begin(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_atomic_end(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_delay_slot_begin(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_delay_slot_end(Memory *);
[[gnu::used]] extern Memory *
__remill_compare_exchange_memory_8(Memory *, addr_t addr, uint8_t &expected,
uint8_t desired);

[[gnu::used]] extern Memory *
__remill_compare_exchange_memory_16(Memory *, addr_t addr, uint16_t &expected,
uint16_t desired);

[[gnu::used]] extern Memory *
__remill_compare_exchange_memory_32(Memory *, addr_t addr, uint32_t &expected,
uint32_t desired);

[[gnu::used]] extern Memory *
__remill_compare_exchange_memory_64(Memory *, addr_t addr, uint64_t &expected,
uint64_t desired);

[[gnu::used]] extern Memory *
__remill_compare_exchange_memory_128(Memory *, addr_t addr, uint128_t &expected,
uint128_t &desired);

[[gnu::used]] extern Memory *__remill_fetch_and_add_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_add_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_add_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_add_64(Memory *, addr_t addr,
uint64_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_sub_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_sub_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_sub_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_sub_64(Memory *, addr_t addr,
uint64_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_and_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_and_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_and_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_and_64(Memory *, addr_t addr,
uint64_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_or_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_or_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_or_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_or_64(Memory *, addr_t addr,
uint64_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_xor_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_xor_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_xor_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_xor_64(Memory *, addr_t addr,
uint64_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_nand_8(Memory *, addr_t addr,
uint8_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_nand_16(Memory *, addr_t addr,
uint16_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_nand_32(Memory *, addr_t addr,
uint32_t &value);

[[gnu::used]] extern Memory *__remill_fetch_and_nand_64(Memory *, addr_t addr,
uint64_t &value);
[[gnu::used, gnu::const]] extern int
__remill_fpu_exception_test_and_clear(int read_mask, int clear_mask);

[[gnu::used, gnu::const]] extern uint8_t __remill_read_io_port_8(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern uint16_t __remill_read_io_port_16(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern uint32_t __remill_read_io_port_32(Memory *,
addr_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_io_port_8(Memory *, addr_t, uint8_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_io_port_16(Memory *, addr_t, uint16_t);

[[gnu::used, gnu::const]] extern Memory *
__remill_write_io_port_32(Memory *, addr_t, uint32_t);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_segment_es(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_segment_ss(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_segment_ds(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_segment_fs(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_segment_gs(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_x86_set_debug_reg(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_x86_set_control_reg_0(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_x86_set_control_reg_1(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_x86_set_control_reg_2(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_x86_set_control_reg_3(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_x86_set_control_reg_4(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_amd64_set_debug_reg(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_0(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_1(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_2(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_3(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_4(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_amd64_set_control_reg_8(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_aarch64_emulate_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_aarch32_emulate_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_aarch32_check_not_el2(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc_set_asi_register(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc_unimplemented_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc_unhandled_dcti(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc_window_underflow(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_a(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_n(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_ne(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_e(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_g(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_le(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_ge(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_l(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_gu(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_leu(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_cc(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_cs(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_pos(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_neg(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_vc(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_sparc_trap_cond_vs(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc32_emulate_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_sparc64_emulate_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *
__remill_ppc_emulate_instruction(Memory *);

[[gnu::used, gnu::const]] extern Memory *__remill_ppc_syscall(Memory *);
}

struct Memory;
struct State;

namespace {

[[gnu::always_inline]] inline static uint128_t
__remill_read_memory_128(Memory *mem, addr_t addr);

[[gnu::always_inline]] inline static Memory *
__remill_write_memory_128(Memory *mem, addr_t addr, uint128_t val);
[[gnu::always_inline]] inline static uint8_t Undefined(uint8_t) {
return __remill_undefined_8();
}
[[gnu::always_inline]] inline static uint8_t Undefined(Rn<uint8_t>) {
return __remill_undefined_8();
}
[[gnu::always_inline]] inline static uint8_t Undefined(RnW<uint8_t>) {
return __remill_undefined_8();
}
[[gnu::always_inline]] inline static uint8_t Undefined(Mn<uint8_t>) {
return __remill_undefined_8();
}
[[gnu::always_inline]] inline static uint8_t Undefined(MnW<uint8_t>) {
return __remill_undefined_8();
}
[[gnu::always_inline]] inline static uint16_t Undefined(uint16_t) {
return __remill_undefined_16();
}
[[gnu::always_inline]] inline static uint16_t Undefined(Rn<uint16_t>) {
return __remill_undefined_16();
}
[[gnu::always_inline]] inline static uint16_t Undefined(RnW<uint16_t>) {
return __remill_undefined_16();
}
[[gnu::always_inline]] inline static uint16_t Undefined(Mn<uint16_t>) {
return __remill_undefined_16();
}
[[gnu::always_inline]] inline static uint16_t Undefined(MnW<uint16_t>) {
return __remill_undefined_16();
}
[[gnu::always_inline]] inline static uint32_t Undefined(uint32_t) {
return __remill_undefined_32();
}
[[gnu::always_inline]] inline static uint32_t Undefined(Rn<uint32_t>) {
return __remill_undefined_32();
}
[[gnu::always_inline]] inline static uint32_t Undefined(RnW<uint32_t>) {
return __remill_undefined_32();
}
[[gnu::always_inline]] inline static uint32_t Undefined(Mn<uint32_t>) {
return __remill_undefined_32();
}
[[gnu::always_inline]] inline static uint32_t Undefined(MnW<uint32_t>) {
return __remill_undefined_32();
}
[[gnu::always_inline]] inline static uint64_t Undefined(uint64_t) {
return __remill_undefined_64();
}
[[gnu::always_inline]] inline static uint64_t Undefined(Rn<uint64_t>) {
return __remill_undefined_64();
}
[[gnu::always_inline]] inline static uint64_t Undefined(RnW<uint64_t>) {
return __remill_undefined_64();
}
[[gnu::always_inline]] inline static uint64_t Undefined(Mn<uint64_t>) {
return __remill_undefined_64();
}
[[gnu::always_inline]] inline static uint64_t Undefined(MnW<uint64_t>) {
return __remill_undefined_64();
}
[[gnu::always_inline]] inline static int8_t
__remill_read_memory_s8(Memory *mem, addr_t addr) {
return static_cast<int8_t>(__remill_read_memory_8(mem, addr));
}
[[gnu::always_inline]] inline static Memory *
__remill_write_memory_s8(Memory *mem, addr_t addr, int8_t val) {
return __remill_write_memory_8(mem, addr, static_cast<uint8_t>(val));
}
[[gnu::always_inline]] inline static int16_t
__remill_read_memory_s16(Memory *mem, addr_t addr) {
return static_cast<int16_t>(__remill_read_memory_16(mem, addr));
}
[[gnu::always_inline]] inline static Memory *
__remill_write_memory_s16(Memory *mem, addr_t addr, int16_t val) {
return __remill_write_memory_16(mem, addr, static_cast<uint16_t>(val));
}
[[gnu::always_inline]] inline static int32_t
__remill_read_memory_s32(Memory *mem, addr_t addr) {
return static_cast<int32_t>(__remill_read_memory_32(mem, addr));
}
[[gnu::always_inline]] inline static Memory *
__remill_write_memory_s32(Memory *mem, addr_t addr, int32_t val) {
return __remill_write_memory_32(mem, addr, static_cast<uint32_t>(val));
}
[[gnu::always_inline]] inline static int64_t
__remill_read_memory_s64(Memory *mem, addr_t addr) {
return static_cast<int64_t>(__remill_read_memory_64(mem, addr));
}
[[gnu::always_inline]] inline static Memory *
__remill_write_memory_s64(Memory *mem, addr_t addr, int64_t val) {
return __remill_write_memory_64(mem, addr, static_cast<uint64_t>(val));
}

[[gnu::always_inline]] inline static int128_t
__remill_read_memory_s128(Memory *mem, addr_t addr) {
return static_cast<int128_t>(__remill_read_memory_128(mem, addr));
}
[[gnu::always_inline]] inline static Memory *
__remill_write_memory_s128(Memory *mem, addr_t addr, int128_t val) {
return __remill_write_memory_128(mem, addr, static_cast<uint128_t>(val));
}

[[gnu::always_inline]] inline static bool _Read(Memory *, bool val) {
return val;
}

[[gnu::always_inline]] inline static uint8_t _Read(Memory *, uint8_t val) {
return val;
}

[[gnu::always_inline]] inline static uint16_t _Read(Memory *, uint16_t val) {
return val;
}

[[gnu::always_inline]] inline static uint32_t _Read(Memory *, uint32_t val) {
return val;
}

[[gnu::always_inline]] inline static uint64_t _Read(Memory *, uint64_t val) {
return val;
}

[[gnu::always_inline]] inline static float32_t _Read(Memory *, float32_t val) {
return val;
}

[[gnu::always_inline]] inline static float64_t _Read(Memory *, float64_t val) {
return val;
}

[[gnu::always_inline]] inline static float80_t _Read(Memory *, float80_t val) {
return val;
}

[[gnu::always_inline]] inline static float32_t _Read(Memory *,
In<float32_t> imm) {
return reinterpret_cast<const float32_t &>(imm.val);
}

[[gnu::always_inline]] inline static float64_t _Read(Memory *,
In<float64_t> imm) {
return reinterpret_cast<const float64_t &>(imm.val);
}

[[gnu::always_inline]] inline static float80_t _Read(Memory *,
In<float80_t> imm) {
return reinterpret_cast<const float80_t &>(imm.val);
}

template <typename T>
[[gnu::always_inline]] inline static T _Read(Memory *, In<T> imm) {
return static_cast<T>(imm.val);
}

template <typename T>
[[gnu::always_inline]] inline static T _Read(Memory *, Rn<T> reg) {
return static_cast<T>(reg.val);
}

template <typename T>
[[gnu::always_inline]] inline static T _Read(Memory *, RnW<T> reg) {
return static_cast<T>(*(reg.val_ref));
}
[[gnu::always_inline]] inline static uint8_t _Read(Memory *&memory,
Mn<uint8_t> op) {
return __remill_read_memory_8(memory, op.addr);
}
[[gnu::always_inline]] inline static uint8_t _Read(Memory *&memory,
MnW<uint8_t> op) {
return __remill_read_memory_8(memory, op.addr);
}
[[gnu::always_inline]] inline static uint16_t _Read(Memory *&memory,
Mn<uint16_t> op) {
return __remill_read_memory_16(memory, op.addr);
}
[[gnu::always_inline]] inline static uint16_t _Read(Memory *&memory,
MnW<uint16_t> op) {
return __remill_read_memory_16(memory, op.addr);
}
[[gnu::always_inline]] inline static uint32_t _Read(Memory *&memory,
Mn<uint32_t> op) {
return __remill_read_memory_32(memory, op.addr);
}
[[gnu::always_inline]] inline static uint32_t _Read(Memory *&memory,
MnW<uint32_t> op) {
return __remill_read_memory_32(memory, op.addr);
}
[[gnu::always_inline]] inline static uint64_t _Read(Memory *&memory,
Mn<uint64_t> op) {
return __remill_read_memory_64(memory, op.addr);
}
[[gnu::always_inline]] inline static uint64_t _Read(Memory *&memory,
MnW<uint64_t> op) {
return __remill_read_memory_64(memory, op.addr);
}

[[gnu::always_inline]] inline static uint128_t _Read(Memory *&memory,
Mn<uint128_t> op) {
return __remill_read_memory_128(memory, op.addr);
}
[[gnu::always_inline]] inline static uint128_t _Read(Memory *&memory,
MnW<uint128_t> op) {
return __remill_read_memory_128(memory, op.addr);
}

[[gnu::always_inline]] inline static float32_t _Read(Memory *&memory,
Mn<float32_t> op) {
return __remill_read_memory_f32(memory, op.addr);
}
[[gnu::always_inline]] inline static float32_t _Read(Memory *&memory,
MnW<float32_t> op) {
return __remill_read_memory_f32(memory, op.addr);
}
[[gnu::always_inline]] inline static float64_t _Read(Memory *&memory,
Mn<float64_t> op) {
return __remill_read_memory_f64(memory, op.addr);
}
[[gnu::always_inline]] inline static float64_t _Read(Memory *&memory,
MnW<float64_t> op) {
return __remill_read_memory_f64(memory, op.addr);
}

[[gnu::always_inline]] inline static float80_t _Read(Memory *&memory,
Mn<float80_t> op) {
native_float80_t val;
memory = __remill_read_memory_f80(memory, op.addr, val);
return val;
}

[[gnu::always_inline]] inline static float80_t _Read(Memory *&memory,
MnW<float80_t> op) {
native_float80_t val;
memory = __remill_read_memory_f80(memory, op.addr, val);
return val;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *_Write(Memory *memory, T &dst,
T src) {
dst = src;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<uint8_t> reg, uint8_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<uint16_t> reg, uint16_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<uint32_t> reg, uint32_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<uint64_t> reg, uint64_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<float32_t> reg, float32_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<float64_t> reg, float64_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, RnW<float80_t> reg, float80_t val) {
*(reg.val_ref) = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<uint8_t> op, uint8_t val) {
return __remill_write_memory_8(memory, op.addr, val);
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<uint16_t> op, uint16_t val) {
return __remill_write_memory_16(memory, op.addr, val);
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<uint32_t> op, uint32_t val) {
return __remill_write_memory_32(memory, op.addr, val);
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<uint64_t> op, uint64_t val) {
return __remill_write_memory_64(memory, op.addr, val);
}

[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<uint128_t> op, uint128_t val) {
return __remill_write_memory_128(memory, op.addr, val);
}

[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<float32_t> op, float32_t val) {
return __remill_write_memory_f32(memory, op.addr, val);
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<float64_t> op, float64_t val) {
return __remill_write_memory_f64(memory, op.addr, val);
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, MnW<float80_t> op, float80_t val) {
return __remill_write_memory_f80(memory, op.addr, val);
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *, RVnW<T> vec)
-> decltype(T().bytes) {
return reinterpret_cast<T *>(vec.val_ref)->bytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *, RVn<T> vec)
-> decltype(T().bytes) {
return reinterpret_cast<const T *>(&vec.val)->bytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *, RVnW<T> vec)
-> decltype(T().words) {
return reinterpret_cast<T *>(vec.val_ref)->words;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *, RVn<T> vec)
-> decltype(T().words) {
return reinterpret_cast<const T *>(&vec.val)->words;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *, RVnW<T> vec)
-> decltype(T().dwords) {
return reinterpret_cast<T *>(vec.val_ref)->dwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *, RVn<T> vec)
-> decltype(T().dwords) {
return reinterpret_cast<const T *>(&vec.val)->dwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *, RVnW<T> vec)
-> decltype(T().qwords) {
return reinterpret_cast<T *>(vec.val_ref)->qwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *, RVn<T> vec)
-> decltype(T().qwords) {
return reinterpret_cast<const T *>(&vec.val)->qwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *, RVnW<T> vec)
-> decltype(T().sbytes) {
return reinterpret_cast<T *>(vec.val_ref)->sbytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *, RVn<T> vec)
-> decltype(T().sbytes) {
return reinterpret_cast<const T *>(&vec.val)->sbytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *, RVnW<T> vec)
-> decltype(T().swords) {
return reinterpret_cast<T *>(vec.val_ref)->swords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *, RVn<T> vec)
-> decltype(T().swords) {
return reinterpret_cast<const T *>(&vec.val)->swords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *, RVnW<T> vec)
-> decltype(T().sdwords) {
return reinterpret_cast<T *>(vec.val_ref)->sdwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *, RVn<T> vec)
-> decltype(T().sdwords) {
return reinterpret_cast<const T *>(&vec.val)->sdwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *, RVnW<T> vec)
-> decltype(T().sqwords) {
return reinterpret_cast<T *>(vec.val_ref)->sqwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *, RVn<T> vec)
-> decltype(T().sqwords) {
return reinterpret_cast<const T *>(&vec.val)->sqwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *, RVnW<T> vec)
-> decltype(T().floats) {
return reinterpret_cast<T *>(vec.val_ref)->floats;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *, RVn<T> vec)
-> decltype(T().floats) {
return reinterpret_cast<const T *>(&vec.val)->floats;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *, RVnW<T> vec)
-> decltype(T().doubles) {
return reinterpret_cast<T *>(vec.val_ref)->doubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *, RVn<T> vec)
-> decltype(T().doubles) {
return reinterpret_cast<const T *>(&vec.val)->doubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *, RVnW<T> vec)
-> decltype(T().tdoubles) {
return reinterpret_cast<T *>(vec.val_ref)->tdoubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *, RVn<T> vec)
-> decltype(T().tdoubles) {
return reinterpret_cast<const T *>(&vec.val)->tdoubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *, VnW<T> vec)
-> decltype(T().bytes) {
return reinterpret_cast<T *>(vec.val_ref)->bytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *, Vn<T> vec)
-> decltype(T().bytes) {
return reinterpret_cast<const T *>(vec.val)->bytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *, VnW<T> vec)
-> decltype(T().words) {
return reinterpret_cast<T *>(vec.val_ref)->words;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *, Vn<T> vec)
-> decltype(T().words) {
return reinterpret_cast<const T *>(vec.val)->words;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *, VnW<T> vec)
-> decltype(T().dwords) {
return reinterpret_cast<T *>(vec.val_ref)->dwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *, Vn<T> vec)
-> decltype(T().dwords) {
return reinterpret_cast<const T *>(vec.val)->dwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *, VnW<T> vec)
-> decltype(T().qwords) {
return reinterpret_cast<T *>(vec.val_ref)->qwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *, Vn<T> vec)
-> decltype(T().qwords) {
return reinterpret_cast<const T *>(vec.val)->qwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _UReadV128(Memory *, VnW<T> vec)
-> decltype(T().dqwords) {
return reinterpret_cast<T *>(vec.val_ref)->dqwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV128(Memory *, Vn<T> vec)
-> decltype(T().dqwords) {
return reinterpret_cast<const T *>(vec.val)->dqwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *, VnW<T> vec)
-> decltype(T().sbytes) {
return reinterpret_cast<T *>(vec.val_ref)->sbytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *, Vn<T> vec)
-> decltype(T().sbytes) {
return reinterpret_cast<const T *>(vec.val)->sbytes;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *, VnW<T> vec)
-> decltype(T().swords) {
return reinterpret_cast<T *>(vec.val_ref)->swords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *, Vn<T> vec)
-> decltype(T().swords) {
return reinterpret_cast<const T *>(vec.val)->swords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *, VnW<T> vec)
-> decltype(T().sdwords) {
return reinterpret_cast<T *>(vec.val_ref)->sdwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *, Vn<T> vec)
-> decltype(T().sdwords) {
return reinterpret_cast<const T *>(vec.val)->sdwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *, VnW<T> vec)
-> decltype(T().sqwords) {
return reinterpret_cast<T *>(vec.val_ref)->sqwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *, Vn<T> vec)
-> decltype(T().sqwords) {
return reinterpret_cast<const T *>(vec.val)->sqwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _SReadV128(Memory *, VnW<T> vec)
-> decltype(T().sdqwords) {
return reinterpret_cast<T *>(vec.val_ref)->sdqwords;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV128(Memory *, Vn<T> vec)
-> decltype(T().sdqwords) {
return reinterpret_cast<const T *>(vec.val)->sdqwords;
}

template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *, VnW<T> vec)
-> decltype(T().floats) {
return reinterpret_cast<T *>(vec.val_ref)->floats;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *, Vn<T> vec)
-> decltype(T().floats) {
return reinterpret_cast<const T *>(vec.val)->floats;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *, VnW<T> vec)
-> decltype(T().doubles) {
return reinterpret_cast<T *>(vec.val_ref)->doubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *, Vn<T> vec)
-> decltype(T().doubles) {
return reinterpret_cast<const T *>(vec.val)->doubles;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *, VnW<T> vec)
-> decltype(T().tdouble) {
return reinterpret_cast<T *>(vec.val_ref)->tdouble;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *, Vn<T> vec)
-> decltype(T().tdouble) {
return reinterpret_cast<const T *>(vec.val)->tdouble;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *memory, MVn<T> mem)
-> decltype(T().bytes) {
decltype(T().bytes) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_8(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV8(Memory *memory, MVnW<T> mem)
-> decltype(T().bytes) {
decltype(T().bytes) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_8(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *memory, MVn<T> mem)
-> decltype(T().words) {
decltype(T().words) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_16(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV16(Memory *memory, MVnW<T> mem)
-> decltype(T().words) {
decltype(T().words) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_16(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *memory, MVn<T> mem)
-> decltype(T().dwords) {
decltype(T().dwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV32(Memory *memory, MVnW<T> mem)
-> decltype(T().dwords) {
decltype(T().dwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *memory, MVn<T> mem)
-> decltype(T().qwords) {
decltype(T().qwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_64(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV64(Memory *memory, MVnW<T> mem)
-> decltype(T().qwords) {
decltype(T().qwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_64(memory, mem.addr + (i * el_size));
}
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static auto _UReadV128(Memory *memory, MVn<T> mem)
-> decltype(T().dqwords) {
decltype(T().dqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_128(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _UReadV128(Memory *memory,
MVnW<T> mem)
-> decltype(T().dqwords) {
decltype(T().dqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_128(memory, mem.addr + (i * el_size));
}
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *memory, MVn<T> mem)
-> decltype(T().sbytes) {
decltype(T().sbytes) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s8(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV8(Memory *memory, MVnW<T> mem)
-> decltype(T().sbytes) {
decltype(T().sbytes) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s8(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *memory, MVn<T> mem)
-> decltype(T().swords) {
decltype(T().swords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s16(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV16(Memory *memory, MVnW<T> mem)
-> decltype(T().swords) {
decltype(T().swords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s16(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *memory, MVn<T> mem)
-> decltype(T().sdwords) {
decltype(T().sdwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV32(Memory *memory, MVnW<T> mem)
-> decltype(T().sdwords) {
decltype(T().sdwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *memory, MVn<T> mem)
-> decltype(T().sqwords) {
decltype(T().sqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s64(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV64(Memory *memory, MVnW<T> mem)
-> decltype(T().sqwords) {
decltype(T().sqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s64(memory, mem.addr + (i * el_size));
}
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static auto _SReadV128(Memory *memory, MVn<T> mem)
-> decltype(T().sdqwords) {
decltype(T().sdqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s128(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _SReadV128(Memory *memory,
MVnW<T> mem)
-> decltype(T().sdqwords) {
decltype(T().sdqwords) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_s128(memory, mem.addr + (i * el_size));
}
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *memory, MVn<T> mem)
-> decltype(T().floats) {
decltype(T().floats) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV32(Memory *memory, MVnW<T> mem)
-> decltype(T().floats) {
decltype(T().floats) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f32(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *memory, MVn<T> mem)
-> decltype(T().doubles) {
decltype(T().doubles) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f64(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV64(Memory *memory, MVnW<T> mem)
-> decltype(T().doubles) {
decltype(T().doubles) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f64(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *memory, MVn<T> mem)
-> decltype(T().tdoubles) {
decltype(T().tdoubles) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f80(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static auto _FReadV80(Memory *memory, MVnW<T> mem)
-> decltype(T().tdoubles) {
decltype(T().tdoubles) vec = {};
const addr_t el_size = sizeof(vec.elems[0]);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec)>::kNumElems); ++i) {
vec.elems[i] = __remill_read_memory_f80(memory, mem.addr + (i * el_size));
}
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, VnW<T> vec, uint8_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->bytes;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().bytes.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->bytes;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, VnW<T> vec, uint16_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->words;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().words.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->words;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, VnW<T> vec, uint32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().dwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, VnW<T> vec, uint64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->qwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().qwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->qwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV128(Memory *memory, VnW<T> vec, uint128_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dqwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV128(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().dqwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dqwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *_SWriteV8(Memory *memory,
VnW<T> vec, int8_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sbytes;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV8(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sbytes.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sbytes;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, VnW<T> vec, int16_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->swords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().swords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->swords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, VnW<T> vec, int32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sdwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, VnW<T> vec, int64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sqwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sqwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sqwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV128(Memory *memory, VnW<T> vec, int128_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdqwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV128(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sdqwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdqwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, VnW<T> vec, float32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->floats;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().floats.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->floats;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, VnW<T> vec, float64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->doubles;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().doubles.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->doubles;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, VnW<T> vec, float80_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->tdoubles;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, VnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().tdoubles.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->tdoubles;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, RVnW<T> vec, uint8_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->bytes;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().bytes.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->bytes;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, RVnW<T> vec, uint16_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->words;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().words.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->words;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, RVnW<T> vec, uint32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().dwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->dwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, RVnW<T> vec, uint64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->qwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().qwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->qwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV8(Memory *memory, RVnW<T> vec, int8_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sbytes;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV8(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sbytes.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sbytes;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, RVnW<T> vec, int16_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->swords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().swords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->swords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, RVnW<T> vec, int32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sdwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sdwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, RVnW<T> vec, int64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sqwords;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().sqwords.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->sqwords;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, RVnW<T> vec, float32_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->floats;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().floats.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->floats;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, RVnW<T> vec, float64_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->doubles;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().doubles.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->doubles;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, RVnW<T> vec, float80_t val) {
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->tdoubles;
sub_vec.elems[0] = val;
#pragma unroll
for (addr_t i = 1;
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, RVnW<T> vec, const V &val) {
static_assert(sizeof(T) >= sizeof(V), "Object to WriteV is too big.");
typedef decltype(T().tdoubles.elems[0]) BT;
typedef decltype(V().elems[0]) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
auto &sub_vec = reinterpret_cast<T *>(vec.val_ref)->tdoubles;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
sub_vec.elems[i] = val.elems[i];
}
#pragma unroll
for (addr_t i = static_cast<addr_t>(VectorType<decltype(val)>::kNumElems);
i < static_cast<addr_t>(VectorType<decltype(sub_vec)>::kNumElems); ++i) {
sub_vec.elems[i] = 0;
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, MVnW<T> mem, uint8_t val) {
T vec{};
const addr_t el_size = sizeof(uint8_t);
vec.bytes.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.bytes)>::kNumElems);
++i) {
memory = __remill_write_memory_8(memory, mem.addr + (i * el_size),
vec.bytes.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV8(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().bytes) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(uint8_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory =
__remill_write_memory_8(memory, mem.addr + (i * el_size), val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, MVnW<T> mem, uint16_t val) {
T vec{};
const addr_t el_size = sizeof(uint16_t);
vec.words.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.words)>::kNumElems);
++i) {
memory = __remill_write_memory_16(memory, mem.addr + (i * el_size),
vec.words.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV16(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().words) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(uint16_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_16(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, MVnW<T> mem, uint32_t val) {
T vec{};
const addr_t el_size = sizeof(uint32_t);
vec.dwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.dwords)>::kNumElems);
++i) {
memory = __remill_write_memory_32(memory, mem.addr + (i * el_size),
vec.dwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV32(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().dwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(uint32_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_32(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, MVnW<T> mem, uint64_t val) {
T vec{};
const addr_t el_size = sizeof(uint64_t);
vec.qwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.qwords)>::kNumElems);
++i) {
memory = __remill_write_memory_64(memory, mem.addr + (i * el_size),
vec.qwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV64(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().qwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(uint64_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_64(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_UWriteV128(Memory *memory, MVnW<T> mem, uint128_t val) {
T vec{};
const addr_t el_size = sizeof(uint128_t);
vec.dqwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.dqwords)>::kNumElems);
++i) {
memory = __remill_write_memory_128(memory, mem.addr + (i * el_size),
vec.dqwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_UWriteV128(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().dqwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(uint128_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_128(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV8(Memory *memory, MVnW<T> mem, int8_t val) {
T vec{};
const addr_t el_size = sizeof(int8_t);
vec.sbytes.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.sbytes)>::kNumElems);
++i) {
memory = __remill_write_memory_s8(memory, mem.addr + (i * el_size),
vec.sbytes.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV8(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().sbytes) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(int8_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_s8(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, MVnW<T> mem, int16_t val) {
T vec{};
const addr_t el_size = sizeof(int16_t);
vec.swords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.swords)>::kNumElems);
++i) {
memory = __remill_write_memory_s16(memory, mem.addr + (i * el_size),
vec.swords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV16(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().swords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(int16_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_s16(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, MVnW<T> mem, int32_t val) {
T vec{};
const addr_t el_size = sizeof(int32_t);
vec.sdwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.sdwords)>::kNumElems);
++i) {
memory = __remill_write_memory_s32(memory, mem.addr + (i * el_size),
vec.sdwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV32(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().sdwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(int32_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_s32(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, MVnW<T> mem, int64_t val) {
T vec{};
const addr_t el_size = sizeof(int64_t);
vec.sqwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.sqwords)>::kNumElems);
++i) {
memory = __remill_write_memory_s64(memory, mem.addr + (i * el_size),
vec.sqwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV64(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().sqwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(int64_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_s64(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_SWriteV128(Memory *memory, MVnW<T> mem, int128_t val) {
T vec{};
const addr_t el_size = sizeof(int128_t);
vec.sdqwords.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.sdqwords)>::kNumElems);
++i) {
memory = __remill_write_memory_s128(memory, mem.addr + (i * el_size),
vec.sdqwords.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_SWriteV128(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().sdqwords) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(int128_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_s128(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}

template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, MVnW<T> mem, float32_t val) {
T vec{};
const addr_t el_size = sizeof(float32_t);
vec.floats.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.floats)>::kNumElems);
++i) {
memory = __remill_write_memory_f32(memory, mem.addr + (i * el_size),
vec.floats.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV32(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().floats) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(float32_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_f32(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, MVnW<T> mem, float64_t val) {
T vec{};
const addr_t el_size = sizeof(float64_t);
vec.doubles.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.doubles)>::kNumElems);
++i) {
memory = __remill_write_memory_f64(memory, mem.addr + (i * el_size),
vec.doubles.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV64(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().doubles) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(float64_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_f64(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, MVnW<T> mem, float80_t val) {
T vec{};
const addr_t el_size = sizeof(float80_t);
vec.tdoubles.elems[0] = val;
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(vec.tdoubles)>::kNumElems);
++i) {
memory = __remill_write_memory_f80(memory, mem.addr + (i * el_size),
vec.tdoubles.elems[i]);
}
return memory;
}
template <typename T, typename V>
[[gnu::always_inline]] inline static Memory *
_FWriteV80(Memory *memory, MVnW<T> mem, const V &val) {
static_assert(sizeof(T) == sizeof(V), "Invalid value size for MVnW.");
typedef decltype(T().tdoubles) BT;
typedef decltype(V()) VT;
static_assert(std::is_same<BT, VT>::value,
"Incompatible types to a write to a vector register");
const addr_t el_size = sizeof(float80_t);
#pragma unroll
for (addr_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(val)>::kNumElems); ++i) {
memory = __remill_write_memory_f80(memory, mem.addr + (i * el_size),
val.elems[i]);
}
return memory;
}
[[gnu::always_inline]] inline static Memory *_Write(Memory *memory, bool &ref,
bool val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *_Write(Memory *memory,
uint8_t &ref, uint8_t val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, uint16_t &ref, uint16_t val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, uint32_t &ref, uint32_t val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, uint64_t &ref, uint64_t val) {
ref = val;
return memory;
}

[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, uint128_t &ref, uint128_t val) {
ref = val;
return memory;
}

[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, float32_t &ref, float32_t val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, float64_t &ref, float64_t val) {
ref = val;
return memory;
}
[[gnu::always_inline]] inline static Memory *
_Write(Memory *memory, float80_t &ref, float80_t val) {
ref = val;
return memory;
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, RnW<T> op, uint8_t &expected, uint8_t desired) {
if (decltype(expected)(*op.val_ref) == expected) {
*op.val_ref = desired;
return true;
} else {
expected = *reinterpret_cast<uint8_t *>(op.val_ref);
return false;
}
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, MnW<T> op, uint8_t &expected, uint8_t desired) {
auto prev_val = expected;
memory =
__remill_compare_exchange_memory_8(memory, op.addr, expected, desired);
return prev_val == expected;
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, RnW<T> op, uint16_t &expected, uint16_t desired) {
if (decltype(expected)(*op.val_ref) == expected) {
*op.val_ref = desired;
return true;
} else {
expected = *reinterpret_cast<uint16_t *>(op.val_ref);
return false;
}
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, MnW<T> op, uint16_t &expected, uint16_t desired) {
auto prev_val = expected;
memory =
__remill_compare_exchange_memory_16(memory, op.addr, expected, desired);
return prev_val == expected;
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, RnW<T> op, uint32_t &expected, uint32_t desired) {
if (decltype(expected)(*op.val_ref) == expected) {
*op.val_ref = desired;
return true;
} else {
expected = *reinterpret_cast<uint32_t *>(op.val_ref);
return false;
}
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, MnW<T> op, uint32_t &expected, uint32_t desired) {
auto prev_val = expected;
memory =
__remill_compare_exchange_memory_32(memory, op.addr, expected, desired);
return prev_val == expected;
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, RnW<T> op, uint64_t &expected, uint64_t desired) {
if (decltype(expected)(*op.val_ref) == expected) {
*op.val_ref = desired;
return true;
} else {
expected = *reinterpret_cast<uint64_t *>(op.val_ref);
return false;
}
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, MnW<T> op, uint64_t &expected, uint64_t desired) {
auto prev_val = expected;
memory =
__remill_compare_exchange_memory_64(memory, op.addr, expected, desired);
return prev_val == expected;
}

template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, RnW<T> op, uint128_t &expected, uint128_t desired) {
if (decltype(expected)(*op.val_ref) == expected) {
*op.val_ref = desired;
return true;
} else {
expected = *reinterpret_cast<uint128_t *>(op.val_ref);
return false;
}
}
template <typename T>
[[gnu::always_inline]] inline static bool
_CmpXchg(Memory *&memory, MnW<T> op, uint128_t &expected, uint128_t desired) {
auto prev_val = expected;
memory =
__remill_compare_exchange_memory_128(memory, op.addr, expected, desired);
return prev_val == expected;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchAdd(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_fetch_and_add_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchAdd(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = prev_value + value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchAdd(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_fetch_and_add_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchAdd(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = prev_value + value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchAdd(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_fetch_and_add_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchAdd(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = prev_value + value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchAdd(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_fetch_and_add_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchAdd(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = prev_value + value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchSub(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_fetch_and_sub_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchSub(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = prev_value - value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchSub(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_fetch_and_sub_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchSub(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = prev_value - value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchSub(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_fetch_and_sub_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchSub(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = prev_value - value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchSub(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_fetch_and_sub_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchSub(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = prev_value - value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchOr(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_fetch_and_or_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchOr(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = prev_value | value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchOr(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_fetch_and_or_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchOr(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = prev_value | value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchOr(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_fetch_and_or_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchOr(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = prev_value | value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchOr(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_fetch_and_or_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchOr(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = prev_value | value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchAnd(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_fetch_and_and_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchAnd(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = prev_value & value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchAnd(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_fetch_and_and_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchAnd(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = prev_value & value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchAnd(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_fetch_and_and_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchAnd(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = prev_value & value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchAnd(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_fetch_and_and_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchAnd(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = prev_value & value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchXor(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_fetch_and_xor_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UFetchXor(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = prev_value ^ value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchXor(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_fetch_and_xor_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UFetchXor(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = prev_value ^ value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchXor(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_fetch_and_xor_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UFetchXor(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = prev_value ^ value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchXor(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_fetch_and_xor_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UFetchXor(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = prev_value ^ value;
return prev_value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UAddFetch(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_add_and_fetch_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UAddFetch(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value + value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UAddFetch(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_add_and_fetch_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UAddFetch(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value + value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UAddFetch(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_add_and_fetch_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UAddFetch(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value + value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UAddFetch(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_add_and_fetch_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UAddFetch(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value + value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _USubFetch(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_sub_and_fetch_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _USubFetch(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value - value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _USubFetch(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_sub_and_fetch_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _USubFetch(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value - value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _USubFetch(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_sub_and_fetch_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _USubFetch(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value - value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _USubFetch(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_sub_and_fetch_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _USubFetch(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value - value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UOrFetch(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_or_and_fetch_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UOrFetch(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value | value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UOrFetch(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_or_and_fetch_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UOrFetch(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value | value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UOrFetch(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_or_and_fetch_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UOrFetch(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value | value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UOrFetch(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_or_and_fetch_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UOrFetch(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value | value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UAndFetch(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_and_and_fetch_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UAndFetch(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value & value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UAndFetch(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_and_and_fetch_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UAndFetch(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value & value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UAndFetch(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_and_and_fetch_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UAndFetch(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value & value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UAndFetch(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_and_and_fetch_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UAndFetch(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value & value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UXorFetch(Memory *&memory, MnW<T> addr,
uint8_t value) {
memory = __remill_xor_and_fetch_8(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint8_t _UXorFetch(Memory *&memory, RnW<T> addr,
uint8_t value) {
auto prev_value = *reinterpret_cast<uint8_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value ^ value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UXorFetch(Memory *&memory, MnW<T> addr,
uint16_t value) {
memory = __remill_xor_and_fetch_16(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint16_t _UXorFetch(Memory *&memory, RnW<T> addr,
uint16_t value) {
auto prev_value = *reinterpret_cast<uint16_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value ^ value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UXorFetch(Memory *&memory, MnW<T> addr,
uint32_t value) {
memory = __remill_xor_and_fetch_32(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint32_t _UXorFetch(Memory *&memory, RnW<T> addr,
uint32_t value) {
auto prev_value = *reinterpret_cast<uint32_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value ^ value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UXorFetch(Memory *&memory, MnW<T> addr,
uint64_t value) {
memory = __remill_xor_and_fetch_64(memory, addr.addr, value);
return value;
}
template <typename T>
[[gnu::always_inline]] inline uint64_t _UXorFetch(Memory *&memory, RnW<T> addr,
uint64_t value) {
auto prev_value = *reinterpret_cast<uint64_t *>(addr.val_ref);
*addr.val_ref = value;
return prev_value ^ value;
}
[[gnu::always_inline]] inline bool issignaling(float32_t x) {
const nan32_t x_nan = {x};
return x_nan.exponent == 0xFFU && !x_nan.is_quiet_nan && x_nan.payload;
}

[[gnu::always_inline]] inline bool issignaling(float64_t x) {
const nan64_t x_nan = {x};
return x_nan.exponent == 0x7FFU && !x_nan.is_quiet_nan && x_nan.payload;
}

[[gnu::always_inline]] inline bool issignaling(float80_t x) {

const nan80_t x_nan = {x};
return x_nan.exponent == 0x7FFFU && !x_nan.is_quiet_nan && x_nan.payload &&
x_nan.interger_bit;
}

template <typename T, typename R = typename IntegerType<T>::UT>
[[gnu::always_inline]] inline static constexpr R ByteSizeOf(T) {
return static_cast<R>(sizeof(typename BaseType<T>::BT));
}

template <typename T, typename R = typename IntegerType<T>::UT>
[[gnu::always_inline]] inline static constexpr R BitSizeOf(T) {
return static_cast<R>(sizeof(typename BaseType<T>::BT) * 8);
}

template <typename T>
[[gnu::always_inline]] inline static auto Unsigned(T val) ->
typename IntegerType<T>::UT {
return static_cast<typename IntegerType<T>::UT>(val);
}

template <typename T>
[[gnu::always_inline]] inline static auto Signed(T val) ->
typename IntegerType<T>::ST {
return static_cast<typename IntegerType<T>::ST>(val);
}

template <typename T>
[[gnu::always_inline]] inline static uint8_t IsNegative(T x) {
return static_cast<uint8_t>(std::signbit(x));
}

[[gnu::always_inline]] inline static uint8_t IsNegative(float80_t x) {
return static_cast<uint8_t>(std::signbit(static_cast<native_float80_t>(x)));
}

[[gnu::always_inline]] inline static uint8_t IsZero(float32_t x) {
return static_cast<uint8_t>(2 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsZero(float64_t x) {
return static_cast<uint8_t>(2 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsZero(float80_t x) {
return static_cast<uint8_t>(
2 == std::fpclassify(static_cast<native_float80_t>(x)));
}

[[gnu::always_inline]] inline static uint8_t IsInfinite(float32_t x) {
return static_cast<uint8_t>(1 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsInfinite(float64_t x) {
return static_cast<uint8_t>(1 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsInfinite(float80_t x) {
return static_cast<uint8_t>(
1 == std::fpclassify(static_cast<native_float80_t>(x)));
}

[[gnu::always_inline]] inline static uint8_t IsNaN(float32_t x) {
return static_cast<uint8_t>(0 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsNaN(float64_t x) {
return static_cast<uint8_t>(0 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsNaN(float80_t x) {
return static_cast<uint8_t>(
0 == std::fpclassify(static_cast<native_float80_t>(x)));
}

[[gnu::always_inline]] inline static bool IsSignalingNaN(float32_t x) {
const nan32_t x_nan = {x};
return x_nan.exponent == 0xFFU && !x_nan.is_quiet_nan && x_nan.payload;
}

[[gnu::always_inline]] inline static bool IsSignalingNaN(float64_t x) {
const nan64_t x_nan = {x};
return x_nan.exponent == 0x7FFU && !x_nan.is_quiet_nan && x_nan.payload;
}

[[gnu::always_inline]] inline static bool IsSignalingNaN(float80_t x) {

const nan80_t x_nan = {x};
return x_nan.exponent == 0x7FFFU && !x_nan.is_quiet_nan && x_nan.payload &&
x_nan.interger_bit;
}

template <typename T>
[[gnu::always_inline]] inline static uint8_t IsSignalingNaN(T) {
return 0;
}

template <typename T>
[[gnu::always_inline]] inline static uint8_t IsDenormal(T x) {
return static_cast<uint8_t>(3 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsDenormal(float32_t x) {
return static_cast<uint8_t>(3 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsDenormal(float64_t x) {
return static_cast<uint8_t>(3 == std::fpclassify(x));
}

[[gnu::always_inline]] inline static uint8_t IsDenormal(float80_t x) {
return static_cast<uint8_t>(
3 == std::fpclassify(static_cast<native_float80_t>(x)));
}
template <typename T>
[[gnu::always_inline]] inline static uint8_t IsZero(T val) {
return static_cast<uint8_t>(!val);
}

template <typename T>
[[gnu::always_inline]] inline static uint8_t IsInfinite(T) {
return 0;
}

template <typename T> [[gnu::always_inline]] inline static uint8_t IsNaN(T) {
return 0;
}

template <typename T> [[gnu::always_inline]] inline static T Maximize(T) {
return std::numeric_limits<T>::max();
}

template <typename T> [[gnu::always_inline]] inline static T Minimize(T) {
return std::numeric_limits<T>::min();
}

template <typename T> [[gnu::always_inline]] inline static int8_t Int8(T val) {
return static_cast<int8_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static int16_t Int16(T val) {
return static_cast<int16_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static int32_t Int32(T val) {
return static_cast<int32_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static int64_t Int64(T val) {
return static_cast<int64_t>(val);
}

template <typename T>
[[gnu::always_inline]] inline static int128_t Int128(T val) {
return static_cast<int128_t>(val);
}

template <typename T>
[[gnu::always_inline]] inline static uint8_t UInt8(T val) {
return static_cast<uint8_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static uint16_t UInt16(T val) {
return static_cast<uint16_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static uint32_t UInt32(T val) {
return static_cast<uint32_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static uint64_t UInt64(T val) {
return static_cast<uint64_t>(val);
}

template <typename T>
[[gnu::always_inline]] inline static uint128_t UInt128(T val) {
return static_cast<uint128_t>(val);
}

template <typename T>
[[gnu::always_inline]] inline static float32_t Float32(T val) {
return static_cast<float32_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static float64_t Float64(T val) {
return static_cast<float64_t>(val);
}
template <typename T>
[[gnu::always_inline]] inline static float80_t Float80(T val) {
return static_cast<float80_t>(val);
}
template <typename T, typename U>
[[gnu::always_inline]] inline static auto Literal(U val) ->
typename IntegerType<T>::BT {
return static_cast<typename IntegerType<T>::BT>(val);
}

template <typename T, typename U>
[[gnu::always_inline]] inline static auto ULiteral(U val) ->
typename IntegerType<T>::UT {
return static_cast<typename IntegerType<T>::UT>(val);
}

template <typename T, typename U>
[[gnu::always_inline]] inline static auto SLiteral(U val) ->
typename IntegerType<T>::ST {
return static_cast<typename IntegerType<T>::ST>(val);
}

template <typename T>
[[gnu::always_inline]] inline static auto ZExt(T val) ->
typename IntegerType<T>::WUT {
return static_cast<typename IntegerType<T>::WUT>(Unsigned(val));
}

template <typename DT, typename T>
[[gnu::always_inline]] inline static auto ZExtTo(T val) ->
typename IntegerType<DT>::UT {
typedef typename IntegerType<DT>::UT UT;
static_assert(sizeof(T) <= sizeof(typename IntegerType<DT>::BT),
"Bad extension.");
return static_cast<UT>(Unsigned(val));
}

template <typename T>
[[gnu::always_inline]] inline static auto SExt(T val) ->
typename IntegerType<T>::WST {
return static_cast<typename IntegerType<T>::WST>(Signed(val));
}

template <typename DT, typename T>
[[gnu::always_inline]] inline static auto SExtTo(T val) ->
typename IntegerType<DT>::ST {
static_assert(sizeof(T) <= sizeof(typename IntegerType<DT>::BT),
"Bad extension.");
return static_cast<typename IntegerType<DT>::ST>(Signed(val));
}

template <typename T>
[[gnu::always_inline]] inline static auto Trunc(T val) ->
typename NextSmallerIntegerType<T>::BT {
return static_cast<typename NextSmallerIntegerType<T>::BT>(val);
}

template <typename DT, typename T>
[[gnu::always_inline]] inline static auto TruncTo(T val) ->
typename IntegerType<DT>::BT {
static_assert(sizeof(T) >= sizeof(typename IntegerType<DT>::BT),
"Bad truncation.");
return static_cast<typename IntegerType<DT>::BT>(val);
}
[[gnu::always_inline]] inline static uint8_t UAdd(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UAdd8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAdd(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAdd16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAdd(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAdd32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) + static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAdd(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) +
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAdd64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) +
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAdd(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAdd8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAdd(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAdd16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAdd(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAdd32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) +
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAdd(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) +
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAdd64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) +
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static float32_t FAdd(float32_t L, float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) +
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float32_t FAdd32(float32_t L,
float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) +
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float64_t FAdd(float64_t L, float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) +
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float64_t FAdd64(float64_t L,
float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) +
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float80_t FAdd(float80_t L, float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) +
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static float80_t FAdd80(float80_t L,
float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) +
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static uint8_t USub(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t USub8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t USub(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t USub16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t USub(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t USub32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) - static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t USub(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) -
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t USub64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) -
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SSub(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SSub8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SSub(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SSub16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SSub(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SSub32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) -
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SSub(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) -
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SSub64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) -
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static float32_t FSub(float32_t L, float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) -
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float32_t FSub32(float32_t L,
float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) -
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float64_t FSub(float64_t L, float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) -
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float64_t FSub64(float64_t L,
float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) -
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float80_t FSub(float80_t L, float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) -
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static float80_t FSub80(float80_t L,
float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) -
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UMul(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UMul8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UMul(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UMul16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UMul(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UMul32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) * static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UMul(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) *
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UMul64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) *
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SMul(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SMul8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SMul(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SMul16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SMul(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SMul32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) *
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SMul(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) *
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SMul64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) *
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static float32_t FMul(float32_t L, float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) *
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float32_t FMul32(float32_t L,
float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) *
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float64_t FMul(float64_t L, float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) *
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float64_t FMul64(float64_t L,
float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) *
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float80_t FMul(float80_t L, float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) *
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static float80_t FMul80(float80_t L,
float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) *
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UDiv(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UDiv8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UDiv(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UDiv16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UDiv(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UDiv32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) / static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UDiv(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) /
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UDiv64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) /
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SDiv(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SDiv8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SDiv(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SDiv16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SDiv(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SDiv32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) /
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SDiv(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) /
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SDiv64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) /
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static float32_t FDiv(float32_t L, float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) /
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float32_t FDiv32(float32_t L,
float32_t R) {
return static_cast<float32_t>(static_cast<float32_t>(L) /
static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float64_t FDiv(float64_t L, float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) /
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float64_t FDiv64(float64_t L,
float64_t R) {
return static_cast<float64_t>(static_cast<float64_t>(L) /
static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float80_t FDiv(float80_t L, float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) /
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static float80_t FDiv80(float80_t L,
float80_t R) {
return static_cast<float80_t>(static_cast<float80_t>(L) /
static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static uint8_t URem(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t URem8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t URem(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t URem16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t URem(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t URem32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) % static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t URem(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) %
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t URem64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) %
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SRem(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SRem8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SRem(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SRem16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SRem(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SRem32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) %
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SRem(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) %
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SRem64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) %
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UAnd(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UAnd8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAnd(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAnd16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAnd(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAnd32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) & static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAnd(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) &
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAnd64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) &
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAnd(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAnd8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAnd(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAnd16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAnd(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAnd32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) &
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAnd(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) &
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAnd64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) &
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UAndN(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) & ~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UAndN8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) & ~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAndN(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) &
~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UAndN16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) &
~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAndN(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) &
~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UAndN32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) &
~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAndN(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) &
~static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UAndN64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) &
~static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAndN(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SAndN8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAndN(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SAndN16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAndN(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SAndN32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) &
~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAndN(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) &
~static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SAndN64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) &
~static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UOr(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UOr8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UOr(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UOr16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UOr(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UOr32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) | static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UOr(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) |
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UOr64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) |
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SOr(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SOr8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SOr(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SOr16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SOr(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SOr32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) |
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SOr(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) |
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SOr64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) |
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UXor(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UXor8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UXor(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UXor16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UXor(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UXor32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) ^ static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UXor(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) ^
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UXor64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) ^
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SXor(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SXor8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SXor(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SXor16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SXor(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SXor32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) ^
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SXor(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) ^
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SXor64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) ^
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UShr(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) >> static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UShr8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) >> static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UShr(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) >>
static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UShr16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L) >>
static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UShr(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) >>
static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UShr32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L) >>
static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UShr(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) >>
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UShr64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L) >>
static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SShr(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SShr8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SShr(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SShr16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SShr(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SShr32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L) >>
static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SShr(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) >>
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SShr64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L) >>
static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UShl(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) << static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UShl8(uint8_t L, uint8_t R) {
return static_cast<uint8_t>(static_cast<addr_t>(L) << static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UShl(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L)
<< static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UShl16(uint16_t L, uint16_t R) {
return static_cast<uint16_t>(static_cast<addr_t>(L)
<< static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UShl(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L)
<< static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UShl32(uint32_t L, uint32_t R) {
return static_cast<uint32_t>(static_cast<addr_t>(L)
<< static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UShl(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L)
<< static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UShl64(uint64_t L, uint64_t R) {
return static_cast<uint64_t>(static_cast<uint64_t>(L)
<< static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SShl(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SShl8(int8_t L, int8_t R) {
return static_cast<int8_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SShl(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SShl16(int16_t L, int16_t R) {
return static_cast<int16_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SShl(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SShl32(int32_t L, int32_t R) {
return static_cast<int32_t>(static_cast<addr_diff_t>(L)
<< static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SShl(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L)
<< static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SShl64(int64_t L, int64_t R) {
return static_cast<int64_t>(static_cast<int64_t>(L)
<< static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UNeg(uint8_t R) {
return static_cast<uint8_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UNeg8(uint8_t R) {
return static_cast<uint8_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UNeg(uint16_t R) {
return static_cast<uint16_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UNeg16(uint16_t R) {
return static_cast<uint16_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UNeg(uint32_t R) {
return static_cast<uint32_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UNeg32(uint32_t R) {
return static_cast<uint32_t>(-static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UNeg(uint64_t R) {
return static_cast<uint64_t>(-static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UNeg64(uint64_t R) {
return static_cast<uint64_t>(-static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SNeg(int8_t R) {
return static_cast<int8_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SNeg8(int8_t R) {
return static_cast<int8_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SNeg(int16_t R) {
return static_cast<int16_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SNeg16(int16_t R) {
return static_cast<int16_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SNeg(int32_t R) {
return static_cast<int32_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SNeg32(int32_t R) {
return static_cast<int32_t>(-static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SNeg(int64_t R) {
return static_cast<int64_t>(-static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SNeg64(int64_t R) {
return static_cast<int64_t>(-static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static float32_t FNeg(float32_t R) {
return static_cast<float32_t>(-static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float32_t FNeg32(float32_t R) {
return static_cast<float32_t>(-static_cast<float32_t>(R));
}
[[gnu::always_inline]] inline static float64_t FNeg(float64_t R) {
return static_cast<float64_t>(-static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float64_t FNeg64(float64_t R) {
return static_cast<float64_t>(-static_cast<float64_t>(R));
}
[[gnu::always_inline]] inline static float80_t FNeg(float80_t R) {
return static_cast<float80_t>(-static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static float80_t FNeg80(float80_t R) {
return static_cast<float80_t>(-static_cast<float80_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UNot(uint8_t R) {
return static_cast<uint8_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint8_t UNot8(uint8_t R) {
return static_cast<uint8_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UNot(uint16_t R) {
return static_cast<uint16_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint16_t UNot16(uint16_t R) {
return static_cast<uint16_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UNot(uint32_t R) {
return static_cast<uint32_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint32_t UNot32(uint32_t R) {
return static_cast<uint32_t>(~static_cast<addr_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UNot(uint64_t R) {
return static_cast<uint64_t>(~static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static uint64_t UNot64(uint64_t R) {
return static_cast<uint64_t>(~static_cast<uint64_t>(R));
}
[[gnu::always_inline]] inline static int8_t SNot(int8_t R) {
return static_cast<int8_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int8_t SNot8(int8_t R) {
return static_cast<int8_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SNot(int16_t R) {
return static_cast<int16_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int16_t SNot16(int16_t R) {
return static_cast<int16_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SNot(int32_t R) {
return static_cast<int32_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int32_t SNot32(int32_t R) {
return static_cast<int32_t>(~static_cast<addr_diff_t>(R));
}
[[gnu::always_inline]] inline static int64_t SNot(int64_t R) {
return static_cast<int64_t>(~static_cast<int64_t>(R));
}
[[gnu::always_inline]] inline static int64_t SNot64(int64_t R) {
return static_cast<int64_t>(~static_cast<int64_t>(R));
}

[[gnu::always_inline]] inline static uint128_t UAdd(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) +
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UAdd128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) +
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAdd(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) +
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAdd128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) +
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t USub(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) -
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t USub128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) -
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SSub(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) -
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SSub128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) -
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UMul(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) *
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UMul128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) *
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SMul(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) *
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SMul128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) *
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UDiv(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) /
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UDiv128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) /
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SDiv(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) /
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SDiv128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) /
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t URem(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) %
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t URem128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) %
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SRem(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) %
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SRem128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) %
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UAnd(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) &
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UAnd128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) &
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAnd(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) &
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAnd128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) &
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UAndN(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) &
~static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UAndN128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) &
~static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAndN(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) &
~static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SAndN128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) &
~static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UOr(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) |
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UOr128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) |
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SOr(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) |
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SOr128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) |
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UXor(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) ^
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UXor128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) ^
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SXor(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) ^
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SXor128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) ^
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UShr(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) >>
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UShr128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L) >>
static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SShr(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) >>
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SShr128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L) >>
static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UShl(uint128_t L, uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L)
<< static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UShl128(uint128_t L,
uint128_t R) {
return static_cast<uint128_t>(static_cast<uint128_t>(L)
<< static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SShl(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L)
<< static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SShl128(int128_t L, int128_t R) {
return static_cast<int128_t>(static_cast<int128_t>(L)
<< static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UNeg(uint128_t R) {
return static_cast<uint128_t>(-static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UNeg128(uint128_t R) {
return static_cast<uint128_t>(-static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SNeg(int128_t R) {
return static_cast<int128_t>(-static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SNeg128(int128_t R) {
return static_cast<int128_t>(-static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UNot(uint128_t R) {
return static_cast<uint128_t>(~static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static uint128_t UNot128(uint128_t R) {
return static_cast<uint128_t>(~static_cast<uint128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SNot(int128_t R) {
return static_cast<int128_t>(~static_cast<int128_t>(R));
}
[[gnu::always_inline]] inline static int128_t SNot128(int128_t R) {
return static_cast<int128_t>(~static_cast<int128_t>(R));
}

template <typename T>
[[gnu::always_inline]] inline static T Ror(T val_, T amount_) {
using UT = typename IntegerType<T>::UT;
constexpr UT width = static_cast<UT>(sizeof(UT) * 8);
const UT val = static_cast<UT>(val_);
const UT amount = static_cast<UT>(amount_) % width;
if (!amount) {
return val_;
}
const UT shifted_bits = val >> amount;
const UT rotated_bits = val << (width - amount);
return static_cast<T>(shifted_bits | rotated_bits);
}

template <typename T>
[[gnu::always_inline]] inline static T Rol(T val_, T amount_) {
using UT = typename IntegerType<T>::UT;
constexpr UT width = static_cast<UT>(sizeof(val_) * 8);
const UT val = static_cast<UT>(val_);
const UT amount = static_cast<UT>(amount_) % width;
if (!amount) {
return val_;
}
UT low_bits = val >> (width - amount);
UT high_bits = val << width;
return static_cast<T>(low_bits | high_bits);
}

[[gnu::always_inline]] inline static bool UCmpEq(uint8_t L, uint8_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq8(uint8_t L, uint8_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq(uint16_t L, uint16_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq16(uint16_t L, uint16_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq(uint32_t L, uint32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq32(uint32_t L, uint32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq(uint64_t L, uint64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq64(uint64_t L, uint64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq(int8_t L, int8_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq8(int8_t L, int8_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq(int16_t L, int16_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq16(int16_t L, int16_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq(int32_t L, int32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq32(int32_t L, int32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq(int64_t L, int64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq64(int64_t L, int64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq(float32_t L, float32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq32(float32_t L, float32_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq(float64_t L, float64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq64(float64_t L, float64_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq(float80_t L, float80_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool FCmpEq80(float80_t L, float80_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpNeq(uint8_t L, uint8_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq8(uint8_t L, uint8_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq(uint16_t L, uint16_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq16(uint16_t L, uint16_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq(uint32_t L, uint32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq32(uint32_t L, uint32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq(uint64_t L, uint64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq64(uint64_t L, uint64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq(int8_t L, int8_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq8(int8_t L, int8_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq(int16_t L, int16_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq16(int16_t L, int16_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq(int32_t L, int32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq32(int32_t L, int32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq(int64_t L, int64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq64(int64_t L, int64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq(float32_t L, float32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq32(float32_t L, float32_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq(float64_t L, float64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq64(float64_t L, float64_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq(float80_t L, float80_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool FCmpNeq80(float80_t L, float80_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpLt(uint8_t L, uint8_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt8(uint8_t L, uint8_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt(uint16_t L, uint16_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt16(uint16_t L, uint16_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt(uint32_t L, uint32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt32(uint32_t L, uint32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt(uint64_t L, uint64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt64(uint64_t L, uint64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt(int8_t L, int8_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt8(int8_t L, int8_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt(int16_t L, int16_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt16(int16_t L, int16_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt(int32_t L, int32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt32(int32_t L, int32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt(int64_t L, int64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt64(int64_t L, int64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt(float32_t L, float32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt32(float32_t L, float32_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt(float64_t L, float64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt64(float64_t L, float64_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt(float80_t L, float80_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool FCmpLt80(float80_t L, float80_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLte(uint8_t L, uint8_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte8(uint8_t L, uint8_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte(uint16_t L, uint16_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte16(uint16_t L, uint16_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte(uint32_t L, uint32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte32(uint32_t L, uint32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte(uint64_t L, uint64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte64(uint64_t L, uint64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte(int8_t L, int8_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte8(int8_t L, int8_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte(int16_t L, int16_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte16(int16_t L, int16_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte(int32_t L, int32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte32(int32_t L, int32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte(int64_t L, int64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte64(int64_t L, int64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte(float32_t L, float32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte32(float32_t L, float32_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte(float64_t L, float64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte64(float64_t L, float64_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte(float80_t L, float80_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool FCmpLte80(float80_t L, float80_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpGt(uint8_t L, uint8_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt8(uint8_t L, uint8_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt(uint16_t L, uint16_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt16(uint16_t L, uint16_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt(uint32_t L, uint32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt32(uint32_t L, uint32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt(uint64_t L, uint64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt64(uint64_t L, uint64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt(int8_t L, int8_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt8(int8_t L, int8_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt(int16_t L, int16_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt16(int16_t L, int16_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt(int32_t L, int32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt32(int32_t L, int32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt(int64_t L, int64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt64(int64_t L, int64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt(float32_t L, float32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt32(float32_t L, float32_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt(float64_t L, float64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt64(float64_t L, float64_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt(float80_t L, float80_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool FCmpGt80(float80_t L, float80_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGte(uint8_t L, uint8_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte8(uint8_t L, uint8_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte(uint16_t L, uint16_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte16(uint16_t L, uint16_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte(uint32_t L, uint32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte32(uint32_t L, uint32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte(uint64_t L, uint64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte64(uint64_t L, uint64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte(int8_t L, int8_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte8(int8_t L, int8_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte(int16_t L, int16_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte16(int16_t L, int16_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte(int32_t L, int32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte32(int32_t L, int32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte(int64_t L, int64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte64(int64_t L, int64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte(float32_t L, float32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte32(float32_t L, float32_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte(float64_t L, float64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte64(float64_t L, float64_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte(float80_t L, float80_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool FCmpGte80(float80_t L, float80_t R) {
return L >= R;
}

[[gnu::always_inline]] inline static bool UCmpEq(uint128_t L, uint128_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpEq128(uint128_t L, uint128_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq(int128_t L, int128_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool SCmpEq128(int128_t L, int128_t R) {
return L == R;
}
[[gnu::always_inline]] inline static bool UCmpNeq(uint128_t L, uint128_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpNeq128(uint128_t L, uint128_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq(int128_t L, int128_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool SCmpNeq128(int128_t L, int128_t R) {
return L != R;
}
[[gnu::always_inline]] inline static bool UCmpLt(uint128_t L, uint128_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLt128(uint128_t L, uint128_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt(int128_t L, int128_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool SCmpLt128(int128_t L, int128_t R) {
return L < R;
}
[[gnu::always_inline]] inline static bool UCmpLte(uint128_t L, uint128_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpLte128(uint128_t L, uint128_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte(int128_t L, int128_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool SCmpLte128(int128_t L, int128_t R) {
return L <= R;
}
[[gnu::always_inline]] inline static bool UCmpGt(uint128_t L, uint128_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGt128(uint128_t L, uint128_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt(int128_t L, int128_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool SCmpGt128(int128_t L, int128_t R) {
return L > R;
}
[[gnu::always_inline]] inline static bool UCmpGte(uint128_t L, uint128_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool UCmpGte128(uint128_t L, uint128_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte(int128_t L, int128_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool SCmpGte128(int128_t L, int128_t R) {
return L >= R;
}
[[gnu::always_inline]] inline static bool BAnd(bool a, bool b) {
return a && b;
}

[[gnu::always_inline]] inline static bool BOr(bool a, bool b) { return a || b; }

[[gnu::always_inline]] inline static bool BXor(bool a, bool b) {
return a != b;
}

[[gnu::always_inline]] inline static bool BXnor(bool a, bool b) {
return a == b;
}

[[gnu::always_inline]] inline static bool BNot(bool a) { return !a; }
template <typename T>
[[gnu::always_inline]] inline static T UAddV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAddV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAddV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAddV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAddV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAddV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAddV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAddV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FAddV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FAddV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FAdd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T USubV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = USub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T USubV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = USub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T USubV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = USub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T USubV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = USub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SSubV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SSubV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SSubV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SSubV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FSubV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FSubV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FSub(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UMulV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UMulV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UMulV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UMulV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SMulV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SMulV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SMulV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SMulV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FMulV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FMulV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FMul(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UDivV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UDivV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UDivV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UDivV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SDivV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SDivV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SDivV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SDivV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FDivV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T FDivV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = FDiv(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T URemV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = URem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T URemV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = URem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T URemV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = URem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T URemV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = URem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SRemV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SRem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SRemV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SRem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SRemV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SRem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SRemV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SRem(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAnd(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndNV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndNV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndNV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UAndNV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndNV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndNV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndNV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SAndNV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SAndN(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UOrV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UOrV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UOrV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UOrV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SOrV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SOrV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SOrV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SOrV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SOr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UXorV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UXorV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UXorV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UXorV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SXorV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SXorV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SXorV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SXorV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SXor(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShlV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShlV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShlV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShlV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShlV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShlV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShlV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShlV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShl(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShrV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShrV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShrV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UShrV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = UShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShrV8(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShrV16(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShrV32(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SShrV64(const T &L, const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(L)>::kNumElems); ++i) {
ret.elems[i] = SShr(L.elems[i], R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNegV8(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNegV16(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNegV32(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNegV64(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNegV8(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNegV16(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNegV32(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNegV64(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNeg(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNotV8(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNotV16(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNotV32(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T UNotV64(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = UNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNotV8(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNotV16(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNotV32(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static T SNotV64(const T &R) {
T ret{};
#pragma unroll
for (auto i = 0UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
ret.elems[i] = SNot(R.elems[i]);
}
return ret;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAddV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAddV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAddV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAddV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAddV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAddV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAddV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAddV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateFAddV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = FAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateFAddV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = FAdd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAnd(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndNV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndNV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndNV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUAndNV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndNV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndNV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndNV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSAndNV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SAndN(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUOrV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUOrV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUOrV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUOrV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSOrV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSOrV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSOrV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSOrV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SOr(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUXorV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUXorV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUXorV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateUXorV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = UXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSXorV8(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSXorV16(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSXorV32(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SXor(L, R.elems[i]);
}
return L;
}
template <typename T>
[[gnu::always_inline]] inline static auto AccumulateSXorV64(T R)
-> decltype(R.elems[0] | R.elems[1]) {
auto L = R.elems[0];
#pragma unroll
for (auto i = 1UL;
i < static_cast<addr_t>(VectorType<decltype(R)>::kNumElems); ++i) {
L = SXor(L, R.elems[i]);
}
return L;
}

template <typename T>
[[gnu::always_inline]] inline static auto NthVectorElem(const T &vec, size_t n)
-> typename VectorType<T>::BaseType {
return vec[n];
}
template <typename T>
[[gnu::always_inline]] inline static uint8_t UExtractV8(const T &vec,
size_t n) {
static_assert(sizeof(uint8_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Unsigned(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static uint16_t UExtractV16(const T &vec,
size_t n) {
static_assert(sizeof(uint16_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Unsigned(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static uint32_t UExtractV32(const T &vec,
size_t n) {
static_assert(sizeof(uint32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Unsigned(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static uint64_t UExtractV64(const T &vec,
size_t n) {
static_assert(sizeof(uint64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Unsigned(vec.elems[n]);
}

template <typename T>
[[gnu::always_inline]] inline static uint128_t UExtractV128(const T &vec,
size_t n) {
static_assert(sizeof(uint128_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Unsigned(vec.elems[n]);
}

template <typename T>
[[gnu::always_inline]] inline static int8_t SExtractV8(const T &vec, size_t n) {
static_assert(sizeof(int8_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Signed(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static int16_t SExtractV16(const T &vec,
size_t n) {
static_assert(sizeof(int16_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Signed(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static int32_t SExtractV32(const T &vec,
size_t n) {
static_assert(sizeof(int32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Signed(vec.elems[n]);
}
template <typename T>
[[gnu::always_inline]] inline static int64_t SExtractV64(const T &vec,
size_t n) {
static_assert(sizeof(int64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Signed(vec.elems[n]);
}

template <typename T>
[[gnu::always_inline]] inline static int128_t SExtractV128(const T &vec,
size_t n) {
static_assert(sizeof(int128_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return Signed(vec.elems[n]);
}

template <typename T>
[[gnu::always_inline]] inline static float32_t FExtractV32(const T &vec,
size_t n) {
static_assert(sizeof(float32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return vec.elems[n];
}
template <typename T>
[[gnu::always_inline]] inline static float64_t FExtractV64(const T &vec,
size_t n) {
static_assert(sizeof(float64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return vec.elems[n];
}
template <typename T>
[[gnu::always_inline]] inline static float80_t FExtractV80(const T &vec,
size_t n) {
static_assert(sizeof(float80_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
return vec.elems[n];
}

[[gnu::always_inline]] inline static int8_t SAbs(int8_t val) {
return val < 0 ? -val : val;
}

[[gnu::always_inline]] inline static int16_t SAbs(int16_t val) {
return val < 0 ? -val : val;
}

[[gnu::always_inline]] inline static int32_t SAbs(int32_t val) {
return val < 0 ? -val : val;
}

[[gnu::always_inline]] inline static int64_t SAbs(int64_t val) {
return val < 0 ? -val : val;
}

template <typename T>
[[gnu::always_inline]] inline static auto SAbs(typename IntegerType<T>::ST val)
-> typename IntegerType<T>::ST {
return Select(SLt(val, 0), SNeg(val), val);
}

template <typename T>
[[gnu::always_inline]] inline static auto UAbs(typename IntegerType<T>::UT val)
-> typename IntegerType<T>::UT {
return val;
}
template <typename T>
[[gnu::always_inline]] inline static T UInsertV8(T vec, size_t n, uint8_t val) {
static_assert(sizeof(uint8_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T UInsertV16(T vec, size_t n,
uint16_t val) {
static_assert(sizeof(uint16_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T UInsertV32(T vec, size_t n,
uint32_t val) {
static_assert(sizeof(uint32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T UInsertV64(T vec, size_t n,
uint64_t val) {
static_assert(sizeof(uint64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static T UInsertV128(T vec, size_t n,
uint128_t val) {
static_assert(sizeof(uint128_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static T SInsertV8(T vec, size_t n, int8_t val) {
static_assert(sizeof(int8_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T SInsertV16(T vec, size_t n,
int16_t val) {
static_assert(sizeof(int16_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T SInsertV32(T vec, size_t n,
int32_t val) {
static_assert(sizeof(int32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T SInsertV64(T vec, size_t n,
int64_t val) {
static_assert(sizeof(int64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static T SInsertV128(T vec, size_t n,
int128_t val) {
static_assert(sizeof(int128_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}

template <typename T>
[[gnu::always_inline]] inline static T FInsertV32(T vec, size_t n,
float32_t val) {
static_assert(sizeof(float32_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T FInsertV64(T vec, size_t n,
float64_t val) {
static_assert(sizeof(float64_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static T FInsertV80(T vec, size_t n,
float80_t val) {
static_assert(sizeof(float80_t) == sizeof(typename VectorType<T>::BT),
"Invalid extract");
vec.elems[n] = val;
return vec;
}
template <typename T>
[[gnu::always_inline]] inline static void UUpdateV8(T &vec, size_t n,
uint8_t val) {
static_assert(sizeof(uint8_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void UUpdateV16(T &vec, size_t n,
uint16_t val) {
static_assert(sizeof(uint16_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void UUpdateV32(T &vec, size_t n,
uint32_t val) {
static_assert(sizeof(uint32_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void UUpdateV64(T &vec, size_t n,
uint64_t val) {
static_assert(sizeof(uint64_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}

template <typename T>
[[gnu::always_inline]] inline static void UUpdateV128(T &vec, size_t n,
uint128_t val) {
static_assert(sizeof(uint128_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}

template <typename T>
[[gnu::always_inline]] inline static void SUpdateV8(T &vec, size_t n,
int8_t val) {
static_assert(sizeof(int8_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void SUpdateV16(T &vec, size_t n,
int16_t val) {
static_assert(sizeof(int16_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void SUpdateV32(T &vec, size_t n,
int32_t val) {
static_assert(sizeof(int32_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void SUpdateV64(T &vec, size_t n,
int64_t val) {
static_assert(sizeof(int64_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}

template <typename T>
[[gnu::always_inline]] inline static void SUpdateV128(T &vec, size_t n,
int128_t val) {
static_assert(sizeof(int128_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}

template <typename T>
[[gnu::always_inline]] inline static void FUpdateV32(T &vec, size_t n,
float32_t val) {
static_assert(sizeof(float32_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void FUpdateV64(T &vec, size_t n,
float64_t val) {
static_assert(sizeof(float64_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}
template <typename T>
[[gnu::always_inline]] inline static void FUpdateV80(T &vec, size_t n,
float80_t val) {
static_assert(sizeof(float80_t) == sizeof(typename VectorType<T>::BT),
"Invalid update");
vec.elems[n] = val;
}

template <typename U, typename T>
[[gnu::always_inline]] inline static constexpr T _ZeroVec(void) {
static_assert(std::is_same<U, typename VectorType<T>::BT>::value,
"Vector type and base don't match.");
return {};
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(Rn<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(RnW<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(Vn<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(VnW<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(Mn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(MnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(MVn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(MVnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsRegister(In<T>) {
return false;
}

template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(Rn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(RnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(Vn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(VnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(Mn<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(MnW<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(MVn<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(MVnW<T>) {
return true;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsMemory(In<T>) {
return false;
}

template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(Rn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(RnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(Vn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(VnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(Mn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(MnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(MVn<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(MVnW<T>) {
return false;
}
template <typename T>
[[gnu::always_inline]] inline static constexpr bool IsImmediate(In<T>) {
return true;
}

[[gnu::always_inline]] inline static constexpr bool IsRegister(uint8_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsRegister(uint16_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsRegister(uint32_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsRegister(uint64_t) {
return true;
}

[[gnu::always_inline]] inline static constexpr bool IsImmediate(uint8_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsImmediate(uint16_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsImmediate(uint32_t) {
return true;
}
[[gnu::always_inline]] inline static constexpr bool IsImmediate(uint64_t) {
return true;
}

template <typename T>
[[gnu::always_inline]] inline static Mn<T> GetElementPtr(Mn<T> addr,
addr_t index) {
return {addr.addr + (index * static_cast<addr_t>(sizeof(T)))};
}

template <typename T>
[[gnu::always_inline]] inline static MVn<T> GetElementPtr(MVn<T> addr,
addr_t index) {
return {addr.addr + (index * static_cast<addr_t>(sizeof(T)))};
}

template <typename T>
[[gnu::always_inline]] inline static MnW<T> GetElementPtr(MnW<T> addr,
addr_t index) {
return {addr.addr + (index * static_cast<addr_t>(sizeof(T)))};
}

template <typename T>
[[gnu::always_inline]] inline static MVnW<T> GetElementPtr(MVnW<T> addr,
addr_t index) {
return {addr.addr + (index * static_cast<addr_t>(sizeof(T)))};
}

template <typename T>
[[gnu::always_inline]] inline static auto ReadPtr(addr_t addr)
-> Mn<typename BaseType<T>::BT> {
return {addr};
}

template <typename T>
[[gnu::always_inline]] inline static auto ReadPtr(addr_t addr, addr_t seg_base)
-> Mn<typename BaseType<T>::BT> {
return {addr + seg_base};
}

template <typename T>
[[gnu::always_inline]] inline static auto WritePtr(addr_t addr)
-> MnW<typename BaseType<T>::BT> {
return {addr};
}

template <typename T>
[[gnu::always_inline]] inline static auto WritePtr(addr_t addr, addr_t seg_base)
-> MnW<typename BaseType<T>::BT> {
return {addr + seg_base};
}

template <typename T>
[[gnu::always_inline]] inline static auto VReadPtr(addr_t addr) -> MVn<T> {
return {addr};
}

template <typename T>
[[gnu::always_inline]] inline static auto VReadPtr(addr_t addr, addr_t seg_base)
-> MVn<T> {
return {addr + seg_base};
}

template <typename T>
[[gnu::always_inline]] inline static auto VWritePtr(addr_t addr) -> MVnW<T> {
return {addr};
}

template <typename T>
[[gnu::always_inline]] inline static auto VWritePtr(addr_t addr,
addr_t seg_base)
-> MVnW<T> {
return {addr + seg_base};
}

template <typename T>
[[gnu::always_inline]] inline static addr_t AddressOf(Mn<T> addr) {
return addr.addr;
}

template <typename T>
[[gnu::always_inline]] inline static addr_t AddressOf(MnW<T> addr) {
return addr.addr;
}

template <typename T>
[[gnu::always_inline]] inline static addr_t AddressOf(MVn<T> addr) {
return addr.addr;
}

template <typename T>
[[gnu::always_inline]] inline static addr_t AddressOf(MVnW<T> addr) {
return addr.addr;
}

template <typename T>
[[gnu::always_inline]] inline static Mn<T> DisplaceAddress(Mn<T> addr,
addr_t disp) {
return Mn<T>{addr.addr + disp};
}

template <typename T>
[[gnu::always_inline]] inline static MnW<T> DisplaceAddress(MnW<T> addr,
addr_t disp) {
return MnW<T>{addr.addr + disp};
}

template <typename T>
[[gnu::always_inline]] inline static MVn<T> DisplaceAddress(MVn<T> addr,
addr_t disp) {
return MVn<T>{addr.addr + disp};
}

template <typename T>
[[gnu::always_inline]] inline static MVnW<T> DisplaceAddress(MVnW<T> addr,
addr_t disp) {
return MVnW<T>{addr.addr + disp};
}

template <typename T>
[[gnu::always_inline]] inline static T Select(bool cond, T if_true,
T if_false) {
return cond ? if_true : if_false;
}
[[gnu::always_inline]] inline static uint128_t
__remill_read_memory_128(Memory *mem, addr_t addr) {
uint128_t low_qword = ZExt(__remill_read_memory_64(mem, addr));
uint128_t high_qword = ZExt(__remill_read_memory_64(mem, addr + 8));
return UOr(UShl(high_qword, 64), low_qword);
}

[[gnu::always_inline]] inline static Memory *
__remill_write_memory_128(Memory *mem, addr_t addr, uint128_t val) {
uint64_t low_qword = Trunc(val);
uint64_t high_qword = Trunc(UShr(val, 64));
mem = __remill_write_memory_64(mem, addr, low_qword);
mem = __remill_write_memory_64(mem, addr + 8, high_qword);
return mem;
}
[[gnu::always_inline]] inline static uint8_t CountLeadingZeros(uint8_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint8_t>(__builtin_clz(in_val)) -
static_cast<uint32_t>(24))
: 8;
}
[[gnu::always_inline]] inline static uint16_t CountLeadingZeros(uint16_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint16_t>(__builtin_clz(in_val)) -
static_cast<uint32_t>(16))
: 16;
}
[[gnu::always_inline]] inline static uint32_t CountLeadingZeros(uint32_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint32_t>(__builtin_clz(in_val)) -
static_cast<uint32_t>(0))
: 32;
}
[[gnu::always_inline]] inline static uint64_t CountLeadingZeros(uint64_t val) {
const auto in_val = static_cast<uint64_t>(val);
return in_val ? (static_cast<uint64_t>(__builtin_clzll(in_val)) -
static_cast<uint64_t>(0))
: 64;
}

[[gnu::always_inline]] inline static uint8_t CountTrailingZeros(uint8_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint8_t>(__builtin_ctz(in_val)) -
static_cast<uint32_t>(0))
: 8;
}
[[gnu::always_inline]] inline static uint16_t CountTrailingZeros(uint16_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint16_t>(__builtin_ctz(in_val)) -
static_cast<uint32_t>(0))
: 16;
}
[[gnu::always_inline]] inline static uint32_t CountTrailingZeros(uint32_t val) {
const auto in_val = static_cast<uint32_t>(val);
return in_val ? (static_cast<uint32_t>(__builtin_ctz(in_val)) -
static_cast<uint32_t>(0))
: 32;
}
[[gnu::always_inline]] inline static uint64_t CountTrailingZeros(uint64_t val) {
const auto in_val = static_cast<uint64_t>(val);
return in_val ? (static_cast<uint64_t>(__builtin_ctzll(in_val)) -
static_cast<uint64_t>(0))
: 64;
}
[[gnu::always_inline]] inline static float32_t FAbs(float32_t val) {
return __builtin_fabsf(val);
}
[[gnu::always_inline]] inline static float32_t FAbs32(float32_t val) {
return __builtin_fabsf(val);
}
[[gnu::always_inline]] inline static float64_t FAbs(float64_t val) {
return __builtin_fabs(val);
}
[[gnu::always_inline]] inline static float64_t FAbs64(float64_t val) {
return __builtin_fabs(val);
}
[[gnu::always_inline]] inline static float80_t FAbs(float80_t val) {
return __builtin_fabsl(val);
}
[[gnu::always_inline]] inline static float80_t FAbs80(float80_t val) {
return __builtin_fabsl(val);
};
[[gnu::always_inline]] inline static float32_t FCos(float32_t val) {
return __builtin_cosf(val);
}
[[gnu::always_inline]] inline static float32_t FCos32(float32_t val) {
return __builtin_cosf(val);
}
[[gnu::always_inline]] inline static float64_t FCos(float64_t val) {
return __builtin_cos(val);
}
[[gnu::always_inline]] inline static float64_t FCos64(float64_t val) {
return __builtin_cos(val);
}
[[gnu::always_inline]] inline static float80_t FCos(float80_t val) {
return __builtin_cosl(val);
}
[[gnu::always_inline]] inline static float80_t FCos80(float80_t val) {
return __builtin_cosl(val);
}
[[gnu::always_inline]] inline static float32_t FSin(float32_t val) {
return __builtin_sinf(val);
}
[[gnu::always_inline]] inline static float32_t FSin32(float32_t val) {
return __builtin_sinf(val);
}
[[gnu::always_inline]] inline static float64_t FSin(float64_t val) {
return __builtin_sin(val);
}
[[gnu::always_inline]] inline static float64_t FSin64(float64_t val) {
return __builtin_sin(val);
}
[[gnu::always_inline]] inline static float80_t FSin(float80_t val) {
return __builtin_sinl(val);
}
[[gnu::always_inline]] inline static float80_t FSin80(float80_t val) {
return __builtin_sinl(val);
}
[[gnu::always_inline]] inline static float32_t FTan(float32_t val) {
return __builtin_tanf(val);
}
[[gnu::always_inline]] inline static float32_t FTan32(float32_t val) {
return __builtin_tanf(val);
}
[[gnu::always_inline]] inline static float64_t FTan(float64_t val) {
return __builtin_tan(val);
}
[[gnu::always_inline]] inline static float64_t FTan64(float64_t val) {
return __builtin_tan(val);
}
[[gnu::always_inline]] inline static float80_t FTan(float80_t val) {
return __builtin_tanl(val);
}
[[gnu::always_inline]] inline static float80_t FTan80(float80_t val) {
return __builtin_tanl(val);
}
[[gnu::always_inline]] inline static float32_t FAtan(float32_t val) {
return __builtin_atanf(val);
}
[[gnu::always_inline]] inline static float32_t FAtan32(float32_t val) {
return __builtin_atanf(val);
}
[[gnu::always_inline]] inline static float64_t FAtan(float64_t val) {
return __builtin_atan(val);
}
[[gnu::always_inline]] inline static float64_t FAtan64(float64_t val) {
return __builtin_atan(val);
}
[[gnu::always_inline]] inline static float80_t FAtan(float80_t val) {
return __builtin_atanl(val);
}
[[gnu::always_inline]] inline static float80_t FAtan80(float80_t val) {
return __builtin_atanl(val);
}
[[gnu::always_inline]] inline static float32_t FSqrt(float32_t val) {
return __builtin_sqrtf(val);
}
[[gnu::always_inline]] inline static float32_t FSqrt32(float32_t val) {
return __builtin_sqrtf(val);
}
[[gnu::always_inline]] inline static float64_t FSqrt(float64_t val) {
return __builtin_sqrt(val);
}
[[gnu::always_inline]] inline static float64_t FSqrt64(float64_t val) {
return __builtin_sqrt(val);
}
[[gnu::always_inline]] inline static float80_t FSqrt(float80_t val) {
return __builtin_sqrtl(val);
}
[[gnu::always_inline]] inline static float80_t FSqrt80(float80_t val) {
return __builtin_sqrtl(val);
}
[[gnu::always_inline]] inline static float32_t Exp2(float32_t val) {
return __builtin_exp2f(val);
}
[[gnu::always_inline]] inline static float32_t Exp232(float32_t val) {
return __builtin_exp2f(val);
}
[[gnu::always_inline]] inline static float64_t Exp2(float64_t val) {
return __builtin_exp2(val);
}
[[gnu::always_inline]] inline static float64_t Exp264(float64_t val) {
return __builtin_exp2(val);
}
[[gnu::always_inline]] inline static float80_t Exp2(float80_t val) {
return __builtin_exp2l(val);
}
[[gnu::always_inline]] inline static float80_t Exp280(float80_t val) {
return __builtin_exp2l(val);
}
[[gnu::always_inline]] inline static float32_t Log2(float32_t val) {
return __builtin_log2f(val);
}
[[gnu::always_inline]] inline static float32_t Log232(float32_t val) {
return __builtin_log2f(val);
}
[[gnu::always_inline]] inline static float64_t Log2(float64_t val) {
return __builtin_log2(val);
}
[[gnu::always_inline]] inline static float64_t Log264(float64_t val) {
return __builtin_log2(val);
}
[[gnu::always_inline]] inline static float80_t Log2(float80_t val) {
return __builtin_log2l(val);
}
[[gnu::always_inline]] inline static float80_t Log280(float80_t val) {
return __builtin_log2l(val);
}

[[gnu::always_inline]] inline static float32_t FRoundUsingMode(float32_t val) {
return __builtin_nearbyintf(val);
}
[[gnu::always_inline]] inline static float32_t
FRoundUsingMode32(float32_t val) {
return __builtin_nearbyintf(val);
}
[[gnu::always_inline]] inline static float64_t FRoundUsingMode(float64_t val) {
return __builtin_nearbyint(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundUsingMode64(float64_t val) {
return __builtin_nearbyint(val);
}
[[gnu::always_inline]] inline static float80_t FRoundUsingMode(float80_t val) {
return __builtin_nearbyintl(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundUsingMode80(float80_t val) {
return __builtin_nearbyintl(val);
};
[[gnu::always_inline]] inline static float32_t FTruncTowardZero(float32_t val) {
return __builtin_truncf(val);
}
[[gnu::always_inline]] inline static float32_t
FTruncTowardZero32(float32_t val) {
return __builtin_truncf(val);
}
[[gnu::always_inline]] inline static float64_t FTruncTowardZero(float64_t val) {
return __builtin_trunc(val);
}
[[gnu::always_inline]] inline static float64_t
FTruncTowardZero64(float64_t val) {
return __builtin_trunc(val);
}
[[gnu::always_inline]] inline static float80_t FTruncTowardZero(float80_t val) {
return __builtin_truncl(val);
}
[[gnu::always_inline]] inline static float80_t
FTruncTowardZero80(float80_t val) {
return __builtin_truncl(val);
};
[[gnu::always_inline]] inline static float32_t
FRoundAwayFromZero(float32_t val) {
return __builtin_roundf(val);
}
[[gnu::always_inline]] inline static float32_t
FRoundAwayFromZero32(float32_t val) {
return __builtin_roundf(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundAwayFromZero(float64_t val) {
return __builtin_round(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundAwayFromZero64(float64_t val) {
return __builtin_round(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundAwayFromZero(float80_t val) {
return __builtin_roundl(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundAwayFromZero80(float80_t val) {
return __builtin_roundl(val);
};
[[gnu::always_inline]] inline static float32_t
FRoundToPositiveInfinity(float32_t val) {
return __builtin_ceilf(val);
}
[[gnu::always_inline]] inline static float32_t
FRoundToPositiveInfinity32(float32_t val) {
return __builtin_ceilf(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundToPositiveInfinity(float64_t val) {
return __builtin_ceil(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundToPositiveInfinity64(float64_t val) {
return __builtin_ceil(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundToPositiveInfinity(float80_t val) {
return __builtin_ceill(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundToPositiveInfinity80(float80_t val) {
return __builtin_ceill(val);
};
[[gnu::always_inline]] inline static float32_t
FRoundToNegativeInfinity(float32_t val) {
return __builtin_floorf(val);
}
[[gnu::always_inline]] inline static float32_t
FRoundToNegativeInfinity32(float32_t val) {
return __builtin_floorf(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundToNegativeInfinity(float64_t val) {
return __builtin_floor(val);
}
[[gnu::always_inline]] inline static float64_t
FRoundToNegativeInfinity64(float64_t val) {
return __builtin_floor(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundToNegativeInfinity(float80_t val) {
return __builtin_floorl(val);
}
[[gnu::always_inline]] inline static float80_t
FRoundToNegativeInfinity80(float80_t val) {
return __builtin_floorl(val);
};

[[gnu::always_inline]] inline static int16_t Float64ToInt16(float64_t val) {
auto max_int = Float64(Maximize(Int16(0)));
return Select<int16_t>(FCmpLt(max_int, FAbs(val)), Int16(0x8000), Int16(val));
}

[[gnu::always_inline]] inline static int32_t Float64ToInt32(float64_t val) {
auto max_int = Float64(Maximize(Int32(0)));
return Select<int32_t>(FCmpLt(max_int, FAbs(val)), Int32(0x80000000),
Int32(val));
}

[[gnu::always_inline]] inline static int16_t Float80ToInt16(float80_t val) {
auto max_int = Float80(Float64(Maximize(Int16(0))));
return Select<int16_t>(FCmpLt80(max_int, FAbs80(val)), Int16(0x8000),
Int16(val));
}

[[gnu::always_inline]] inline static int32_t Float80ToInt32(float80_t val) {
auto max_int = Float80(Float64(Maximize(Int32(0))));
return Select<int32_t>(FCmpLt80(max_int, FAbs80(val)), Int32(0x80000000),
Int32(val));
}

[[gnu::always_inline]] inline static int16_t Float32ToInt16(float32_t val) {
auto max_int = Float32(Maximize(Int32(0)));
return Select<int16_t>(FCmpLt(max_int, FAbs(val)), Int16(0x8000), Int16(val));
}

[[gnu::always_inline]] inline static int32_t Float32ToInt32(float32_t val) {
auto max_int = Float32(Maximize(Int32(0)));
return Select<int32_t>(FCmpLt(max_int, FAbs(val)), Int32(0x80000000),
Int32(val));
}

[[gnu::always_inline]] inline static int64_t Float32ToInt64(float32_t val) {
return Int64(val);
}

[[gnu::always_inline]] inline static int64_t Float64ToInt64(float64_t val) {
auto max_int = Float64(Maximize(Int64(0)));
return Select<int64_t>(FCmpLt(max_int, FAbs(val)),
Int64(0x8000000000000000LL), Int64(val));
}

[[gnu::always_inline]] inline static int64_t Float80ToInt64(float80_t val) {
auto max_int = Float80(Float64(Maximize(Int64(0))));
return Select<int64_t>(FCmpLt80(max_int, FAbs80(val)),
Int64(0x8000000000000000LL), Int64(val));
}

[[gnu::always_inline]] inline static float32_t
FRoundToNearestEven32(float32_t val) {
return FRoundUsingMode32(val);
}

[[gnu::always_inline]] inline static float64_t
FRoundToNearestEven64(float64_t val) {
return FRoundUsingMode64(val);
}

} // namespace

#pragma clang diagnostic push
#pragma clang diagnostic fatal "-Wpadded"

struct ArchState {
public:
AsyncHyperCall::Name hyper_call;

uint32_t _0;

union {
uint64_t addr_to_load;
uint64_t addr_to_store;
uint32_t hyper_call_vector;
};
} __attribute__((packed));

static_assert(16 == sizeof(ArchState),
"Invalid packing of `struct ArchState`.");
enum RequestPrivilegeLevel : uint16_t {
kRPLRingZero = 0,
kRPLRingOne = 1,
kRPLRingTwo = 2,
kRPLRingThree = 3
};

enum TableIndicator : uint16_t {
kGlobalDescriptorTable = 0,
kLocalDescriptorTable = 1
};

union SegmentSelector final {
uint16_t flat;
struct {
uint16_t rpi : 2;
uint16_t ti : 1;
uint16_t index : 13;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(SegmentSelector) == 2,
"Invalid packing of `union SegmentSelector`.");

struct SegmentShadow final {
union {
uint32_t dword;
uint64_t qword;
} base;
uint32_t limit;
uint32_t flags;
} __attribute__((packed));

static_assert(sizeof(SegmentShadow) == 16,
"Invalid packing of `struct SegmentShadow`.");

union FPUStatusWord final {
uint16_t flat;
struct {
uint16_t ie : 1;
uint16_t de : 1;
uint16_t ze : 1;
uint16_t oe : 1;
uint16_t ue : 1;
uint16_t pe : 1;
uint16_t sf : 1;
uint16_t es : 1;
uint16_t c0 : 1;
uint16_t c1 : 1;
uint16_t c2 : 1;
uint16_t top : 3;
uint16_t c3 : 1;
uint16_t b : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(2 == sizeof(FPUStatusWord),
"Invalid structure packing of `FPUFlags`.");

enum FPUPrecisionControl : uint16_t {
kPrecisionSingle,
kPrecisionReserved,
kPrecisionDouble,
kPrecisionExtended
};

enum FPURoundingControl : uint16_t {
kFPURoundToNearestEven,
kFPURoundDownNegInf,
kFPURoundUpInf,
kFPURoundToZero
};

enum FPUInfinityControl : uint16_t { kInfinityProjective, kInfinityAffine };

union FPUControlWord final {
uint16_t flat;
struct {
uint16_t im : 1;
uint16_t dm : 1;
uint16_t zm : 1;
uint16_t om : 1;
uint16_t um : 1;
uint16_t pm : 1;
uint16_t _rsvd0 : 2;
uint16_t pc : 2;
uint16_t rc : 2;
uint16_t x : 1;
uint16_t _rsvd1 : 3;
} __attribute__((packed));
} __attribute__((packed));

static_assert(2 == sizeof(FPUControlWord),
"Invalid structure packing of `FPUControl`.");

struct FPUStackElem final {
FPUStackElem() {}
union {
float80_t st;
struct {
uint64_t mmx;
uint16_t infinity;
} __attribute__((packed));
} __attribute__((packed));
uint8_t _rsvd[6];
} __attribute__((packed));

static_assert(0 == __builtin_offsetof(FPUStackElem, st),
"Invalid structure packing of `FPUStackElem::st`.");

static_assert(0 == __builtin_offsetof(FPUStackElem, mmx),
"Invalid structure packing of `FPUStackElem::mmx`.");

static_assert(8 == __builtin_offsetof(FPUStackElem, infinity),
"Invalid structure packing of `FPUStackElem::st`.");

static_assert(10 == __builtin_offsetof(FPUStackElem, _rsvd[0]),
"Invalid structure packing of `FPUStackElem::st`.");

static_assert(16 == sizeof(FPUStackElem),
"Invalid structure packing of `FPUStackElem`.");

union FPUControlStatus {
uint32_t flat;
struct {
uint32_t ie : 1;
uint32_t de : 1;
uint32_t ze : 1;
uint32_t oe : 1;
uint32_t ue : 1;
uint32_t pe : 1;
uint32_t daz : 1;
uint32_t im : 1;
uint32_t dm : 1;
uint32_t zm : 1;
uint32_t om : 1;
uint32_t um : 1;
uint32_t pm : 1;
uint32_t rn : 1;
uint32_t rp : 1;
uint32_t fz : 1;
uint32_t _rsvd : 16;
} __attribute__((packed));
} __attribute__((packed));

static_assert(4 == sizeof(FPUControlStatus),
"Invalid structure packing of `SSEControlStatus`.");

enum FPUTag : uint16_t {
kFPUTagNonZero,
kFPUTagZero,
kFPUTagSpecial,
kFPUTagEmpty
};

enum FPUAbridgedTag : uint8_t { kFPUAbridgedTagEmpty, kFPUAbridgedTagValid };

union FPUTagWord final {
uint16_t flat;
struct {
uint16_t tag0 : 2;
uint16_t tag1 : 2;
uint16_t tag2 : 2;
uint16_t tag3 : 2;
uint16_t tag4 : 2;
uint16_t tag5 : 2;
uint16_t tag6 : 2;
uint16_t tag7 : 2;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(FPUTagWord) == 2,
"Invalid structure packing of `TagWord`.");

union FPUAbridgedTagWord final {
uint8_t flat;
struct {
uint8_t r0 : 1;
uint8_t r1 : 1;
uint8_t r2 : 1;
uint8_t r3 : 1;
uint8_t r4 : 1;
uint8_t r5 : 1;
uint8_t r6 : 1;
uint8_t r7 : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(sizeof(FPUAbridgedTagWord) == 1,
"Invalid structure packing of `FPUAbridgedTagWord`.");

struct FpuFSAVE {
FPUControlWord cwd;
uint16_t _rsvd0;
FPUStatusWord swd;
uint16_t _rsvd1;
FPUTagWord ftw;
uint16_t fop;
uint32_t ip;
SegmentSelector cs;
uint16_t _rsvd2;
uint32_t dp;
SegmentSelector ds;
uint16_t _rsvd3;
FPUStackElem st[8];
} __attribute__((packed));

struct FpuFXSAVE {
FPUControlWord cwd;
FPUStatusWord swd;
FPUAbridgedTagWord ftw;
uint8_t _rsvd0;
uint16_t fop;
uint32_t ip;
SegmentSelector cs;
uint16_t _rsvd1;
uint32_t dp;
SegmentSelector ds;
uint16_t _rsvd2;
FPUControlStatus mxcsr;
FPUControlStatus mxcsr_mask;
FPUStackElem st[8];
vec128_t xmm[16];
} __attribute__((packed));

struct FpuFXSAVE64 {
FPUControlWord cwd;
FPUStatusWord swd;
FPUAbridgedTagWord ftw;
uint8_t _rsvd0;
uint16_t fop;
uint64_t ip;
uint64_t dp;
FPUControlStatus mxcsr;
FPUControlStatus mxcsr_mask;
FPUStackElem st[8];
vec128_t xmm[16];
} __attribute__((packed));

union alignas(16) FPU final {
FPU() {}
struct : public FpuFSAVE {
uint8_t _padding0[512 - sizeof(FpuFSAVE)];
} __attribute__((packed)) fsave;

struct : public FpuFXSAVE {
uint8_t _padding0[512 - sizeof(FpuFXSAVE)];
} __attribute__((packed)) fxsave32;

struct : public FpuFXSAVE64 {
uint8_t _padding0[512 - sizeof(FpuFXSAVE64)];
} __attribute__((packed)) fxsave64;
} __attribute__((packed));

static_assert(512 == sizeof(FPU), "Invalid structure packing of `FPU`.");

struct FPUStatusFlags final {
uint8_t _0;
uint8_t c0;
uint8_t _1;
uint8_t c1;
uint8_t _2;
uint8_t c2;
uint8_t _3;
uint8_t c3;

uint8_t _4;
uint8_t pe;

uint8_t _5;
uint8_t ue;

uint8_t _6;
uint8_t oe;

uint8_t _7;
uint8_t ze;

uint8_t _8;
uint8_t de;

uint8_t _9;
uint8_t ie;

uint8_t _padding[4];
} __attribute__((packed));

static_assert(24 == sizeof(FPUStatusFlags),
"Invalid packing of `FPUStatusFlags`.");

union alignas(8) Flags final {
uint64_t flat;
struct {
uint32_t cf : 1;
uint32_t must_be_1 : 1;
uint32_t pf : 1;
uint32_t must_be_0a : 1;

uint32_t af : 1;
uint32_t must_be_0b : 1;
uint32_t zf : 1;
uint32_t sf : 1;

uint32_t tf : 1;
uint32_t _if : 1;
uint32_t df : 1;
uint32_t of : 1;

uint32_t iopl : 2;
uint32_t nt : 1;
uint32_t must_be_0c : 1;

uint32_t rf : 1;
uint32_t vm : 1;
uint32_t ac : 1;
uint32_t vif : 1;

uint32_t vip : 1;
uint32_t id : 1;
uint32_t reserved_eflags : 10;
uint32_t reserved_rflags;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(Flags), "Invalid structure packing of `Flags`.");

struct alignas(8) ArithFlags final {

volatile uint8_t _0;
uint8_t cf;
volatile uint8_t _1;
uint8_t pf;
volatile uint8_t _2;
uint8_t af;
volatile uint8_t _3;
uint8_t zf;
volatile uint8_t _4;
uint8_t sf;
volatile uint8_t _5;
uint8_t df;
volatile uint8_t _6;
uint8_t of;
volatile uint8_t _7;
volatile uint8_t _8;
} __attribute__((packed));

static_assert(16 == sizeof(ArithFlags), "Invalid packing of `ArithFlags`.");

union XCR0 {
uint64_t flat;

struct {
uint32_t eax;
uint32_t edx;
} __attribute__((packed));

struct {
uint64_t x87_fpu_mmx : 1;
uint64_t xmm : 1;
uint64_t ymm : 1;
uint64_t bndreg : 1;
uint64_t bndcsr : 1;
uint64_t opmask : 1;
uint64_t zmm_hi256 : 1;
uint64_t hi16_zmm : 1;
uint64_t pkru : 1;
uint64_t _reserved0 : 53;
uint64_t lwp : 1;
uint64_t _reserved1 : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(XCR0), "Invalid packing of `XCR0`.");

struct alignas(8) Segments final {
volatile uint16_t _0;
SegmentSelector ss;
volatile uint16_t _1;
SegmentSelector es;
volatile uint16_t _2;
SegmentSelector gs;
volatile uint16_t _3;
SegmentSelector fs;
volatile uint16_t _4;
SegmentSelector ds;
volatile uint16_t _5;
SegmentSelector cs;
} __attribute__((packed));

static_assert(24 == sizeof(Segments), "Invalid packing of `struct Segments`.");

struct alignas(8) SegmentCaches final {
SegmentShadow cs;
SegmentShadow ss;
SegmentShadow ds;
SegmentShadow es;
SegmentShadow fs;
SegmentShadow gs;
} __attribute__((packed));

static_assert(96 == sizeof(SegmentCaches),
"Invalid packing of `struct SegmentCaches`.");

enum DescriptorPrivilegeLevel : uint64_t {
kDPLRingZero = 0,
kDPLRingOne = 1,
kDPLRingTwo = 2,
kDPLRingThree = 3
};

enum DescriptorClass : uint64_t {
kDataSegmentDescriptor,
kCodeSegmentDescriptor,
kSystemSegmentDescriptor,
kGateDescriptor,
kNotPresentDescriptor
};

enum SegmentGranularity : uint64_t {
kSegmentGranularityNotScaled,
kSegmentGranularityScaled
};

enum SegmentDefaultOperandSize : uint64_t {
kSegmentDefaultOperandSize16,
kSegmentDefaultOperandSize32
};

enum SegmentPresentStatus : uint64_t { kSegmentNotPresent, kSegmentPresent };

enum SystemDescriptorType : uint64_t {
kSystemTypeIllegal0,
kSystemTypeIllegal1,
kSystemTypeLDT,
kSystemTypeIllegal2,
kSystemTypeIllegal3,
kSystemTypeIllegal4,
kSystemTypeIllegal5,
kSystemTypeIllegal6,
kSystemTypeIllegal7,
kSystemTypeAvailableTSS,
kSystemTypeIllegal8,
kSystemTypeBusyTSS,
kSystemTypeCallGate,
kSystemTypeIllegal9,
kSystemTypeInterruptGate,
kSystemTypeTrapGate
};

enum CodeSegmentMode : uint64_t {
kSegmentCompatibilityMode,
kSegment64BitMode
};

enum SegmentSystemBit : uint64_t { kSegmentBitSystem, kSegmentBitUser };
struct GenericDescriptor {
uint64_t unused : 44;
uint64_t sbit : 1;
uint64_t dpl : 2;
uint64_t present : 1;
uint64_t unused3 : 16;
} __attribute__((packed));

static_assert(8U == sizeof(GenericDescriptor),
"Invalid packing of `struct GenericDescriptor`.");

union SegmentDescriptor {
uint64_t flat;
struct {
uint16_t limit_low : 16;
uint16_t base_low : 16;
uint16_t base_middle : 8;
uint16_t system_type : 4;
uint16_t system_access : 4;
uint16_t limit_high : 4;
uint16_t available : 1;

uint16_t code_mode : 1;

uint16_t default_operand_size : 1;
uint16_t granularity : 1;

uint16_t base_high : 8;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8U == sizeof(SegmentDescriptor),
"Invalid packing of `struct SegmentDescriptor`.");

struct GateDescriptor {
uint64_t target_offset_low : 16;
uint64_t target_selector : 16;

uint64_t interrupt_stack_table_index : 3;
uint64_t reserved : 5;
uint64_t system_type : 4;
uint64_t access : 4;
uint64_t target_offset_middle : 16;
} __attribute__((packed));

static_assert(8U == sizeof(GateDescriptor),
"Invalid packing of `struct GateDescriptor`.");

struct ExtensionDescriptor {
uint64_t higher_addr : 32;
uint64_t reserved : 32;
} __attribute__((packed));

static_assert(8U == sizeof(ExtensionDescriptor),
"Invalid packing of `struct DescritorExtension`.");

union Descriptor {
GenericDescriptor generic;
SegmentDescriptor segment;
GateDescriptor gate;
ExtensionDescriptor extension;
} __attribute__((packed));

static_assert(8U == sizeof(Descriptor),
"Invalid packing of `struct SystemDescriptorExtra`.");

struct Reg final {
union {
alignas(1) struct {
uint8_t low;
uint8_t high;
} byte;
alignas(2) uint16_t word;
alignas(4) uint32_t dword;
alignas(8) uint64_t qword;
} __attribute__((packed));

} __attribute__((packed));

static_assert(sizeof(uint64_t) == sizeof(Reg), "Invalid packing of `Reg`.");

static_assert(0 == __builtin_offsetof(Reg, byte.low),
"Invalid packing of `Reg::low`.");
static_assert(1 == __builtin_offsetof(Reg, byte.high),
"Invalid packing of `Reg::high`.");
static_assert(0 == __builtin_offsetof(Reg, word),
"Invalid packing of `Reg::word`.");
static_assert(0 == __builtin_offsetof(Reg, dword),
"Invalid packing of `Reg::dword`.");
static_assert(0 == __builtin_offsetof(Reg, qword),
"Invalid packing of `Reg::qword`.");

union alignas(16) VectorReg final {
alignas(16) vec128_t xmm;
alignas(16) vec256_t ymm;
alignas(16) vec512_t zmm;
} __attribute__((packed));

static_assert(0 == __builtin_offsetof(VectorReg, xmm),
"Invalid packing of `VectorReg::xmm`.");

static_assert(0 == __builtin_offsetof(VectorReg, ymm),
"Invalid packing of `VectorReg::ymm`.");

static_assert(0 == __builtin_offsetof(VectorReg, zmm),
"Invalid packing of `VectorReg::zmm`.");

static_assert(64 == sizeof(VectorReg),
"Invalid packing of `struct VectorReg`.");

struct alignas(8) AddressSpace final {
volatile uint64_t _0;
Reg ss_base;
volatile uint64_t _1;
Reg es_base;
volatile uint64_t _2;
Reg gs_base;
volatile uint64_t _3;
Reg fs_base;
volatile uint64_t _4;
Reg ds_base;
volatile uint64_t _5;
Reg cs_base;
} __attribute__((packed));

static_assert(96 == sizeof(AddressSpace),
"Invalid packing of `struct AddressSpace`.");

struct alignas(8) GPR final {

volatile uint64_t _0;
Reg rax;
volatile uint64_t _1;
Reg rbx;
volatile uint64_t _2;
Reg rcx;
volatile uint64_t _3;
Reg rdx;
volatile uint64_t _4;
Reg rsi;
volatile uint64_t _5;
Reg rdi;
volatile uint64_t _6;
Reg rsp;
volatile uint64_t _7;
Reg rbp;
volatile uint64_t _8;
Reg r8;
volatile uint64_t _9;
Reg r9;
volatile uint64_t _10;
Reg r10;
volatile uint64_t _11;
Reg r11;
volatile uint64_t _12;
Reg r12;
volatile uint64_t _13;
Reg r13;
volatile uint64_t _14;
Reg r14;
volatile uint64_t _15;
Reg r15;
volatile uint64_t _16;

Reg rip;
} __attribute__((packed));

static_assert(272 == sizeof(GPR), "Invalid structure packing of `GPR`.");

struct alignas(16) X87Stack final {
struct alignas(16) {
uint8_t _[6];
float80_t val;
} __attribute__((packed)) elems[8];
};

static_assert(128 == sizeof(X87Stack),
"Invalid structure packing of `X87Stack`.");

struct alignas(8) MMX final {
struct alignas(8) {
uint64_t _0;
vec64_t val;
} __attribute__((packed)) elems[8];
};

struct alignas(8) K_REG final {
struct alignas(8) {
uint64_t _0;
uint64_t val;
} __attribute__((packed)) elems[8];
};

static_assert(128 == sizeof(MMX), "Invalid structure packing of `MMX`.");

enum : size_t { kNumVecRegisters = 32 };

struct alignas(16) X86State : public ArchState {

VectorReg vec[kNumVecRegisters];

ArithFlags aflag;
Flags rflag;
Segments seg;
AddressSpace addr;
GPR gpr;
X87Stack st;
MMX mmx;
FPUStatusFlags sw;
XCR0 xcr0;
FPU x87;
SegmentCaches seg_caches;
K_REG k_reg;
} __attribute__((packed));

static_assert((96 + 3264 + 16 + 128) == sizeof(X86State),
"Invalid packing of `struct State`");

struct State : public X86State {};

union CR0Reg {
uint64_t flat;
struct {
uint64_t pe : 1;
uint64_t mp : 1;
uint64_t em : 1;
uint64_t ts : 1;
uint64_t et : 1;
uint64_t ne : 1;
uint64_t _rsvd0 : 10;
uint64_t wp : 1;
uint64_t _rsvd1 : 1;
uint64_t am : 1;
uint64_t _rsvd2 : 10;
uint64_t nw : 1;
uint64_t cd : 1;
uint64_t pg : 1;
uint64_t _rsvd3 : 32;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(CR0Reg), "Invalid packing of CR0Reg");

union CR1Reg {
uint64_t flat;
} __attribute__((packed));

static_assert(8 == sizeof(CR1Reg), "Invalid packing of CR1Reg");

union CR2Reg {
uint64_t flat;
addr_t linear_address;
} __attribute__((packed));

static_assert(8 == sizeof(CR2Reg), "Invalid packing of CR2Reg");

union CR3Reg {
uint64_t flat;
struct {
uint64_t _rsvd0 : 3;
uint64_t pwt : 1;
uint64_t pcd : 1;
uint64_t _rsvd1 : 7;
uint64_t page_dir_base : 52;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(CR3Reg), "Invalid packing of CR3Reg");

union CR4Reg {
uint64_t flat;
struct {
uint64_t vme : 1;
uint64_t pvi : 1;
uint64_t tsd : 1;
uint64_t de : 1;
uint64_t pse : 1;
uint64_t pae : 1;
uint64_t mce : 1;
uint64_t pge : 1;
uint64_t pce : 1;
uint64_t osfxsr : 1;
uint64_t osxmmexcpt : 1;
uint64_t umip : 1;
uint64_t _rsvd0 : 1;
uint64_t vmxe : 1;
uint64_t smxe : 1;
uint64_t _rsvd1 : 1;
uint64_t fsgsbase : 1;
uint64_t pcide : 1;
uint64_t osxsave : 1;
uint64_t _rsvd2 : 1;
uint64_t smep : 1;
uint64_t smap : 1;
uint64_t pke : 1;
uint64_t _rsvd3 : 9;
uint64_t _rsvd4 : 32;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(CR4Reg), "Invalid packing of CR4Reg");

union CR8Reg {
uint64_t flat;
struct {
uint64_t tpr : 4;
uint64_t _rsvd0 : 60;
} __attribute__((packed));
} __attribute__((packed));

static_assert(8 == sizeof(CR8Reg), "Invalid packing of CR8Reg");

#pragma clang diagnostic pop

union bcd_digit_pair_t {
uint8_t u8;
struct {
uint8_t lsd : 4;
uint8_t msd : 4;
} __attribute((packed)) pair;
} __attribute((packed));

struct bcd80_t final {
union bcd_digit_pair_t digit_pairs[9];
struct {
uint8_t _unused : 7;
uint8_t is_negative : 1;
} __attribute((packed));
} __attribute__((packed));

static_assert(10 == sizeof(bcd80_t), "Invalid `bcd80_t` size.");

typedef RnW<uint8_t> R8W;
typedef RnW<uint16_t> R16W;
typedef RnW<uint64_t> R32W;
typedef RnW<uint64_t> R64W;

typedef Rn<uint8_t> R8;
typedef Rn<uint16_t> R16;
typedef Rn<uint32_t> R32;
typedef Rn<uint64_t> R64;

typedef RVn<vec32_t> V32;
typedef RVn<vec64_t> V64;

typedef Vn<vec128_t> V128;
typedef Vn<vec128_t> VV128;
typedef Vn<vec256_t> V256;
typedef Vn<vec256_t> VV256;
typedef Vn<vec512_t> V512;
typedef Vn<vec512_t> VV512;

typedef vec512_t WriteVecType;
typedef RVnW<vec64_t> V32W;
typedef RVnW<vec64_t> V64W;
typedef VnW<vec128_t> V128W;

typedef VnW<WriteVecType> VV128W;
typedef VnW<WriteVecType> VV256W;
typedef VnW<WriteVecType> VV512W;

typedef MnW<uint8_t> M8W;
typedef MnW<uint16_t> M16W;
typedef MnW<uint32_t> M32W;
typedef MnW<uint64_t> M64W;
typedef MnW<uint128_t> M128W;

typedef MnW<bcd80_t> MBCD80W;

typedef MnW<float32_t> MF32W;
typedef MnW<float64_t> MF64W;
typedef MnW<float80_t> MF80W;

typedef Mn<float32_t> MF32;
typedef Mn<float64_t> MF64;
typedef Mn<float80_t> MF80;

typedef MVnW<vec32_t> MV32W;
typedef MVnW<vec64_t> MV64W;
typedef MVnW<vec128_t> MV128W;
typedef MVnW<vec256_t> MV256W;
typedef MVnW<vec512_t> MV512W;

typedef Mn<uint8_t> M8;
typedef Mn<uint16_t> M16;
typedef Mn<uint32_t> M32;
typedef Mn<uint64_t> M64;
typedef Mn<uint128_t> M128;

typedef Mn<bcd80_t> MBCD80;

typedef MVn<vec8_t> MV8;
typedef MVn<vec16_t> MV16;
typedef MVn<vec32_t> MV32;
typedef MVn<vec64_t> MV64;
typedef MVn<vec128_t> MV128;
typedef MVn<vec256_t> MV256;
typedef MVn<vec512_t> MV512;

typedef In<uint8_t> I8;
typedef In<uint16_t> I16;
typedef In<uint32_t> I32;
typedef In<uint64_t> I64;

typedef In<addr_t> PC;

typedef Rn<float32_t> RF32;
typedef RnW<float32_t> RF32W;

typedef Rn<float64_t> RF64;
typedef RnW<float64_t> RF64W;

typedef Rn<float80_t> RF80;
typedef RnW<float80_t> RF80W;

namespace {

[[gnu::always_inline]] inline static uint64_t _Read(Memory *, Reg reg) {
return reg.qword;
}

[[gnu::always_inline]] inline static void _Write(Memory *, Reg &reg,
uint64_t val) {
reg.qword = val;
}

[[gnu::always_inline]] inline static bcd80_t _ReadBCD80(Memory *memory,
Mn<bcd80_t> op) {
bcd80_t bcd = {};
const auto num_digit_pairs = sizeof(bcd.digit_pairs);

#pragma unroll
for (addr_t i = 0; i < num_digit_pairs; i++) {
bcd.digit_pairs[i].u8 = __remill_read_memory_8(memory, op.addr + i);
}
auto msb = __remill_read_memory_8(memory, op.addr + num_digit_pairs);
bcd.is_negative = msb >> 7;

return bcd;
}

[[gnu::always_inline]] inline static Memory *
_WriteBCD80(Memory *memory, MBCD80W dst, bcd80_t src) {
const auto num_digit_pairs = sizeof(src.digit_pairs);

#pragma unroll
for (addr_t i = 0; i < num_digit_pairs; i++) {
memory =
__remill_write_memory_8(memory, dst.addr + i, src.digit_pairs[i].u8);
}

uint8_t msb = static_cast<uint8_t>(src.is_negative << 7);
memory = __remill_write_memory_8(memory, dst.addr + num_digit_pairs, msb);

return memory;
}

[[gnu::always_inline]] inline static Memory *
_WriteBCD80Indefinite(Memory *memory, MBCD80W dst) {
const uint8_t indefinite[sizeof(bcd80_t)] = {
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0xff, 0xff,
};

#pragma unroll
for (addr_t i = 0; i < sizeof(indefinite); i++) {
memory = __remill_write_memory_8(memory, dst.addr + i, indefinite[i]);
}

return memory;
}

} // namespace

State __remill_state;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
HandleUnsupported(Memory *memory, State &state) {
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kAMD64EmulateInstruction);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
HandleInvalidInstruction(Memory *memory, State &state) {
state.hyper_call = AsyncHyperCall::kInvalidInstruction;
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_UNSUPPORTED_INSTRUCTION [[gnu::used]] =
HandleUnsupported;
extern "C" constexpr auto ISEL_INVALID_INSTRUCTION [[gnu::used]] =
HandleInvalidInstruction;

namespace {
template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static auto
PopFromStack(Memory *&memory, State &state) -> T {
addr_t op_size = TruncTo<addr_t>(sizeof(T));
addr_t old_xsp = _Read(memory, state.gpr.rsp.qword);
addr_t new_xsp = UAdd(old_xsp, op_size);
T val = _Read(memory, ReadPtr<T>(old_xsp));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(new_xsp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (new_xsp));
} while (false);
return val;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
SquareRoot32(Memory *&memory, State &state, float32_t src_float) -> float32_t {
auto square_root = src_float;

if (IsNaN(src_float)) {

if (IsSignalingNaN(src_float)) {
nan32_t temp_nan = {src_float};
temp_nan.is_quiet_nan = 1;
square_root = temp_nan.f;

} else {
square_root = src_float;
}
} else {

if (IsNegative(src_float) && src_float != -0.0) {
uint32_t indef_qnan = 0xFFC00000U;
square_root = reinterpret_cast<float32_t &>(indef_qnan);
} else {
square_root = std::sqrt(src_float);
}
}

return square_root;
}

} // namespace

namespace {

enum : uint32_t { kLHS = 2415899639U, kRHS = 70623199U };

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool ZeroFlag(T res) {
return T(0) == res;
}

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool SignFlag(T res) {
return 0 > Signed(res);
}

template <typename T, typename S1, typename S2>
[[gnu::const]] [[gnu::always_inline]] inline static bool ZeroFlag(T res, S1 lhs,
S2 rhs) {
return __remill_flag_computation_zero(T(0) == res, lhs, rhs, res);
}

template <typename T, typename S1, typename S2>
[[gnu::const]] [[gnu::always_inline]] inline static bool
NotZeroFlag(T res, S1 lhs, S2 rhs) {
return !__remill_flag_computation_zero(T(0) == res, lhs, rhs, res);
}

template <typename T, typename S1, typename S2>
[[gnu::const]] [[gnu::always_inline]] inline static bool SignFlag(T res, S1 lhs,
S2 rhs) {
return __remill_flag_computation_sign(0 > Signed(res), lhs, rhs, res);
}

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool
AuxCarryFlag(T lhs, T rhs, T res) {
return ((res ^ lhs ^ rhs) & T(0x10));
}

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool
AuxCarryFlag(T lhs, T rhs, T carry, T res) {
return ((res ^ lhs ^ carry ^ rhs) & T(0x10));
}

[[gnu::const]] [[gnu::always_inline]] inline static bool
ParityFlag(uint8_t r0) {
return !__builtin_parity(static_cast<unsigned>(r0));
}

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool ParityFlag(T x) {
return ParityFlag(static_cast<uint8_t>(x));
}

struct tag_add {};
struct tag_sub {};
struct tag_div {};
struct tag_mul {};

template <typename T> struct Overflow;

template <> struct Overflow<tag_add> {
template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool Flag(T lhs, T rhs,
T res) {
static_assert(std::is_unsigned<T>::value,
"Invalid specialization of `Overflow::Flag` for addition.");
enum { kSignShift = sizeof(T) * 8 - 1 };

const T sign_lhs = lhs >> kSignShift;
const T sign_rhs = rhs >> kSignShift;
const T sign_res = res >> kSignShift;
return __remill_flag_computation_overflow(
2 == ((sign_lhs ^ sign_res) + (sign_rhs ^ sign_res)), lhs, rhs, res);
}
};

template <> struct Overflow<tag_sub> {
template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool Flag(T lhs, T rhs,
T res) {
static_assert(std::is_unsigned<T>::value,
"Invalid specialization of `Overflow::Flag` for "
"subtraction.");
enum { kSignShift = sizeof(T) * 8 - 1 };

const T sign_lhs = lhs >> kSignShift;
const T sign_rhs = rhs >> kSignShift;
const T sign_res = res >> kSignShift;
return __remill_flag_computation_overflow(
2 == ((sign_lhs ^ sign_rhs) + (sign_lhs ^ sign_res)), lhs, rhs, res);
}
};

template <> struct Overflow<tag_mul> {

template <typename T, typename R>
[[gnu::const]] [[gnu::always_inline]] inline static bool
Flag(T lhs, T rhs, R res,
typename std::enable_if<sizeof(T) < sizeof(R), int>::type = 0) {

return __remill_flag_computation_overflow(
static_cast<R>(static_cast<T>(res)) != res, lhs, rhs, res);
}

template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool
Flag(T lhs, T rhs, T,
typename std::enable_if<std::is_signed<T>::value, int>::type = 0) {
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
return Flag<T, decltype(lhs_wide)>(lhs, rhs, lhs_wide * rhs_wide);
}
};

template <typename Tag> struct Carry;

template <> struct Carry<tag_add> {
template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool Flag(T lhs, T rhs,
T res) {
static_assert(std::is_unsigned<T>::value,
"Invalid specialization of `Carry::Flag` for addition.");
return __remill_flag_computation_carry(res < lhs || res < rhs, lhs, rhs,
res);
}
};

template <> struct Carry<tag_sub> {
template <typename T>
[[gnu::const]] [[gnu::always_inline]] inline static bool Flag(T lhs, T rhs,
T res) {
static_assert(std::is_unsigned<T>::value,
"Invalid specialization of `Carry::Flag` for addition.");
return __remill_flag_computation_carry(lhs < rhs, lhs, rhs, res);
}
};

} // namespace
[[gnu::always_inline]] inline static void SetFPSRStatusFlags(State &state,
int mask) {
state.sw.pe |= static_cast<uint8_t>(0 != (mask & 0x20));
state.sw.oe |= static_cast<uint8_t>(0 != (mask & 0x08));
state.sw.ue |= static_cast<uint8_t>(0 != (mask & 0x10));
state.sw.ie |= static_cast<uint8_t>(0 != (mask & 0x01));
state.sw.ze |= static_cast<uint8_t>(0 != (mask & 0x04));
}

template <typename F, typename T>
[[gnu::always_inline]] inline static auto CheckedFloatUnaryOp(State &state,
F func, T arg1)
-> decltype(func(arg1)) {
state.sw.de = IsDenormal(arg1);
auto old_except = __remill_fpu_exception_test_and_clear(
0, (0x20 | 0x04 | 0x10 | 0x08 | 0x01));
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto res = func(arg1);
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto new_except = __remill_fpu_exception_test_and_clear(

(0x20 | 0x04 | 0x10 | 0x08 | 0x01), old_except);
SetFPSRStatusFlags(state, new_except);
return res;
}

template <typename F1, typename F2, typename T>
[[gnu::always_inline]] inline static auto
CheckedFloatUnaryOp2(State &state, F1 func1, F2 func2, T arg1)
-> decltype(func2(func1(arg1))) {
state.sw.de = IsDenormal(arg1);
auto old_except = __remill_fpu_exception_test_and_clear(
0, (0x20 | 0x04 | 0x10 | 0x08 | 0x01));

do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto res1 = func1(arg1);
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto new_except1 = __remill_fpu_exception_test_and_clear(

(0x20 | 0x04 | 0x10 | 0x08 | 0x01), old_except);

do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto res = func2(res1);
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto new_except2 = __remill_fpu_exception_test_and_clear(
(0x20 | 0x04 | 0x10 | 0x08 | 0x01), new_except1);

SetFPSRStatusFlags(state, new_except1 | new_except2);
return res;
}

template <typename F, typename T>
[[gnu::always_inline]] inline static auto
CheckedFloatBinOp(State &state, F func, T arg1, T arg2)
-> decltype(func(arg1, arg2)) {
state.sw.de = IsDenormal(arg1) | IsDenormal(arg2);
auto old_except = __remill_fpu_exception_test_and_clear(
0, (0x20 | 0x04 | 0x10 | 0x08 | 0x01));
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto res = func(arg1, arg2);
do {
__asm__ __volatile__("" ::: "memory");
} while (false);
auto new_except = __remill_fpu_exception_test_and_clear(

(0x20 | 0x04 | 0x10 | 0x08 | 0x01), old_except);
SetFPSRStatusFlags(state, new_except);
return res;
}

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoVZEROUPPER(Memory *memory, State &state) {

#pragma unroll
for (unsigned i = 0; i < 16; ++i) {
auto &vec = state.vec[i];
vec.ymm.dqwords.elems[1] = 0;
vec.zmm.dqwords.elems[2] = 0;
vec.zmm.dqwords.elems[3] = 0;
}
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPBROADCASTB(Memory *memory, State &state, D dst, S1 src1) {
auto src_vec = _UReadV8(memory, src1);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto num_groups =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);
auto src_byte = UExtractV8(src_vec, 0);

for (std::size_t i = 0; i < num_groups; ++i) {
dst_vec = UInsertV8(dst_vec, i, src_byte);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPBROADCASTQ(Memory *memory, State &state, D dst, S1 src1) {
auto src_vec = _UReadV64(memory, src1);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto num_groups =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);
auto src_val = UExtractV64(src_vec, 0);

for (std::size_t i = 0; i < num_groups; ++i) {
dst_vec = UInsertV64(dst_vec, i, src_val);
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VINSERTF128(Memory *memory, State &state, VV256W dst, V256 src1, S2 src2,
I8 src3) {
auto dst_vec = _UReadV128(memory, src1);
auto src2_vec = _UReadV128(memory, src2);
auto src3_i8 = _Read(memory, src3);
auto i = static_cast<unsigned>(src3_i8 & 1u);
dst_vec = UInsertV128(dst_vec, i, UExtractV128(src2_vec, 0));
do {
memory = _UWriteV128(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_VINSERTF128_YMMqq_YMMqq_MEMdq_IMMb
[[gnu::used]] = VINSERTF128<MV128>;
extern "C" constexpr auto ISEL_VINSERTF128_YMMqq_YMMqq_XMMdq_IMMb
[[gnu::used]] = VINSERTF128<V128>;

extern "C" constexpr auto ISEL_VZEROUPPER [[gnu::used]] = DoVZEROUPPER;
extern "C" constexpr auto ISEL_VPBROADCASTB_YMMqq_XMMb [[gnu::used]] =
VPBROADCASTB<VV256W, V128>;
extern "C" constexpr auto ISEL_VPBROADCASTQ_YMMqq_XMMq [[gnu::used]] =
VPBROADCASTQ<VV256W, V128>;

namespace {

template <typename Tag, typename T>
[[gnu::always_inline]] inline static void WriteFlagsIncDec(State &state, T lhs,
T rhs, T res) {
state.aflag.pf = ParityFlag(res);
state.aflag.af = AuxCarryFlag(lhs, rhs, res);
state.aflag.zf = ZeroFlag(res, lhs, rhs);
state.aflag.sf = SignFlag(res, lhs, rhs);
state.aflag.of = Overflow<Tag>::Flag(lhs, rhs, res);
}

template <typename Tag, typename T>
[[gnu::always_inline]] inline static void WriteFlagsAddSub(State &state, T lhs,
T rhs, T res) {
state.aflag.cf = Carry<Tag>::Flag(lhs, rhs, res);
WriteFlagsIncDec<Tag>(state, lhs, rhs, res);
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto sum = UAdd(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(sum)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(sum)));
} while (false);
} while (false);
WriteFlagsAddSub<tag_add>(state, lhs, rhs, sum);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADDPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV32(memory, dst,
(FAddV32(_FReadV32(memory, src1), _FReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADDPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV64(memory, dst,
(FAddV64(_FReadV64(memory, src1), _FReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADDSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV32(memory, src1);
auto rhs = _FReadV32(memory, src2);
auto sum = FAdd(FExtractV32(lhs, 0), FExtractV32(rhs, 0));
auto res = FInsertV32(lhs, 0, sum);
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADDSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV64(memory, src1);
auto rhs = _FReadV64(memory, src2);
auto sum = FAdd(FExtractV64(lhs, 0), FExtractV64(rhs, 0));
auto res = FInsertV64(lhs, 0, sum);
do {
memory = _FWriteV64(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_ADD_MEMb_IMMb_80r0 [[gnu::used]] =
ADD<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADD_GPR8_IMMb_80r0 [[gnu::used]] =
ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMz_8 [[gnu::used]] = ADD<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMz_16 [[gnu::used]] =
ADD<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMz_32 [[gnu::used]] =
ADD<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMz_64 [[gnu::used]] =
ADD<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMz_8 [[gnu::used]] = ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMz_16 [[gnu::used]] =
ADD<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMz_32 [[gnu::used]] =
ADD<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMz_64 [[gnu::used]] =
ADD<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ADD_MEMb_IMMb_82r0 [[gnu::used]] =
ADD<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADD_GPR8_IMMb_82r0 [[gnu::used]] =
ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMb_8 [[gnu::used]] = ADD<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMb_16 [[gnu::used]] =
ADD<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMb_32 [[gnu::used]] =
ADD<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ADD_MEMv_IMMb_64 [[gnu::used]] =
ADD<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMb_8 [[gnu::used]] = ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMb_16 [[gnu::used]] =
ADD<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMb_32 [[gnu::used]] =
ADD<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADD_GPRv_IMMb_64 [[gnu::used]] =
ADD<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ADD_MEMb_GPR8 [[gnu::used]] = ADD<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ADD_GPR8_GPR8_00 [[gnu::used]] =
ADD<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADD_MEMv_GPRv_8 [[gnu::used]] = ADD<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ADD_MEMv_GPRv_16 [[gnu::used]] =
ADD<M16W, M16, R16>;
extern "C" constexpr auto ISEL_ADD_MEMv_GPRv_32 [[gnu::used]] =
ADD<M32W, M32, R32>;
extern "C" constexpr auto ISEL_ADD_MEMv_GPRv_64 [[gnu::used]] =
ADD<M64W, M64, R64>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_01_8 [[gnu::used]] =
ADD<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_01_16 [[gnu::used]] =
ADD<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_01_32 [[gnu::used]] =
ADD<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_01_64 [[gnu::used]] =
ADD<R64W, R64, R64>;
extern "C" constexpr auto ISEL_ADD_GPR8_MEMb [[gnu::used]] = ADD<R8W, R8, M8>;
extern "C" constexpr auto ISEL_ADD_GPR8_GPR8_02 [[gnu::used]] =
ADD<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADD_GPRv_MEMv_8 [[gnu::used]] = ADD<R8W, R8, M8>;
extern "C" constexpr auto ISEL_ADD_GPRv_MEMv_16 [[gnu::used]] =
ADD<R16W, R16, M16>;
extern "C" constexpr auto ISEL_ADD_GPRv_MEMv_32 [[gnu::used]] =
ADD<R32W, R32, M32>;
extern "C" constexpr auto ISEL_ADD_GPRv_MEMv_64 [[gnu::used]] =
ADD<R64W, R64, M64>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_03_8 [[gnu::used]] =
ADD<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_03_16 [[gnu::used]] =
ADD<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_03_32 [[gnu::used]] =
ADD<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ADD_GPRv_GPRv_03_64 [[gnu::used]] =
ADD<R64W, R64, R64>;
extern "C" constexpr auto ISEL_ADD_AL_IMMb [[gnu::used]] = ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_OrAX_IMMz_8 [[gnu::used]] = ADD<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADD_OrAX_IMMz_16 [[gnu::used]] =
ADD<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADD_OrAX_IMMz_32 [[gnu::used]] =
ADD<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADD_OrAX_IMMz_64 [[gnu::used]] =
ADD<R64W, R64, I64>;

extern "C" constexpr auto ISEL_ADDPS_XMMps_MEMps [[gnu::used]] =
ADDPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ADDPS_XMMps_XMMps [[gnu::used]] =
ADDPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VADDPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
ADDPS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VADDPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
ADDPS<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VADDPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
ADDPS<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VADDPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
ADDPS<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_ADDPD_XMMpd_MEMpd [[gnu::used]] =
ADDPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ADDPD_XMMpd_XMMpd [[gnu::used]] =
ADDPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VADDPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
ADDPD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VADDPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
ADDPD<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VADDPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
ADDPD<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VADDPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
ADDPD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_ADDSS_XMMss_MEMss [[gnu::used]] =
ADDSS<V128W, V128, MV32>;
extern "C" constexpr auto ISEL_ADDSS_XMMss_XMMss [[gnu::used]] =
ADDSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VADDSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
ADDSS<VV128W, VV128, MV32>;
extern "C" constexpr auto ISEL_VADDSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
ADDSS<VV128W, VV128, VV128>;

extern "C" constexpr auto ISEL_ADDSD_XMMsd_MEMsd [[gnu::used]] =
ADDSD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_ADDSD_XMMsd_XMMsd [[gnu::used]] =
ADDSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VADDSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
ADDSD<VV128W, VV128, MV64>;
extern "C" constexpr auto ISEL_VADDSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
ADDSD<VV128W, VV128, VV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SUB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto sum = USub(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(sum)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(sum)));
} while (false);
} while (false);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, sum);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SUBPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV32(memory, dst,
(FSubV32(_FReadV32(memory, src1), _FReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SUBPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV64(memory, dst,
(FSubV64(_FReadV64(memory, src1), _FReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SUBSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV32(memory, src1);
auto rhs = _FReadV32(memory, src2);
auto sum = FSub(FExtractV32(lhs, 0), FExtractV32(rhs, 0));
auto res = FInsertV32(lhs, 0, sum);
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SUBSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV64(memory, src1);
auto rhs = _FReadV64(memory, src2);
auto sum = FSub(FExtractV64(lhs, 0), FExtractV64(rhs, 0));
auto res = FInsertV64(lhs, 0, sum);
do {
memory = _FWriteV64(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SUB_MEMb_IMMb_80r5 [[gnu::used]] =
SUB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SUB_GPR8_IMMb_80r5 [[gnu::used]] =
SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMz_8 [[gnu::used]] = SUB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMz_16 [[gnu::used]] =
SUB<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMz_32 [[gnu::used]] =
SUB<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMz_64 [[gnu::used]] =
SUB<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMz_8 [[gnu::used]] = SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMz_16 [[gnu::used]] =
SUB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMz_32 [[gnu::used]] =
SUB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMz_64 [[gnu::used]] =
SUB<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SUB_MEMb_IMMb_82r5 [[gnu::used]] =
SUB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SUB_GPR8_IMMb_82r5 [[gnu::used]] =
SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMb_8 [[gnu::used]] = SUB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMb_16 [[gnu::used]] =
SUB<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMb_32 [[gnu::used]] =
SUB<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SUB_MEMv_IMMb_64 [[gnu::used]] =
SUB<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMb_8 [[gnu::used]] = SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMb_16 [[gnu::used]] =
SUB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMb_32 [[gnu::used]] =
SUB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SUB_GPRv_IMMb_64 [[gnu::used]] =
SUB<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SUB_MEMb_GPR8 [[gnu::used]] = SUB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SUB_GPR8_GPR8_28 [[gnu::used]] =
SUB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SUB_MEMv_GPRv_8 [[gnu::used]] = SUB<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SUB_MEMv_GPRv_16 [[gnu::used]] =
SUB<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SUB_MEMv_GPRv_32 [[gnu::used]] =
SUB<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SUB_MEMv_GPRv_64 [[gnu::used]] =
SUB<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_29_8 [[gnu::used]] =
SUB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_29_16 [[gnu::used]] =
SUB<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_29_32 [[gnu::used]] =
SUB<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_29_64 [[gnu::used]] =
SUB<R64W, R64, R64>;
extern "C" constexpr auto ISEL_SUB_GPR8_GPR8_2A [[gnu::used]] =
SUB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SUB_GPR8_MEMb [[gnu::used]] = SUB<R8W, R8, M8>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_2B_8 [[gnu::used]] =
SUB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_2B_16 [[gnu::used]] =
SUB<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_2B_32 [[gnu::used]] =
SUB<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SUB_GPRv_GPRv_2B_64 [[gnu::used]] =
SUB<R64W, R64, R64>;
extern "C" constexpr auto ISEL_SUB_GPRv_MEMv_8 [[gnu::used]] = SUB<R8W, R8, M8>;
extern "C" constexpr auto ISEL_SUB_GPRv_MEMv_16 [[gnu::used]] =
SUB<R16W, R16, M16>;
extern "C" constexpr auto ISEL_SUB_GPRv_MEMv_32 [[gnu::used]] =
SUB<R32W, R32, M32>;
extern "C" constexpr auto ISEL_SUB_GPRv_MEMv_64 [[gnu::used]] =
SUB<R64W, R64, M64>;
extern "C" constexpr auto ISEL_SUB_AL_IMMb [[gnu::used]] = SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_OrAX_IMMz_8 [[gnu::used]] = SUB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SUB_OrAX_IMMz_16 [[gnu::used]] =
SUB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SUB_OrAX_IMMz_32 [[gnu::used]] =
SUB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SUB_OrAX_IMMz_64 [[gnu::used]] =
SUB<R64W, R64, I64>;

extern "C" constexpr auto ISEL_SUBPS_XMMps_MEMps [[gnu::used]] =
SUBPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_SUBPS_XMMps_XMMps [[gnu::used]] =
SUBPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VSUBPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
SUBPS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VSUBPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
SUBPS<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VSUBPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
SUBPS<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VSUBPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
SUBPS<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_SUBPD_XMMpd_MEMpd [[gnu::used]] =
SUBPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_SUBPD_XMMpd_XMMpd [[gnu::used]] =
SUBPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VSUBPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
SUBPD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VSUBPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
SUBPD<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VSUBPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
SUBPD<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VSUBPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
SUBPD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_SUBSS_XMMss_MEMss [[gnu::used]] =
SUBSS<V128W, V128, MV32>;
extern "C" constexpr auto ISEL_SUBSS_XMMss_XMMss [[gnu::used]] =
SUBSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VSUBSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
SUBSS<VV128W, VV128, MV32>;
extern "C" constexpr auto ISEL_VSUBSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
SUBSS<VV128W, VV128, VV128>;

extern "C" constexpr auto ISEL_SUBSD_XMMsd_MEMsd [[gnu::used]] =
SUBSD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_SUBSD_XMMsd_XMMsd [[gnu::used]] =
SUBSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VSUBSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
SUBSD<VV128W, VV128, MV64>;
extern "C" constexpr auto ISEL_VSUBSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
SUBSD<VV128W, VV128, VV128>;

namespace {

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMP(Memory *memory, State &state, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto sum = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, sum);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CMP_MEMb_IMMb_80r7 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_GPR8_IMMb_80r7 [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMz_8 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMz_16 [[gnu::used]] = CMP<M16, I16>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMz_32 [[gnu::used]] = CMP<M32, I32>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMz_64 [[gnu::used]] = CMP<M64, I64>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMz_8 [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMz_16 [[gnu::used]] = CMP<R16, I16>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMz_32 [[gnu::used]] = CMP<R32, I32>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMz_64 [[gnu::used]] = CMP<R64, I64>;
extern "C" constexpr auto ISEL_CMP_MEMb_IMMb_82r7 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_GPR8_IMMb_82r7 [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMb_8 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMb_16 [[gnu::used]] = CMP<M16, I16>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMb_32 [[gnu::used]] = CMP<M32, I32>;
extern "C" constexpr auto ISEL_CMP_MEMv_IMMb_64 [[gnu::used]] = CMP<M64, I64>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMb_8 [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMb_16 [[gnu::used]] = CMP<R16, I16>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMb_32 [[gnu::used]] = CMP<R32, I32>;
extern "C" constexpr auto ISEL_CMP_GPRv_IMMb_64 [[gnu::used]] = CMP<R64, I64>;
extern "C" constexpr auto ISEL_CMP_MEMb_GPR8 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_GPR8_GPR8_38 [[gnu::used]] = CMP<R8, R8>;
extern "C" constexpr auto ISEL_CMP_MEMv_GPRv_8 [[gnu::used]] = CMP<M8, I8>;
extern "C" constexpr auto ISEL_CMP_MEMv_GPRv_16 [[gnu::used]] = CMP<M16, I16>;
extern "C" constexpr auto ISEL_CMP_MEMv_GPRv_32 [[gnu::used]] = CMP<M32, I32>;
extern "C" constexpr auto ISEL_CMP_MEMv_GPRv_64 [[gnu::used]] = CMP<M64, I64>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_39_8 [[gnu::used]] = CMP<R8, R8>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_39_16 [[gnu::used]] =
CMP<R16, R16>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_39_32 [[gnu::used]] =
CMP<R32, R32>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_39_64 [[gnu::used]] =
CMP<R64, R64>;
extern "C" constexpr auto ISEL_CMP_GPR8_GPR8_3A [[gnu::used]] = CMP<R8, R8>;
extern "C" constexpr auto ISEL_CMP_GPR8_MEMb [[gnu::used]] = CMP<R8, M8>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_3B_8 [[gnu::used]] = CMP<R8, R8>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_3B_16 [[gnu::used]] =
CMP<R16, R16>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_3B_32 [[gnu::used]] =
CMP<R32, R32>;
extern "C" constexpr auto ISEL_CMP_GPRv_GPRv_3B_64 [[gnu::used]] =
CMP<R64, R64>;
extern "C" constexpr auto ISEL_CMP_GPRv_MEMv_8 [[gnu::used]] = CMP<R8, M8>;
extern "C" constexpr auto ISEL_CMP_GPRv_MEMv_16 [[gnu::used]] = CMP<R16, M16>;
extern "C" constexpr auto ISEL_CMP_GPRv_MEMv_32 [[gnu::used]] = CMP<R32, M32>;
extern "C" constexpr auto ISEL_CMP_GPRv_MEMv_64 [[gnu::used]] = CMP<R64, M64>;
extern "C" constexpr auto ISEL_CMP_AL_IMMb [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_OrAX_IMMz_8 [[gnu::used]] = CMP<R8, I8>;
extern "C" constexpr auto ISEL_CMP_OrAX_IMMz_16 [[gnu::used]] = CMP<R16, I16>;
extern "C" constexpr auto ISEL_CMP_OrAX_IMMz_32 [[gnu::used]] = CMP<R32, I32>;
extern "C" constexpr auto ISEL_CMP_OrAX_IMMz_64 [[gnu::used]] = CMP<R64, I64>;

namespace {

template <typename T, typename U, typename V>
[[gnu::always_inline]] inline static void
WriteFlagsMul(State &state, T lhs, T rhs, U res, V res_trunc) {
const auto new_of = Overflow<tag_mul>::Flag(lhs, rhs, res);
state.aflag.cf = new_of;
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = new_of;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IMUL(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = Signed(_Read(memory, src1));
auto rhs = Signed(_Read(memory, src2));
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
auto res = SMul(lhs_wide, rhs_wide);
auto res_trunc = TruncTo<S2>(res);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res_trunc)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res_trunc)));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}

template <typename D, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULX(Memory *memory, State &state, D dst1, D dst2, const S2 src2) {
auto lhs = ZExt(_Read(memory, src2));

auto rhs = ZExt(TruncTo<S2>(_Read(memory, state.gpr.rdx.qword)));
auto res = UMul(lhs, rhs);
auto res_high = UShr(res, ZExt(BitSizeOf(src2)));

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst1)>::BT) ==
sizeof(ZExtTo<decltype(dst1)>(TruncTo<S2>(res_high))),
"Bad write!");
memory =
_Write(memory, dst1, (ZExtTo<decltype(dst1)>(TruncTo<S2>(res_high))));
} while (false);
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst2)>::BT) ==
sizeof(ZExtTo<decltype(dst2)>(TruncTo<S2>(res))),
"Bad write!");
memory = _Write(memory, dst2, (ZExtTo<decltype(dst2)>(TruncTo<S2>(res))));
} while (false);
} while (false);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULal(Memory *memory, State &state, S2 src2) {
auto lhs = _Read(memory, state.gpr.rax.byte.low);
auto rhs = _Read(memory, src2);
auto lhs_wide = ZExt(lhs);
auto rhs_wide = ZExt(rhs);
auto res = UMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(res_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(res_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.high)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.high)>(
Trunc(UShr(res, shift)))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.byte.high,
(ZExtTo<decltype(state.gpr.rax.byte.high)>(Trunc(UShr(res, shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULax(Memory *memory, State &state, S2 src2) {
auto lhs = _Read(memory, state.gpr.rax.word);
auto rhs = _Read(memory, src2);
auto lhs_wide = ZExt(lhs);
auto rhs_wide = ZExt(rhs);
auto res = UMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(res_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(res_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.word)>(
Trunc(UShr(res, shift)))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.word,
(ZExtTo<decltype(state.gpr.rdx.word)>(Trunc(UShr(res, shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULeax(Memory *memory, State &state, S2 src2) {
auto lhs = _Read(memory, state.gpr.rax.dword);
auto rhs = _Read(memory, src2);
auto lhs_wide = ZExt(lhs);
auto rhs_wide = ZExt(rhs);
auto res = UMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(res_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(res_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(res, shift)))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(Trunc(UShr(res, shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULrax(Memory *memory, State &state, S2 src2) {
auto lhs = _Read(memory, state.gpr.rax.qword);
auto rhs = _Read(memory, src2);
auto lhs_wide = ZExt(lhs);
auto rhs_wide = ZExt(rhs);
auto res = UMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(res_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(res_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(res, shift)))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(Trunc(UShr(res, shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IMULal(Memory *memory, State &state, S2 src2) {
auto lhs = Signed(_Read(memory, state.gpr.rax.byte.low));
auto rhs = Signed(_Read(memory, src2));
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
auto res = SMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(
Unsigned(res_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(Unsigned(res_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.high)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.high)>(
Trunc(UShr(Unsigned(res), shift)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.high,
(ZExtTo<decltype(state.gpr.rax.byte.high)>(
Trunc(UShr(Unsigned(res), shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IMULax(Memory *memory, State &state, S2 src2) {
auto lhs = Signed(_Read(memory, state.gpr.rax.word));
auto rhs = Signed(_Read(memory, src2));
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
auto res = SMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(Unsigned(res_trunc))),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(Unsigned(res_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.word)>(
Trunc(UShr(Unsigned(res), shift)))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.word,
(ZExtTo<decltype(state.gpr.rdx.word)>(
Trunc(UShr(Unsigned(res), shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IMULeax(Memory *memory, State &state, S2 src2) {
auto lhs = Signed(_Read(memory, state.gpr.rax.dword));
auto rhs = Signed(_Read(memory, src2));
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
auto res = SMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(
ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(res_trunc))),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(res_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(Unsigned(res), shift)))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(Unsigned(res), shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IMULrax(Memory *memory, State &state, S2 src2) {
auto lhs = Signed(_Read(memory, state.gpr.rax.qword));
auto rhs = Signed(_Read(memory, src2));
auto lhs_wide = SExt(lhs);
auto rhs_wide = SExt(rhs);
auto res = SMul(lhs_wide, rhs_wide);
auto res_trunc = Trunc(res);
auto shift = ZExt(BitSizeOf(src2));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(
ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(res_trunc))),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(res_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(Unsigned(res), shift)))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(Unsigned(res), shift)))));
} while (false);
} while (false);
WriteFlagsMul(state, lhs, rhs, res, res_trunc);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV32(memory, dst,
(FMulV32(_FReadV32(memory, src1), _FReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV64(memory, dst,
(FMulV64(_FReadV64(memory, src1), _FReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV32(memory, src1);
auto rhs = _FReadV32(memory, src2);
auto mul = FMul(FExtractV32(lhs, 0), FExtractV32(rhs, 0));
auto res = FInsertV32(lhs, 0, mul);
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MULSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV64(memory, src1);
auto rhs = _FReadV64(memory, src2);
auto mul = FMul(FExtractV64(lhs, 0), FExtractV64(rhs, 0));
auto res = FInsertV64(lhs, 0, mul);
do {
memory = _FWriteV64(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_IMUL_MEMb [[gnu::used]] = IMULal<M8>;
extern "C" constexpr auto ISEL_IMUL_GPR8 [[gnu::used]] = IMULal<R8>;
extern "C" constexpr auto ISEL_IMUL_MEMv_8 [[gnu::used]] = IMULal<M8>;
extern "C" constexpr auto ISEL_IMUL_MEMv_16 [[gnu::used]] = IMULax<M16>;
extern "C" constexpr auto ISEL_IMUL_MEMv_32 [[gnu::used]] = IMULeax<M32>;
extern "C" constexpr auto ISEL_IMUL_MEMv_64 [[gnu::used]] = IMULrax<M64>;
extern "C" constexpr auto ISEL_IMUL_GPRv_8 [[gnu::used]] = IMULal<R8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_16 [[gnu::used]] = IMULax<R16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_32 [[gnu::used]] = IMULeax<R32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_64 [[gnu::used]] = IMULrax<R64>;

extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMz_8 [[gnu::used]] =
IMUL<R8W, M8, I8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMz_16 [[gnu::used]] =
IMUL<R16W, M16, I16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMz_32 [[gnu::used]] =
IMUL<R32W, M32, I32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMz_64 [[gnu::used]] =
IMUL<R64W, M64, I64>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMz_8 [[gnu::used]] =
IMUL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMz_16 [[gnu::used]] =
IMUL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMz_32 [[gnu::used]] =
IMUL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMz_64 [[gnu::used]] =
IMUL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMb_8 [[gnu::used]] =
IMUL<R8W, M8, I8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMb_16 [[gnu::used]] =
IMUL<R16W, M16, I16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMb_32 [[gnu::used]] =
IMUL<R32W, M32, I32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_IMMb_64 [[gnu::used]] =
IMUL<R64W, M64, I64>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMb_8 [[gnu::used]] =
IMUL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMb_16 [[gnu::used]] =
IMUL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMb_32 [[gnu::used]] =
IMUL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_IMMb_64 [[gnu::used]] =
IMUL<R64W, R64, I64>;

extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_8 [[gnu::used]] =
IMUL<R8W, R8, M8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_16 [[gnu::used]] =
IMUL<R16W, R16, M16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_32 [[gnu::used]] =
IMUL<R32W, R32, M32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_MEMv_64 [[gnu::used]] =
IMUL<R64W, R64, M64>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_8 [[gnu::used]] =
IMUL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_16 [[gnu::used]] =
IMUL<R16W, R16, R16>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_32 [[gnu::used]] =
IMUL<R32W, R32, R32>;
extern "C" constexpr auto ISEL_IMUL_GPRv_GPRv_64 [[gnu::used]] =
IMUL<R64W, R64, R64>;

extern "C" constexpr auto ISEL_MUL_GPR8 [[gnu::used]] = MULal<R8>;
extern "C" constexpr auto ISEL_MUL_MEMb [[gnu::used]] = MULal<M8>;
extern "C" constexpr auto ISEL_MUL_MEMv_8 [[gnu::used]] = MULal<M8>;
extern "C" constexpr auto ISEL_MUL_MEMv_16 [[gnu::used]] = MULax<M16>;
extern "C" constexpr auto ISEL_MUL_MEMv_32 [[gnu::used]] = MULeax<M32>;
extern "C" constexpr auto ISEL_MUL_MEMv_64 [[gnu::used]] = MULrax<M64>;
extern "C" constexpr auto ISEL_MUL_GPRv_8 [[gnu::used]] = MULal<R8>;
extern "C" constexpr auto ISEL_MUL_GPRv_16 [[gnu::used]] = MULax<R16>;
extern "C" constexpr auto ISEL_MUL_GPRv_32 [[gnu::used]] = MULeax<R32>;
extern "C" constexpr auto ISEL_MUL_GPRv_64 [[gnu::used]] = MULrax<R64>;

extern "C" constexpr auto ISEL_MULX_VGPR32d_VGPR32d_VGPR32d [[gnu::used]] =
MULX<R32W, R32>;
extern "C" constexpr auto ISEL_MULX_VGPR32d_VGPR32d_MEMd [[gnu::used]] =
MULX<R32W, M32>;
extern "C" constexpr auto ISEL_MULX_VGPR64q_VGPR64q_VGPR64q [[gnu::used]] =
MULX<R64W, R64>;
extern "C" constexpr auto ISEL_MULX_VGPR64q_VGPR64q_MEMq [[gnu::used]] =
MULX<R64W, M64>;

extern "C" constexpr auto ISEL_MULPS_XMMps_MEMps [[gnu::used]] =
MULPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_MULPS_XMMps_XMMps [[gnu::used]] =
MULPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMULPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
MULPS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VMULPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
MULPS<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VMULPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
MULPS<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VMULPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
MULPS<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_MULPD_XMMpd_MEMpd [[gnu::used]] =
MULPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_MULPD_XMMpd_XMMpd [[gnu::used]] =
MULPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMULPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
MULPD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VMULPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
MULPD<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VMULPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
MULPD<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VMULPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
MULPD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_MULSS_XMMss_MEMss [[gnu::used]] =
MULSS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_MULSS_XMMss_XMMss [[gnu::used]] =
MULSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMULSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
MULSS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VMULSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
MULSS<VV128W, VV128, VV128>;

extern "C" constexpr auto ISEL_MULSD_XMMsd_MEMsd [[gnu::used]] =
MULSD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_MULSD_XMMsd_XMMsd [[gnu::used]] =
MULSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMULSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
MULSD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VMULSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
MULSD<VV128W, VV128, VV128>;

namespace {
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.byte.low));
auto lhs_high = ZExt(_Read(memory, state.gpr.rax.byte.high));
auto rhs = ZExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = UOr(UShl(lhs_high, shift), lhs_low);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = UDiv(lhs, rhs);
auto rem = URem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != ZExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(quot_trunc)),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(quot_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(
typename BaseType<decltype(state.gpr.rax.byte.high)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.high)>(rem_trunc)),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.byte.high,
(ZExtTo<decltype(state.gpr.rax.byte.high)>(rem_trunc)));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVdxax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.word));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.word));
auto rhs = ZExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = UOr(UShl(lhs_high, shift), lhs_low);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = UDiv(lhs, rhs);
auto rem = URem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != ZExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(quot_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(quot_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.word)>(rem_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.word,
(ZExtTo<decltype(state.gpr.rdx.word)>(rem_trunc)));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVedxeax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.dword));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.dword));
auto rhs = ZExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = UOr(UShl(lhs_high, shift), lhs_low);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = UDiv(lhs, rhs);
auto rem = URem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != ZExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(quot_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(quot_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(rem_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(rem_trunc)));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVrdxrax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.qword));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.qword));
auto rhs = ZExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = UOr(UShl(lhs_high, shift), lhs_low);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = UDiv(lhs, rhs);
auto rem = URem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != ZExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(quot_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(quot_trunc)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(rem_trunc)),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(rem_trunc)));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IDIVax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.byte.low));
auto lhs_high = ZExt(_Read(memory, state.gpr.rax.byte.high));
auto rhs = SExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = Signed(UOr(UShl(lhs_high, shift), lhs_low));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = SDiv(lhs, rhs);
auto rem = SRem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != SExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(
Unsigned(quot_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(Unsigned(quot_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(
typename BaseType<decltype(state.gpr.rax.byte.high)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.high)>(
Unsigned(rem_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.byte.high,
(ZExtTo<decltype(state.gpr.rax.byte.high)>(Unsigned(rem_trunc))));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IDIVdxax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.word));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.word));
auto rhs = SExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = Signed(UOr(UShl(lhs_high, shift), lhs_low));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = SDiv(lhs, rhs);
auto rem = SRem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != SExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(
Unsigned(quot_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(Unsigned(quot_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.word)>(
Unsigned(rem_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.word,
(ZExtTo<decltype(state.gpr.rdx.word)>(Unsigned(rem_trunc))));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IDIVedxeax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.dword));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.dword));
auto rhs = SExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = Signed(UOr(UShl(lhs_high, shift), lhs_low));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = SDiv(lhs, rhs);
auto rem = SRem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != SExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
Unsigned(quot_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(quot_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Unsigned(rem_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(Unsigned(rem_trunc))));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}
template <typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IDIVrdxrax(Memory *memory, State &state, S3 src3, PC next_pc) {
auto lhs_low = ZExt(_Read(memory, state.gpr.rax.qword));
auto lhs_high = ZExt(_Read(memory, state.gpr.rdx.qword));
auto rhs = SExt(_Read(memory, src3));
auto shift = ZExt(BitSizeOf(src3));
auto lhs = Signed(UOr(UShl(lhs_high, shift), lhs_low));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
if (IsZero(rhs)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
auto quot = SDiv(lhs, rhs);
auto rem = SRem(lhs, rhs);
auto quot_trunc = Trunc(quot);
auto rem_trunc = Trunc(rem);
if (quot != SExt(quot_trunc)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
} else {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
Unsigned(quot_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(Unsigned(quot_trunc))));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Unsigned(rem_trunc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(Unsigned(rem_trunc))));
} while (false);
} while (false);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
return memory;
}
}
}

} // namespace

extern "C" constexpr auto ISEL_IDIV_MEMb [[gnu::used]] = IDIVax<M8>;
extern "C" constexpr auto ISEL_IDIV_GPR8 [[gnu::used]] = IDIVax<R8>;
extern "C" constexpr auto ISEL_IDIV_MEMv_8 [[gnu::used]] = IDIVax<M8>;
extern "C" constexpr auto ISEL_IDIV_MEMv_16 [[gnu::used]] = IDIVdxax<M16>;
extern "C" constexpr auto ISEL_IDIV_MEMv_32 [[gnu::used]] = IDIVedxeax<M32>;
extern "C" constexpr auto ISEL_IDIV_MEMv_64 [[gnu::used]] = IDIVrdxrax<M64>;
extern "C" constexpr auto ISEL_IDIV_GPRv_8 [[gnu::used]] = IDIVax<R8>;
extern "C" constexpr auto ISEL_IDIV_GPRv_16 [[gnu::used]] = IDIVdxax<R16>;
extern "C" constexpr auto ISEL_IDIV_GPRv_32 [[gnu::used]] = IDIVedxeax<R32>;
extern "C" constexpr auto ISEL_IDIV_GPRv_64 [[gnu::used]] = IDIVrdxrax<R64>;

extern "C" constexpr auto ISEL_DIV_MEMb [[gnu::used]] = DIVax<M8>;
extern "C" constexpr auto ISEL_DIV_GPR8 [[gnu::used]] = DIVax<R8>;
extern "C" constexpr auto ISEL_DIV_MEMv_8 [[gnu::used]] = DIVax<M8>;
extern "C" constexpr auto ISEL_DIV_MEMv_16 [[gnu::used]] = DIVdxax<M16>;
extern "C" constexpr auto ISEL_DIV_MEMv_32 [[gnu::used]] = DIVedxeax<M32>;
extern "C" constexpr auto ISEL_DIV_MEMv_64 [[gnu::used]] = DIVrdxrax<M64>;
extern "C" constexpr auto ISEL_DIV_GPRv_8 [[gnu::used]] = DIVax<R8>;
extern "C" constexpr auto ISEL_DIV_GPRv_16 [[gnu::used]] = DIVdxax<R16>;
extern "C" constexpr auto ISEL_DIV_GPRv_32 [[gnu::used]] = DIVedxeax<R32>;
extern "C" constexpr auto ISEL_DIV_GPRv_64 [[gnu::used]] = DIVrdxrax<R64>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_FWriteV32(memory, dst,
(FDivV32(_FReadV32(memory, src1), _FReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVPD(Memory *memory, State &state, D dst, const S1 src1, const S2 src2) {
do {
memory =
_FWriteV64(memory, dst,
(FDivV64(_FReadV64(memory, src1), _FReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV32(memory, src1);
auto rhs = _FReadV32(memory, src2);
auto quot = FDiv(FExtractV32(lhs, 0), FExtractV32(rhs, 0));
auto res = FInsertV32(lhs, 0, quot);
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DIVSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _FReadV64(memory, src1);
auto rhs = _FReadV64(memory, src2);
auto quot = FDiv(FExtractV64(lhs, 0), FExtractV64(rhs, 0));
auto res = FInsertV64(lhs, 0, quot);
do {
memory = _FWriteV64(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_DIVPS_XMMps_MEMps [[gnu::used]] =
DIVPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_DIVPS_XMMps_XMMps [[gnu::used]] =
DIVPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VDIVPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
DIVPS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VDIVPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
DIVPS<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VDIVPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
DIVPS<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VDIVPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
DIVPS<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_DIVPD_XMMpd_MEMpd [[gnu::used]] =
DIVPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_DIVPD_XMMpd_XMMpd [[gnu::used]] =
DIVPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VDIVPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
DIVPD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VDIVPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
DIVPD<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VDIVPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
DIVPD<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VDIVPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
DIVPD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_DIVSS_XMMss_MEMss [[gnu::used]] =
DIVSS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_DIVSS_XMMss_XMMss [[gnu::used]] =
DIVSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VDIVSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
DIVSS<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VDIVSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
DIVSS<VV128W, VV128, VV128>;

extern "C" constexpr auto ISEL_DIVSD_XMMsd_MEMsd [[gnu::used]] =
DIVSD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_DIVSD_XMMsd_XMMsd [[gnu::used]] =
DIVSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VDIVSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
DIVSD<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VDIVSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
DIVSD<VV128W, VV128, VV128>;

namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
INC(Memory *memory, State &state, D dst, S1 src) {
auto lhs = _Read(memory, src);
decltype(lhs) rhs = 1;
auto sum = UAdd(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(sum)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(sum)));
} while (false);
} while (false);
WriteFlagsIncDec<tag_add>(state, lhs, rhs, sum);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DEC(Memory *memory, State &state, D dst, S1 src) {
auto lhs = _Read(memory, src);
auto_t(S1) rhs = 1;
auto sum = USub(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(sum)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(sum)));
} while (false);
} while (false);
WriteFlagsIncDec<tag_sub>(state, lhs, rhs, sum);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
NEG(Memory *memory, State &state, D dst, S1 src) {
auto_t(S1) lhs = 0;
auto rhs = _Read(memory, src);
auto neg = UNeg(rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(neg)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(neg)));
} while (false);
} while (false);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, neg);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_INC_MEMb [[gnu::used]] = INC<M8W, M8>;
extern "C" constexpr auto ISEL_INC_GPR8 [[gnu::used]] = INC<R8W, R8>;
extern "C" constexpr auto ISEL_INC_MEMv_8 [[gnu::used]] = INC<M8W, M8>;
extern "C" constexpr auto ISEL_INC_MEMv_16 [[gnu::used]] = INC<M16W, M16>;
extern "C" constexpr auto ISEL_INC_MEMv_32 [[gnu::used]] = INC<M32W, M32>;
extern "C" constexpr auto ISEL_INC_MEMv_64 [[gnu::used]] = INC<M64W, M64>;
extern "C" constexpr auto ISEL_INC_GPRv_FFr0_8 [[gnu::used]] = INC<R8W, R8>;
extern "C" constexpr auto ISEL_INC_GPRv_FFr0_16 [[gnu::used]] = INC<R16W, R16>;
extern "C" constexpr auto ISEL_INC_GPRv_FFr0_32 [[gnu::used]] = INC<R32W, R32>;
extern "C" constexpr auto ISEL_INC_GPRv_FFr0_64 [[gnu::used]] = INC<R64W, R64>;
extern "C" constexpr auto ISEL_INC_GPRv_40_8 [[gnu::used]] = INC<R8W, R8>;
extern "C" constexpr auto ISEL_INC_GPRv_40_16 [[gnu::used]] = INC<R16W, R16>;
extern "C" constexpr auto ISEL_INC_GPRv_40_32 [[gnu::used]] = INC<R32W, R32>;
extern "C" constexpr auto ISEL_INC_GPRv_40_64 [[gnu::used]] = INC<R64W, R64>;

extern "C" constexpr auto ISEL_DEC_MEMb [[gnu::used]] = DEC<M8W, M8>;
extern "C" constexpr auto ISEL_DEC_GPR8 [[gnu::used]] = DEC<R8W, R8>;
extern "C" constexpr auto ISEL_DEC_MEMv_8 [[gnu::used]] = DEC<M8W, M8>;
extern "C" constexpr auto ISEL_DEC_MEMv_16 [[gnu::used]] = DEC<M16W, M16>;
extern "C" constexpr auto ISEL_DEC_MEMv_32 [[gnu::used]] = DEC<M32W, M32>;
extern "C" constexpr auto ISEL_DEC_MEMv_64 [[gnu::used]] = DEC<M64W, M64>;
extern "C" constexpr auto ISEL_DEC_GPRv_FFr1_8 [[gnu::used]] = DEC<R8W, R8>;
extern "C" constexpr auto ISEL_DEC_GPRv_FFr1_16 [[gnu::used]] = DEC<R16W, R16>;
extern "C" constexpr auto ISEL_DEC_GPRv_FFr1_32 [[gnu::used]] = DEC<R32W, R32>;
extern "C" constexpr auto ISEL_DEC_GPRv_FFr1_64 [[gnu::used]] = DEC<R64W, R64>;
extern "C" constexpr auto ISEL_DEC_GPRv_48_8 [[gnu::used]] = DEC<R8W, R8>;
extern "C" constexpr auto ISEL_DEC_GPRv_48_16 [[gnu::used]] = DEC<R16W, R16>;
extern "C" constexpr auto ISEL_DEC_GPRv_48_32 [[gnu::used]] = DEC<R32W, R32>;
extern "C" constexpr auto ISEL_DEC_GPRv_48_64 [[gnu::used]] = DEC<R64W, R64>;

extern "C" constexpr auto ISEL_NEG_MEMb [[gnu::used]] = NEG<M8W, M8>;
extern "C" constexpr auto ISEL_NEG_GPR8 [[gnu::used]] = NEG<R8W, R8>;
extern "C" constexpr auto ISEL_NEG_MEMv_8 [[gnu::used]] = NEG<M8W, M8>;
extern "C" constexpr auto ISEL_NEG_MEMv_16 [[gnu::used]] = NEG<M16W, M16>;
extern "C" constexpr auto ISEL_NEG_MEMv_32 [[gnu::used]] = NEG<M32W, M32>;
extern "C" constexpr auto ISEL_NEG_MEMv_64 [[gnu::used]] = NEG<M64W, M64>;
extern "C" constexpr auto ISEL_NEG_GPRv_8 [[gnu::used]] = NEG<R8W, R8>;
extern "C" constexpr auto ISEL_NEG_GPRv_16 [[gnu::used]] = NEG<R16W, R16>;
extern "C" constexpr auto ISEL_NEG_GPRv_32 [[gnu::used]] = NEG<R32W, R32>;
extern "C" constexpr auto ISEL_NEG_GPRv_64 [[gnu::used]] = NEG<R64W, R64>;

namespace {

template <typename TagT, typename T>
[[gnu::always_inline]] inline static bool CarryFlag(T a, T b, T ab, T c,
T abc) {
static_assert(std::is_unsigned<T>::value,
"Invalid specialization of `CarryFlag` for addition.");
return Carry<TagT>::Flag(a, b, ab) || Carry<TagT>::Flag(ab, c, abc);
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ADC(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto carry = ZExtTo<S1>(Unsigned(_Read(memory, state.aflag.cf)));
auto sum = UAdd(lhs, rhs);
auto res = UAdd(sum, carry);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(CarryFlag<tag_add>(lhs, rhs, sum, carry, res)),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(CarryFlag<tag_add>(lhs, rhs, sum, carry, res)));
} while (false);
WriteFlagsIncDec<tag_add>(state, lhs, rhs, res);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SBB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto borrow = ZExtTo<S1>(Unsigned(_Read(memory, state.aflag.cf)));
auto sum = USub(lhs, rhs);
auto res = USub(sum, borrow);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(CarryFlag<tag_sub>(lhs, rhs, sum, borrow, res)),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(CarryFlag<tag_sub>(lhs, rhs, sum, borrow, res)));
} while (false);
WriteFlagsIncDec<tag_sub>(state, lhs, rhs, res);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SBB_MEMb_IMMb_80r3 [[gnu::used]] =
SBB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SBB_GPR8_IMMb_80r3 [[gnu::used]] =
SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMz_8 [[gnu::used]] = SBB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMz_16 [[gnu::used]] =
SBB<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMz_32 [[gnu::used]] =
SBB<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMz_64 [[gnu::used]] =
SBB<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMz_8 [[gnu::used]] = SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMz_16 [[gnu::used]] =
SBB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMz_32 [[gnu::used]] =
SBB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMz_64 [[gnu::used]] =
SBB<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SBB_MEMb_IMMb_82r3 [[gnu::used]] =
SBB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SBB_GPR8_IMMb_82r3 [[gnu::used]] =
SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMb_8 [[gnu::used]] = SBB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMb_16 [[gnu::used]] =
SBB<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMb_32 [[gnu::used]] =
SBB<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SBB_MEMv_IMMb_64 [[gnu::used]] =
SBB<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMb_8 [[gnu::used]] = SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMb_16 [[gnu::used]] =
SBB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMb_32 [[gnu::used]] =
SBB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SBB_GPRv_IMMb_64 [[gnu::used]] =
SBB<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SBB_MEMb_GPR8 [[gnu::used]] = SBB<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SBB_GPR8_GPR8_18 [[gnu::used]] =
SBB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SBB_MEMv_GPRv_8 [[gnu::used]] = SBB<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SBB_MEMv_GPRv_16 [[gnu::used]] =
SBB<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SBB_MEMv_GPRv_32 [[gnu::used]] =
SBB<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SBB_MEMv_GPRv_64 [[gnu::used]] =
SBB<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_19_8 [[gnu::used]] =
SBB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_19_16 [[gnu::used]] =
SBB<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_19_32 [[gnu::used]] =
SBB<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_19_64 [[gnu::used]] =
SBB<R64W, R64, R64>;
extern "C" constexpr auto ISEL_SBB_GPR8_GPR8_1A [[gnu::used]] =
SBB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SBB_GPR8_MEMb [[gnu::used]] = SBB<R8W, R8, M8>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_1B_8 [[gnu::used]] =
SBB<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_1B_16 [[gnu::used]] =
SBB<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_1B_32 [[gnu::used]] =
SBB<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SBB_GPRv_GPRv_1B_64 [[gnu::used]] =
SBB<R64W, R64, R64>;
extern "C" constexpr auto ISEL_SBB_GPRv_MEMv_8 [[gnu::used]] = SBB<R8W, R8, M8>;
extern "C" constexpr auto ISEL_SBB_GPRv_MEMv_16 [[gnu::used]] =
SBB<R16W, R16, M16>;
extern "C" constexpr auto ISEL_SBB_GPRv_MEMv_32 [[gnu::used]] =
SBB<R32W, R32, M32>;
extern "C" constexpr auto ISEL_SBB_GPRv_MEMv_64 [[gnu::used]] =
SBB<R64W, R64, M64>;
extern "C" constexpr auto ISEL_SBB_AL_IMMb [[gnu::used]] = SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_OrAX_IMMz_8 [[gnu::used]] = SBB<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SBB_OrAX_IMMz_16 [[gnu::used]] =
SBB<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SBB_OrAX_IMMz_32 [[gnu::used]] =
SBB<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SBB_OrAX_IMMz_64 [[gnu::used]] =
SBB<R64W, R64, I64>;

extern "C" constexpr auto ISEL_ADC_MEMb_IMMb_80r2 [[gnu::used]] =
ADC<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADC_GPR8_IMMb_80r2 [[gnu::used]] =
ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMz_8 [[gnu::used]] = ADC<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMz_16 [[gnu::used]] =
ADC<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMz_32 [[gnu::used]] =
ADC<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMz_64 [[gnu::used]] =
ADC<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMz_8 [[gnu::used]] = ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMz_16 [[gnu::used]] =
ADC<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMz_32 [[gnu::used]] =
ADC<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMz_64 [[gnu::used]] =
ADC<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ADC_MEMb_IMMb_82r2 [[gnu::used]] =
ADC<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADC_GPR8_IMMb_82r2 [[gnu::used]] =
ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMb_8 [[gnu::used]] = ADC<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMb_16 [[gnu::used]] =
ADC<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMb_32 [[gnu::used]] =
ADC<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ADC_MEMv_IMMb_64 [[gnu::used]] =
ADC<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMb_8 [[gnu::used]] = ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMb_16 [[gnu::used]] =
ADC<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMb_32 [[gnu::used]] =
ADC<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADC_GPRv_IMMb_64 [[gnu::used]] =
ADC<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ADC_MEMb_GPR8 [[gnu::used]] = ADC<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ADC_GPR8_GPR8_10 [[gnu::used]] =
ADC<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADC_MEMv_GPRv_8 [[gnu::used]] = ADC<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ADC_MEMv_GPRv_16 [[gnu::used]] =
ADC<M16W, M16, R16>;
extern "C" constexpr auto ISEL_ADC_MEMv_GPRv_32 [[gnu::used]] =
ADC<M32W, M32, R32>;
extern "C" constexpr auto ISEL_ADC_MEMv_GPRv_64 [[gnu::used]] =
ADC<M64W, M64, R64>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_11_8 [[gnu::used]] =
ADC<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_11_16 [[gnu::used]] =
ADC<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_11_32 [[gnu::used]] =
ADC<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_11_64 [[gnu::used]] =
ADC<R64W, R64, R64>;
extern "C" constexpr auto ISEL_ADC_GPR8_MEMb [[gnu::used]] = ADC<R8W, R8, M8>;
extern "C" constexpr auto ISEL_ADC_GPR8_GPR8_12 [[gnu::used]] =
ADC<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADC_GPRv_MEMv_8 [[gnu::used]] = ADC<R8W, R8, M8>;
extern "C" constexpr auto ISEL_ADC_GPRv_MEMv_16 [[gnu::used]] =
ADC<R16W, R16, M16>;
extern "C" constexpr auto ISEL_ADC_GPRv_MEMv_32 [[gnu::used]] =
ADC<R32W, R32, M32>;
extern "C" constexpr auto ISEL_ADC_GPRv_MEMv_64 [[gnu::used]] =
ADC<R64W, R64, M64>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_13_8 [[gnu::used]] =
ADC<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_13_16 [[gnu::used]] =
ADC<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_13_32 [[gnu::used]] =
ADC<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ADC_GPRv_GPRv_13_64 [[gnu::used]] =
ADC<R64W, R64, R64>;
extern "C" constexpr auto ISEL_ADC_AL_IMMb [[gnu::used]] = ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_OrAX_IMMz_8 [[gnu::used]] = ADC<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ADC_OrAX_IMMz_16 [[gnu::used]] =
ADC<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ADC_OrAX_IMMz_32 [[gnu::used]] =
ADC<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ADC_OrAX_IMMz_64 [[gnu::used]] =
ADC<R64W, R64, I64>;
namespace {

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNLE(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BAnd(BNot(state.aflag.zf),
BXnor(state.aflag.sf, state.aflag.of))),
"Bad write!");
memory = _Write(
memory, dst,
(BAnd(BNot(state.aflag.zf), BXnor(state.aflag.sf, state.aflag.of))));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNS(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BNot(state.aflag.sf)),
"Bad write!");
memory = _Write(memory, dst, (BNot(state.aflag.sf)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETL(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BXor(state.aflag.sf, state.aflag.of)),
"Bad write!");
memory = _Write(memory, dst, (BXor(state.aflag.sf, state.aflag.of)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNP(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BNot(state.aflag.pf)),
"Bad write!");
memory = _Write(memory, dst, (BNot(state.aflag.pf)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNZ(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BNot(state.aflag.zf)),
"Bad write!");
memory = _Write(memory, dst, (BNot(state.aflag.zf)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNB(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BNot(state.aflag.cf)),
"Bad write!");
memory = _Write(memory, dst, (BNot(state.aflag.cf)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNO(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BNot(state.aflag.of)),
"Bad write!");
memory = _Write(memory, dst, (BNot(state.aflag.of)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNL(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BXnor(state.aflag.sf, state.aflag.of)),
"Bad write!");
memory = _Write(memory, dst, (BXnor(state.aflag.sf, state.aflag.of)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETNBE(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BAnd(BNot(state.aflag.cf), BNot(state.aflag.zf))),
"Bad write!");
memory =
_Write(memory, dst, (BAnd(BNot(state.aflag.cf), BNot(state.aflag.zf))));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETBE(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BOr(state.aflag.cf, state.aflag.zf)),
"Bad write!");
memory = _Write(memory, dst, (BOr(state.aflag.cf, state.aflag.zf)));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETZ(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(state.aflag.zf),
"Bad write!");
memory = _Write(memory, dst, (state.aflag.zf));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETP(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(state.aflag.pf),
"Bad write!");
memory = _Write(memory, dst, (state.aflag.pf));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETS(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(state.aflag.sf),
"Bad write!");
memory = _Write(memory, dst, (state.aflag.sf));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETO(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(state.aflag.of),
"Bad write!");
memory = _Write(memory, dst, (state.aflag.of));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETB(Memory *memory, State &state, D dst) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(state.aflag.cf),
"Bad write!");
memory = _Write(memory, dst, (state.aflag.cf));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SETLE(Memory *memory, State &state, D dst) {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(BOr(state.aflag.zf, BXor(state.aflag.sf, state.aflag.of))),
"Bad write!");
memory =
_Write(memory, dst,
(BOr(state.aflag.zf, BXor(state.aflag.sf, state.aflag.of))));
} while (false);
return memory;
}

} // namespace
extern "C" constexpr auto ISEL_SETB_MEMb [[gnu::used]] = SETB<M8W>;
extern "C" constexpr auto ISEL_SETB_GPR8 [[gnu::used]] = SETB<R8W>;
extern "C" constexpr auto ISEL_SETL_MEMb [[gnu::used]] = SETL<M8W>;
extern "C" constexpr auto ISEL_SETL_GPR8 [[gnu::used]] = SETL<R8W>;
extern "C" constexpr auto ISEL_SETO_MEMb [[gnu::used]] = SETO<M8W>;
extern "C" constexpr auto ISEL_SETO_GPR8 [[gnu::used]] = SETO<R8W>;
extern "C" constexpr auto ISEL_SETP_MEMb [[gnu::used]] = SETP<M8W>;
extern "C" constexpr auto ISEL_SETP_GPR8 [[gnu::used]] = SETP<R8W>;
extern "C" constexpr auto ISEL_SETZ_MEMb [[gnu::used]] = SETZ<M8W>;
extern "C" constexpr auto ISEL_SETZ_GPR8 [[gnu::used]] = SETZ<R8W>;
extern "C" constexpr auto ISEL_SETS_MEMb [[gnu::used]] = SETS<M8W>;
extern "C" constexpr auto ISEL_SETS_GPR8 [[gnu::used]] = SETS<R8W>;
extern "C" constexpr auto ISEL_SETNO_MEMb [[gnu::used]] = SETNO<M8W>;
extern "C" constexpr auto ISEL_SETNO_GPR8 [[gnu::used]] = SETNO<R8W>;
extern "C" constexpr auto ISEL_SETNL_MEMb [[gnu::used]] = SETNL<M8W>;
extern "C" constexpr auto ISEL_SETNL_GPR8 [[gnu::used]] = SETNL<R8W>;
extern "C" constexpr auto ISEL_SETNB_MEMb [[gnu::used]] = SETNB<M8W>;
extern "C" constexpr auto ISEL_SETNB_GPR8 [[gnu::used]] = SETNB<R8W>;
extern "C" constexpr auto ISEL_SETNZ_MEMb [[gnu::used]] = SETNZ<M8W>;
extern "C" constexpr auto ISEL_SETNZ_GPR8 [[gnu::used]] = SETNZ<R8W>;
extern "C" constexpr auto ISEL_SETNS_MEMb [[gnu::used]] = SETNS<M8W>;
extern "C" constexpr auto ISEL_SETNS_GPR8 [[gnu::used]] = SETNS<R8W>;
extern "C" constexpr auto ISEL_SETNP_MEMb [[gnu::used]] = SETNP<M8W>;
extern "C" constexpr auto ISEL_SETNP_GPR8 [[gnu::used]] = SETNP<R8W>;
extern "C" constexpr auto ISEL_SETNBE_MEMb [[gnu::used]] = SETNBE<M8W>;
extern "C" constexpr auto ISEL_SETNBE_GPR8 [[gnu::used]] = SETNBE<R8W>;
extern "C" constexpr auto ISEL_SETLE_MEMb [[gnu::used]] = SETLE<M8W>;
extern "C" constexpr auto ISEL_SETLE_GPR8 [[gnu::used]] = SETLE<R8W>;
extern "C" constexpr auto ISEL_SETNLE_MEMb [[gnu::used]] = SETNLE<M8W>;
extern "C" constexpr auto ISEL_SETNLE_GPR8 [[gnu::used]] = SETNLE<R8W>;
extern "C" constexpr auto ISEL_SETBE_MEMb [[gnu::used]] = SETBE<M8W>;
extern "C" constexpr auto ISEL_SETBE_GPR8 [[gnu::used]] = SETBE<R8W>;

namespace {
template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTreg(Memory *memory, State &state, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTmem(Memory *memory, State &state, S1 src1, S2 src2) {
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
auto index = UDiv(bit, BitSizeOf(src1));
auto val = _Read(memory, GetElementPtr(src1, index));
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTSreg(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(val)));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(UOr(val, bit_mask))),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(UOr(val, bit_mask))));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTSmem(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
auto index = UDiv(bit, BitSizeOf(src1));
auto val = _Read(memory, GetElementPtr(src1, index));
do {
static_assert(
sizeof(typename BaseType<decltype(GetElementPtr(dst, index))>::BT) ==
sizeof(UOr(val, bit_mask)),
"Bad write!");
memory = _Write(memory, GetElementPtr(dst, index), (UOr(val, bit_mask)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTRreg(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(UAnd(val, UNot(bit_mask)))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(UAnd(val, UNot(bit_mask)))));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTRmem(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
auto index = UDiv(bit, BitSizeOf(src1));
auto val = _Read(memory, GetElementPtr(src1, index));
do {
static_assert(
sizeof(typename BaseType<decltype(GetElementPtr(dst, index))>::BT) ==
sizeof(UAnd(val, UNot(bit_mask))),
"Bad write!");
memory =
_Write(memory, GetElementPtr(dst, index), (UAnd(val, UNot(bit_mask))));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTCreg(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(val)));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(UXor(val, bit_mask))),
"Bad write!");
memory =
_Write(memory, dst, (ZExtTo<decltype(dst)>(UXor(val, bit_mask))));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BTCmem(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto bit = ZExtTo<S1>(_Read(memory, src2));
auto bit_mask = UShl(Literal<S1>(1), URem(bit, BitSizeOf(src1)));
auto index = UDiv(bit, BitSizeOf(src1));
auto val = _Read(memory, GetElementPtr(src1, index));
do {
static_assert(
sizeof(typename BaseType<decltype(GetElementPtr(dst, index))>::BT) ==
sizeof(UXor(val, bit_mask)),
"Bad write!");
memory = _Write(memory, GetElementPtr(dst, index), (UXor(val, bit_mask)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(UCmpNeq(UAnd(val, bit_mask), Literal<S1>(0))));
} while (false);
do {
do {
state.aflag.of = __remill_undefined_8();
} while (false);
do {
state.aflag.sf = __remill_undefined_8();
} while (false);
do {
state.aflag.zf = __remill_undefined_8();
} while (false);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
do {
state.aflag.pf = __remill_undefined_8();
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_BT_MEMv_IMMb_8 [[gnu::used]] = BTmem<M8, I8>;
extern "C" constexpr auto ISEL_BT_MEMv_IMMb_16 [[gnu::used]] = BTmem<M16, I16>;
extern "C" constexpr auto ISEL_BT_MEMv_IMMb_32 [[gnu::used]] = BTmem<M32, I32>;
extern "C" constexpr auto ISEL_BT_MEMv_IMMb_64 [[gnu::used]] = BTmem<M64, I64>;
extern "C" constexpr auto ISEL_BT_GPRv_IMMb_8 [[gnu::used]] = BTreg<R8, I8>;
extern "C" constexpr auto ISEL_BT_GPRv_IMMb_16 [[gnu::used]] = BTreg<R16, I16>;
extern "C" constexpr auto ISEL_BT_GPRv_IMMb_32 [[gnu::used]] = BTreg<R32, I32>;
extern "C" constexpr auto ISEL_BT_GPRv_IMMb_64 [[gnu::used]] = BTreg<R64, I64>;
extern "C" constexpr auto ISEL_BT_MEMv_GPRv_8 [[gnu::used]] = BTmem<M8, R8>;
extern "C" constexpr auto ISEL_BT_MEMv_GPRv_16 [[gnu::used]] = BTmem<M16, R16>;
extern "C" constexpr auto ISEL_BT_MEMv_GPRv_32 [[gnu::used]] = BTmem<M32, R32>;
extern "C" constexpr auto ISEL_BT_MEMv_GPRv_64 [[gnu::used]] = BTmem<M64, R64>;
extern "C" constexpr auto ISEL_BT_GPRv_GPRv_8 [[gnu::used]] = BTreg<R8, R8>;
extern "C" constexpr auto ISEL_BT_GPRv_GPRv_16 [[gnu::used]] = BTreg<R16, R16>;
extern "C" constexpr auto ISEL_BT_GPRv_GPRv_32 [[gnu::used]] = BTreg<R32, R32>;
extern "C" constexpr auto ISEL_BT_GPRv_GPRv_64 [[gnu::used]] = BTreg<R64, R64>;

extern "C" constexpr auto ISEL_BTS_MEMv_IMMb_8 [[gnu::used]] =
BTSmem<M8W, M8, I8>;
extern "C" constexpr auto ISEL_BTS_MEMv_IMMb_16 [[gnu::used]] =
BTSmem<M16W, M16, I16>;
extern "C" constexpr auto ISEL_BTS_MEMv_IMMb_32 [[gnu::used]] =
BTSmem<M32W, M32, I32>;
extern "C" constexpr auto ISEL_BTS_MEMv_IMMb_64 [[gnu::used]] =
BTSmem<M64W, M64, I64>;
extern "C" constexpr auto ISEL_BTS_GPRv_IMMb_8 [[gnu::used]] =
BTSreg<R8W, R8, I8>;
extern "C" constexpr auto ISEL_BTS_GPRv_IMMb_16 [[gnu::used]] =
BTSreg<R16W, R16, I16>;
extern "C" constexpr auto ISEL_BTS_GPRv_IMMb_32 [[gnu::used]] =
BTSreg<R32W, R32, I32>;
extern "C" constexpr auto ISEL_BTS_GPRv_IMMb_64 [[gnu::used]] =
BTSreg<R64W, R64, I64>;
extern "C" constexpr auto ISEL_BTS_MEMv_GPRv_8 [[gnu::used]] =
BTSmem<M8W, M8, R8>;
extern "C" constexpr auto ISEL_BTS_MEMv_GPRv_16 [[gnu::used]] =
BTSmem<M16W, M16, R16>;
extern "C" constexpr auto ISEL_BTS_MEMv_GPRv_32 [[gnu::used]] =
BTSmem<M32W, M32, R32>;
extern "C" constexpr auto ISEL_BTS_MEMv_GPRv_64 [[gnu::used]] =
BTSmem<M64W, M64, R64>;
extern "C" constexpr auto ISEL_BTS_GPRv_GPRv_8 [[gnu::used]] =
BTSreg<R8W, R8, R8>;
extern "C" constexpr auto ISEL_BTS_GPRv_GPRv_16 [[gnu::used]] =
BTSreg<R16W, R16, R16>;
extern "C" constexpr auto ISEL_BTS_GPRv_GPRv_32 [[gnu::used]] =
BTSreg<R32W, R32, R32>;
extern "C" constexpr auto ISEL_BTS_GPRv_GPRv_64 [[gnu::used]] =
BTSreg<R64W, R64, R64>;

extern "C" constexpr auto ISEL_BTR_MEMv_IMMb_8 [[gnu::used]] =
BTRmem<M8W, M8, I8>;
extern "C" constexpr auto ISEL_BTR_MEMv_IMMb_16 [[gnu::used]] =
BTRmem<M16W, M16, I16>;
extern "C" constexpr auto ISEL_BTR_MEMv_IMMb_32 [[gnu::used]] =
BTRmem<M32W, M32, I32>;
extern "C" constexpr auto ISEL_BTR_MEMv_IMMb_64 [[gnu::used]] =
BTRmem<M64W, M64, I64>;
extern "C" constexpr auto ISEL_BTR_GPRv_IMMb_8 [[gnu::used]] =
BTRreg<R8W, R8, I8>;
extern "C" constexpr auto ISEL_BTR_GPRv_IMMb_16 [[gnu::used]] =
BTRreg<R16W, R16, I16>;
extern "C" constexpr auto ISEL_BTR_GPRv_IMMb_32 [[gnu::used]] =
BTRreg<R32W, R32, I32>;
extern "C" constexpr auto ISEL_BTR_GPRv_IMMb_64 [[gnu::used]] =
BTRreg<R64W, R64, I64>;
extern "C" constexpr auto ISEL_BTR_MEMv_GPRv_8 [[gnu::used]] =
BTRmem<M8W, M8, R8>;
extern "C" constexpr auto ISEL_BTR_MEMv_GPRv_16 [[gnu::used]] =
BTRmem<M16W, M16, R16>;
extern "C" constexpr auto ISEL_BTR_MEMv_GPRv_32 [[gnu::used]] =
BTRmem<M32W, M32, R32>;
extern "C" constexpr auto ISEL_BTR_MEMv_GPRv_64 [[gnu::used]] =
BTRmem<M64W, M64, R64>;
extern "C" constexpr auto ISEL_BTR_GPRv_GPRv_8 [[gnu::used]] =
BTRreg<R8W, R8, R8>;
extern "C" constexpr auto ISEL_BTR_GPRv_GPRv_16 [[gnu::used]] =
BTRreg<R16W, R16, R16>;
extern "C" constexpr auto ISEL_BTR_GPRv_GPRv_32 [[gnu::used]] =
BTRreg<R32W, R32, R32>;
extern "C" constexpr auto ISEL_BTR_GPRv_GPRv_64 [[gnu::used]] =
BTRreg<R64W, R64, R64>;

extern "C" constexpr auto ISEL_BTC_MEMv_IMMb_8 [[gnu::used]] =
BTCmem<M8W, M8, I8>;
extern "C" constexpr auto ISEL_BTC_MEMv_IMMb_16 [[gnu::used]] =
BTCmem<M16W, M16, I16>;
extern "C" constexpr auto ISEL_BTC_MEMv_IMMb_32 [[gnu::used]] =
BTCmem<M32W, M32, I32>;
extern "C" constexpr auto ISEL_BTC_MEMv_IMMb_64 [[gnu::used]] =
BTCmem<M64W, M64, I64>;
extern "C" constexpr auto ISEL_BTC_GPRv_IMMb_8 [[gnu::used]] =
BTCreg<R8W, R8, I8>;
extern "C" constexpr auto ISEL_BTC_GPRv_IMMb_16 [[gnu::used]] =
BTCreg<R16W, R16, I16>;
extern "C" constexpr auto ISEL_BTC_GPRv_IMMb_32 [[gnu::used]] =
BTCreg<R32W, R32, I32>;
extern "C" constexpr auto ISEL_BTC_GPRv_IMMb_64 [[gnu::used]] =
BTCreg<R64W, R64, I64>;
extern "C" constexpr auto ISEL_BTC_MEMv_GPRv_8 [[gnu::used]] =
BTCmem<M8W, M8, R8>;
extern "C" constexpr auto ISEL_BTC_MEMv_GPRv_16 [[gnu::used]] =
BTCmem<M16W, M16, R16>;
extern "C" constexpr auto ISEL_BTC_MEMv_GPRv_32 [[gnu::used]] =
BTCmem<M32W, M32, R32>;
extern "C" constexpr auto ISEL_BTC_MEMv_GPRv_64 [[gnu::used]] =
BTCmem<M64W, M64, R64>;
extern "C" constexpr auto ISEL_BTC_GPRv_GPRv_8 [[gnu::used]] =
BTCreg<R8W, R8, R8>;
extern "C" constexpr auto ISEL_BTC_GPRv_GPRv_16 [[gnu::used]] =
BTCreg<R16W, R16, R16>;
extern "C" constexpr auto ISEL_BTC_GPRv_GPRv_32 [[gnu::used]] =
BTCreg<R32W, R32, R32>;
extern "C" constexpr auto ISEL_BTC_GPRv_GPRv_64 [[gnu::used]] =
BTCreg<R64W, R64, R64>;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BSWAP_16(Memory *memory, State &state, R16W dst, R16 src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(static_cast<uint16_t>(0)),
"Bad write!");
memory = _Write(memory, dst, (static_cast<uint16_t>(0)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BSWAP_32(Memory *memory, State &state, R32W dst, R32 src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
__builtin_bswap32(_Read(memory, src)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(__builtin_bswap32(_Read(memory, src)))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BSWAP_64(Memory *memory, State &state, R64W dst, R64 src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(__builtin_bswap64(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (__builtin_bswap64(_Read(memory, src))));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
TZCNT(Memory *memory, State &state, D dst, S src) {
auto val = _Read(memory, src);
auto count = CountTrailingZeros(val);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(UCmpEq(UAnd(val, 1), 1)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (UCmpEq(UAnd(val, 1), 1)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(ZeroFlag(val)),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (ZeroFlag(val)));
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(state.aflag.cf, BitSizeOf(src), count))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(
Select(state.aflag.cf, BitSizeOf(src), count))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LZCNT(Memory *memory, State &state, D dst, S src) {
auto val = _Read(memory, src);
auto count = CountLeadingZeros(val);
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(SignFlag(val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (SignFlag(val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpEq(val, 0)),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (UCmpEq(val, 0)));
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(state.aflag.cf, BitSizeOf(src), count))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(
Select(state.aflag.cf, BitSizeOf(src), count))));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_BSWAP_GPRv_16 [[gnu::used]] = BSWAP_16;
extern "C" constexpr auto ISEL_BSWAP_GPRv_32 [[gnu::used]] = BSWAP_32;
extern "C" constexpr auto ISEL_BSWAP_GPRv_64 [[gnu::used]] = BSWAP_64;

extern "C" constexpr auto ISEL_TZCNT_GPRv_MEMv_8 [[gnu::used]] = TZCNT<R8W, M8>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_MEMv_16 [[gnu::used]] =
TZCNT<R16W, M16>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_MEMv_32 [[gnu::used]] =
TZCNT<R32W, M32>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_MEMv_64 [[gnu::used]] =
TZCNT<R64W, M64>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_GPRv_8 [[gnu::used]] = TZCNT<R8W, R8>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_GPRv_16 [[gnu::used]] =
TZCNT<R16W, R16>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_GPRv_32 [[gnu::used]] =
TZCNT<R32W, R32>;
extern "C" constexpr auto ISEL_TZCNT_GPRv_GPRv_64 [[gnu::used]] =
TZCNT<R64W, R64>;

extern "C" constexpr auto ISEL_LZCNT_GPRv_MEMv_8 [[gnu::used]] = LZCNT<R8W, M8>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_MEMv_16 [[gnu::used]] =
LZCNT<R16W, M16>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_MEMv_32 [[gnu::used]] =
LZCNT<R32W, M32>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_MEMv_64 [[gnu::used]] =
LZCNT<R64W, M64>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_GPRv_8 [[gnu::used]] = LZCNT<R8W, R8>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_GPRv_16 [[gnu::used]] =
LZCNT<R16W, R16>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_GPRv_32 [[gnu::used]] =
LZCNT<R32W, R32>;
extern "C" constexpr auto ISEL_LZCNT_GPRv_GPRv_64 [[gnu::used]] =
LZCNT<R64W, R64>;

namespace {
template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BSR(Memory *memory, State &state, D dst, S src) {
auto val = _Read(memory, src);
auto count = CountLeadingZeros(val);
auto index = USub(USub(BitSizeOf(src), count), Literal<S>(1));
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(val)));
} while (false);
auto index_ret = Select(state.aflag.zf, _Read(memory, dst), ZExtTo<D>(index));
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(index)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(index)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(index_ret),
"Bad write!");
memory = _Write(memory, dst, (index_ret));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
BSF(Memory *memory, State &state, D dst, S src) {
auto val = _Read(memory, src);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(val)));
} while (false);
auto index = Select(state.aflag.zf, _Read(memory, dst),
ZExtTo<D>(CountTrailingZeros(val)));
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(index)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(index)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(index),
"Bad write!");
memory = _Write(memory, dst, (index));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_BSR_GPRv_MEMv_8 [[gnu::used]] = BSR<R8W, M8>;
extern "C" constexpr auto ISEL_BSR_GPRv_MEMv_16 [[gnu::used]] = BSR<R16W, M16>;
extern "C" constexpr auto ISEL_BSR_GPRv_MEMv_32 [[gnu::used]] = BSR<R32W, M32>;
extern "C" constexpr auto ISEL_BSR_GPRv_MEMv_64 [[gnu::used]] = BSR<R64W, M64>;
extern "C" constexpr auto ISEL_BSR_GPRv_GPRv_8 [[gnu::used]] = BSR<R8W, R8>;
extern "C" constexpr auto ISEL_BSR_GPRv_GPRv_16 [[gnu::used]] = BSR<R16W, R16>;
extern "C" constexpr auto ISEL_BSR_GPRv_GPRv_32 [[gnu::used]] = BSR<R32W, R32>;
extern "C" constexpr auto ISEL_BSR_GPRv_GPRv_64 [[gnu::used]] = BSR<R64W, R64>;

extern "C" constexpr auto ISEL_BSF_GPRv_MEMv_8 [[gnu::used]] = BSF<R8W, M8>;
extern "C" constexpr auto ISEL_BSF_GPRv_MEMv_16 [[gnu::used]] = BSF<R16W, M16>;
extern "C" constexpr auto ISEL_BSF_GPRv_MEMv_32 [[gnu::used]] = BSF<R32W, M32>;
extern "C" constexpr auto ISEL_BSF_GPRv_MEMv_64 [[gnu::used]] = BSF<R64W, M64>;
extern "C" constexpr auto ISEL_BSF_GPRv_GPRv_8 [[gnu::used]] = BSF<R8W, R8>;
extern "C" constexpr auto ISEL_BSF_GPRv_GPRv_16 [[gnu::used]] = BSF<R16W, R16>;
extern "C" constexpr auto ISEL_BSF_GPRv_GPRv_32 [[gnu::used]] = BSF<R32W, R32>;
extern "C" constexpr auto ISEL_BSF_GPRv_GPRv_64 [[gnu::used]] = BSF<R64W, R64>;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CALL(Memory *memory, State &state, T target_pc, R64W pc_dst, PC return_pc,
R64W return_pc_dst) {
addr_t next_sp = USub(state.gpr.rsp.qword, static_cast<addr_t>(64UL / 8));
const auto new_pc = ZExtTo<addr_t>(_Read(memory, target_pc));
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<addr_t>(next_sp))>::BT) ==
sizeof(_Read(memory, return_pc)),
"Bad write!");
memory =
_Write(memory, WritePtr<addr_t>(next_sp), (_Read(memory, return_pc)));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(next_sp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (next_sp));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword, (new_pc));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, pc_dst, (new_pc));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(return_pc_dst)>::BT) ==
sizeof(_Read(memory, return_pc)),
"Bad write!");
memory = _Write(memory, return_pc_dst, (_Read(memory, return_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RET_IMM(Memory *memory, State &state, I16 bytes, R64W pc_dst) {
const auto new_pc = _Read(memory, ReadPtr<addr_t>(state.gpr.rsp.qword));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword, (new_pc));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, pc_dst, (new_pc));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(
UAdd(state.gpr.rsp.qword, ZExtTo<addr_t>(_Read(memory, bytes))),
static_cast<addr_t>(64UL / 8))),
"Bad write!");
memory = _Write(
memory, state.gpr.rsp.qword,
(UAdd(UAdd(state.gpr.rsp.qword, ZExtTo<addr_t>(_Read(memory, bytes))),
static_cast<addr_t>(64UL / 8))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RET(Memory *memory, State &state, R64W pc_dst) {
const auto new_pc = _Read(memory, ReadPtr<addr_t>(state.gpr.rsp.qword));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword, (new_pc));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(new_pc),
"Bad write!");
memory = _Write(memory, pc_dst, (new_pc));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(state.gpr.rsp.qword, static_cast<addr_t>(64UL / 8))),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword,
(UAdd(state.gpr.rsp.qword, static_cast<addr_t>(64UL / 8))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CALL_NEAR_RELBRd_64 [[gnu::used]] = CALL<PC>;
extern "C" constexpr auto ISEL_CALL_NEAR_RELBRz_64 [[gnu::used]] = CALL<PC>;

extern "C" constexpr auto ISEL_CALL_NEAR_MEMv_64 [[gnu::used]] = CALL<M64>;

extern "C" constexpr auto ISEL_CALL_NEAR_GPRv_64 [[gnu::used]] = CALL<R64>;

extern "C" constexpr auto ISEL_RET_NEAR_IMMw_64 [[gnu::used]] = RET_IMM;
extern "C" constexpr auto ISEL_RET_NEAR_64 [[gnu::used]] = RET;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IRETQ(Memory *memory, State &state, R64W pc_dst) {
auto new_rip = PopFromStack<uint64_t>(memory, state);
auto new_cs = static_cast<uint16_t>(PopFromStack<uint64_t>(memory, state));
auto temp_rflags = PopFromStack<uint64_t>(memory, state);
Flags f = {};
f.flat = temp_rflags;
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(new_rip),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword, (new_rip));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(new_rip),
"Bad write!");
memory = _Write(memory, pc_dst, (new_rip));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.seg.cs.flat)>::BT) ==
sizeof(new_cs),
"Bad write!");
memory = _Write(memory, state.seg.cs.flat, (new_cs));
} while (false);
state.rflag = f;
state.aflag.af = f.af;
state.aflag.cf = f.cf;
state.aflag.df = f.df;
state.aflag.of = f.of;
state.aflag.pf = f.pf;
state.aflag.sf = f.sf;
state.aflag.zf = f.zf;
state.hyper_call = AsyncHyperCall::kX86IRet;

auto new_rsp = PopFromStack<uint64_t>(memory, state);
auto new_ss = static_cast<uint16_t>(PopFromStack<uint64_t>(memory, state));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(new_rsp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (new_rsp));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.seg.ss.flat)>::BT) ==
sizeof(new_ss),
"Bad write!");
memory = _Write(memory, state.seg.ss.flat, (new_ss));
} while (false);

return memory;
}

extern "C" constexpr auto ISEL_IRETQ_64 [[gnu::used]] = IRETQ;

} // namespace

namespace {
template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNLE(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_sgt(
BAnd(BNot(state.aflag.zf),
BXnor(state.aflag.sf, state.aflag.of))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_sgt(BAnd(BNot(state.aflag.zf),
BXnor(state.aflag.sf, state.aflag.of))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false)

;
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNS(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.sf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.sf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVL(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_slt(BXor(state.aflag.sf, state.aflag.of)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_slt(BXor(state.aflag.sf, state.aflag.of)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNP(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.pf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.pf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNZ(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_neq(BNot(state.aflag.zf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_neq(BNot(state.aflag.zf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNB(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_uge(BNot(state.aflag.cf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_uge(BNot(state.aflag.cf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNO(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.of), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(
Select(BNot(state.aflag.of), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNL(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_sge(BXnor(state.aflag.sf, state.aflag.of)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_sge(BXnor(state.aflag.sf, state.aflag.of)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVNBE(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_ugt(
BNot(BOr(state.aflag.cf, state.aflag.zf))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_ugt(BNot(BOr(state.aflag.cf, state.aflag.zf))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVBE(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_ule(BOr(state.aflag.cf, state.aflag.zf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_ule(BOr(state.aflag.cf, state.aflag.zf)),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVZ(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_eq(state.aflag.zf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_eq(state.aflag.zf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVP(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(state.aflag.pf, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(state.aflag.pf, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVS(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(state.aflag.sf, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(state.aflag.sf, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVO(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Select(state.aflag.of, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Select(state.aflag.of, _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVB(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_ult(state.aflag.cf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_ult(state.aflag.cf), _Read(memory, src1),
TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMOVLE(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Select(
__remill_compare_sle(BOr(
state.aflag.zf, BXor(state.aflag.sf, state.aflag.of))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(Select(
__remill_compare_sle(BOr(
state.aflag.zf, BXor(state.aflag.sf, state.aflag.of))),
_Read(memory, src1), TruncTo<S1>(_Read(memory, dst))))));
} while (false);
} while (false)

;
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CMOVBE_GPRv_MEMv_8 [[gnu::used]] =
CMOVBE<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_MEMv_16 [[gnu::used]] =
CMOVBE<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_MEMv_32 [[gnu::used]] =
CMOVBE<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_MEMv_64 [[gnu::used]] =
CMOVBE<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_GPRv_8 [[gnu::used]] =
CMOVBE<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_GPRv_16 [[gnu::used]] =
CMOVBE<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_GPRv_32 [[gnu::used]] =
CMOVBE<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVBE_GPRv_GPRv_64 [[gnu::used]] =
CMOVBE<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_MEMv_8 [[gnu::used]] =
CMOVLE<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_MEMv_16 [[gnu::used]] =
CMOVLE<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_MEMv_32 [[gnu::used]] =
CMOVLE<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_MEMv_64 [[gnu::used]] =
CMOVLE<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_GPRv_8 [[gnu::used]] =
CMOVLE<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_GPRv_16 [[gnu::used]] =
CMOVLE<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_GPRv_32 [[gnu::used]] =
CMOVLE<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVLE_GPRv_GPRv_64 [[gnu::used]] =
CMOVLE<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_MEMv_8 [[gnu::used]] =
CMOVNLE<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_MEMv_16 [[gnu::used]] =
CMOVNLE<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_MEMv_32 [[gnu::used]] =
CMOVNLE<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_MEMv_64 [[gnu::used]] =
CMOVNLE<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_GPRv_8 [[gnu::used]] =
CMOVNLE<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_GPRv_16 [[gnu::used]] =
CMOVNLE<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_GPRv_32 [[gnu::used]] =
CMOVNLE<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNLE_GPRv_GPRv_64 [[gnu::used]] =
CMOVNLE<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_MEMv_8 [[gnu::used]] =
CMOVNP<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_MEMv_16 [[gnu::used]] =
CMOVNP<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_MEMv_32 [[gnu::used]] =
CMOVNP<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_MEMv_64 [[gnu::used]] =
CMOVNP<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_GPRv_8 [[gnu::used]] =
CMOVNP<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_GPRv_16 [[gnu::used]] =
CMOVNP<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_GPRv_32 [[gnu::used]] =
CMOVNP<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNP_GPRv_GPRv_64 [[gnu::used]] =
CMOVNP<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_MEMv_8 [[gnu::used]] =
CMOVNZ<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_MEMv_16 [[gnu::used]] =
CMOVNZ<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_MEMv_32 [[gnu::used]] =
CMOVNZ<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_MEMv_64 [[gnu::used]] =
CMOVNZ<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_GPRv_8 [[gnu::used]] =
CMOVNZ<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_GPRv_16 [[gnu::used]] =
CMOVNZ<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_GPRv_32 [[gnu::used]] =
CMOVNZ<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNZ_GPRv_GPRv_64 [[gnu::used]] =
CMOVNZ<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_MEMv_8 [[gnu::used]] =
CMOVNS<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_MEMv_16 [[gnu::used]] =
CMOVNS<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_MEMv_32 [[gnu::used]] =
CMOVNS<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_MEMv_64 [[gnu::used]] =
CMOVNS<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_GPRv_8 [[gnu::used]] =
CMOVNS<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_GPRv_16 [[gnu::used]] =
CMOVNS<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_GPRv_32 [[gnu::used]] =
CMOVNS<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNS_GPRv_GPRv_64 [[gnu::used]] =
CMOVNS<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_MEMv_8 [[gnu::used]] =
CMOVNO<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_MEMv_16 [[gnu::used]] =
CMOVNO<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_MEMv_32 [[gnu::used]] =
CMOVNO<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_MEMv_64 [[gnu::used]] =
CMOVNO<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_GPRv_8 [[gnu::used]] =
CMOVNO<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_GPRv_16 [[gnu::used]] =
CMOVNO<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_GPRv_32 [[gnu::used]] =
CMOVNO<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNO_GPRv_GPRv_64 [[gnu::used]] =
CMOVNO<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_MEMv_8 [[gnu::used]] =
CMOVNL<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_MEMv_16 [[gnu::used]] =
CMOVNL<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_MEMv_32 [[gnu::used]] =
CMOVNL<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_MEMv_64 [[gnu::used]] =
CMOVNL<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_GPRv_8 [[gnu::used]] =
CMOVNL<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_GPRv_16 [[gnu::used]] =
CMOVNL<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_GPRv_32 [[gnu::used]] =
CMOVNL<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNL_GPRv_GPRv_64 [[gnu::used]] =
CMOVNL<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_MEMv_8 [[gnu::used]] =
CMOVNB<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_MEMv_16 [[gnu::used]] =
CMOVNB<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_MEMv_32 [[gnu::used]] =
CMOVNB<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_MEMv_64 [[gnu::used]] =
CMOVNB<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_GPRv_8 [[gnu::used]] =
CMOVNB<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_GPRv_16 [[gnu::used]] =
CMOVNB<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_GPRv_32 [[gnu::used]] =
CMOVNB<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNB_GPRv_GPRv_64 [[gnu::used]] =
CMOVNB<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_MEMv_8 [[gnu::used]] = CMOVO<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_MEMv_16 [[gnu::used]] =
CMOVO<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_MEMv_32 [[gnu::used]] =
CMOVO<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_MEMv_64 [[gnu::used]] =
CMOVO<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_GPRv_8 [[gnu::used]] = CMOVO<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_GPRv_16 [[gnu::used]] =
CMOVO<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_GPRv_32 [[gnu::used]] =
CMOVO<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVO_GPRv_GPRv_64 [[gnu::used]] =
CMOVO<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_MEMv_8 [[gnu::used]] = CMOVZ<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_MEMv_16 [[gnu::used]] =
CMOVZ<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_MEMv_32 [[gnu::used]] =
CMOVZ<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_MEMv_64 [[gnu::used]] =
CMOVZ<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_GPRv_8 [[gnu::used]] = CMOVZ<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_GPRv_16 [[gnu::used]] =
CMOVZ<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_GPRv_32 [[gnu::used]] =
CMOVZ<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVZ_GPRv_GPRv_64 [[gnu::used]] =
CMOVZ<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_MEMv_8 [[gnu::used]] = CMOVP<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_MEMv_16 [[gnu::used]] =
CMOVP<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_MEMv_32 [[gnu::used]] =
CMOVP<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_MEMv_64 [[gnu::used]] =
CMOVP<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_GPRv_8 [[gnu::used]] = CMOVP<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_GPRv_16 [[gnu::used]] =
CMOVP<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_GPRv_32 [[gnu::used]] =
CMOVP<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVP_GPRv_GPRv_64 [[gnu::used]] =
CMOVP<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_MEMv_8 [[gnu::used]] = CMOVS<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_MEMv_16 [[gnu::used]] =
CMOVS<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_MEMv_32 [[gnu::used]] =
CMOVS<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_MEMv_64 [[gnu::used]] =
CMOVS<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_GPRv_8 [[gnu::used]] = CMOVS<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_GPRv_16 [[gnu::used]] =
CMOVS<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_GPRv_32 [[gnu::used]] =
CMOVS<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVS_GPRv_GPRv_64 [[gnu::used]] =
CMOVS<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_MEMv_8 [[gnu::used]] = CMOVL<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_MEMv_16 [[gnu::used]] =
CMOVL<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_MEMv_32 [[gnu::used]] =
CMOVL<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_MEMv_64 [[gnu::used]] =
CMOVL<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_GPRv_8 [[gnu::used]] = CMOVL<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_GPRv_16 [[gnu::used]] =
CMOVL<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_GPRv_32 [[gnu::used]] =
CMOVL<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVL_GPRv_GPRv_64 [[gnu::used]] =
CMOVL<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_MEMv_8 [[gnu::used]] = CMOVB<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_MEMv_16 [[gnu::used]] =
CMOVB<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_MEMv_32 [[gnu::used]] =
CMOVB<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_MEMv_64 [[gnu::used]] =
CMOVB<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_GPRv_8 [[gnu::used]] = CMOVB<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_GPRv_16 [[gnu::used]] =
CMOVB<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_GPRv_32 [[gnu::used]] =
CMOVB<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVB_GPRv_GPRv_64 [[gnu::used]] =
CMOVB<R64W, R64>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_MEMv_8 [[gnu::used]] =
CMOVNBE<R8W, M8>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_MEMv_16 [[gnu::used]] =
CMOVNBE<R16W, M16>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_MEMv_32 [[gnu::used]] =
CMOVNBE<R32W, M32>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_MEMv_64 [[gnu::used]] =
CMOVNBE<R64W, M64>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_GPRv_8 [[gnu::used]] =
CMOVNBE<R8W, R8>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_GPRv_16 [[gnu::used]] =
CMOVNBE<R16W, R16>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_GPRv_32 [[gnu::used]] =
CMOVNBE<R32W, R32>;
extern "C" constexpr auto ISEL_CMOVNBE_GPRv_GPRv_64 [[gnu::used]] =
CMOVNBE<R64W, R64>;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNLE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_sgt(
BAnd(BNot(state.aflag.zf), BXnor(state.aflag.sf, state.aflag.of)));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNS(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = BNot(state.aflag.sf);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JL(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_slt(BXor(state.aflag.sf, state.aflag.of));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNP(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = BNot(state.aflag.pf);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNZ(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_neq(BNot(state.aflag.zf));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNB(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_uge(BNot(state.aflag.cf));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNO(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = BNot(state.aflag.of);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNL(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch =
__remill_compare_uge(BXnor(state.aflag.sf, state.aflag.of));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JNBE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch =
__remill_compare_ugt(BNot(BOr(state.aflag.cf, state.aflag.zf)));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JBE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_ule(BOr(state.aflag.cf, state.aflag.zf));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JZ(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_eq(state.aflag.zf);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JP(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = state.aflag.pf;
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JS(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = state.aflag.sf;
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JO(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = state.aflag.of;
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JB(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_ult(state.aflag.cf);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JLE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = __remill_compare_sle(
BOr(state.aflag.zf, BXor(state.aflag.sf, state.aflag.of)));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_JNLE_RELBRb [[gnu::used]] = JNLE;
extern "C" constexpr auto ISEL_JNLE_RELBRz_8 [[gnu::used]] = JNLE;
extern "C" constexpr auto ISEL_JNLE_RELBRz_16 [[gnu::used]] = JNLE;
extern "C" constexpr auto ISEL_JNLE_RELBRz_32 [[gnu::used]] = JNLE;
extern "C" constexpr auto ISEL_JNLE_RELBRz_64 [[gnu::used]] = JNLE;
extern "C" constexpr auto ISEL_JNLE_RELBRd [[gnu::used]] = JNLE;

extern "C" constexpr auto ISEL_JNS_RELBRb [[gnu::used]] = JNS;
extern "C" constexpr auto ISEL_JNS_RELBRz_8 [[gnu::used]] = JNS;
extern "C" constexpr auto ISEL_JNS_RELBRz_16 [[gnu::used]] = JNS;
extern "C" constexpr auto ISEL_JNS_RELBRz_32 [[gnu::used]] = JNS;
extern "C" constexpr auto ISEL_JNS_RELBRz_64 [[gnu::used]] = JNS;
extern "C" constexpr auto ISEL_JNS_RELBRd [[gnu::used]] = JNS;

extern "C" constexpr auto ISEL_JL_RELBRb [[gnu::used]] = JL;
extern "C" constexpr auto ISEL_JL_RELBRz_8 [[gnu::used]] = JL;
extern "C" constexpr auto ISEL_JL_RELBRz_16 [[gnu::used]] = JL;
extern "C" constexpr auto ISEL_JL_RELBRz_32 [[gnu::used]] = JL;
extern "C" constexpr auto ISEL_JL_RELBRz_64 [[gnu::used]] = JL;
extern "C" constexpr auto ISEL_JL_RELBRd [[gnu::used]] = JL;

extern "C" constexpr auto ISEL_JNP_RELBRb [[gnu::used]] = JNP;
extern "C" constexpr auto ISEL_JNP_RELBRz_8 [[gnu::used]] = JNP;
extern "C" constexpr auto ISEL_JNP_RELBRz_16 [[gnu::used]] = JNP;
extern "C" constexpr auto ISEL_JNP_RELBRz_32 [[gnu::used]] = JNP;
extern "C" constexpr auto ISEL_JNP_RELBRz_64 [[gnu::used]] = JNP;
extern "C" constexpr auto ISEL_JNP_RELBRd [[gnu::used]] = JNP;

extern "C" constexpr auto ISEL_JNZ_RELBRb [[gnu::used]] = JNZ;
extern "C" constexpr auto ISEL_JNZ_RELBRz_8 [[gnu::used]] = JNZ;
extern "C" constexpr auto ISEL_JNZ_RELBRz_16 [[gnu::used]] = JNZ;
extern "C" constexpr auto ISEL_JNZ_RELBRz_32 [[gnu::used]] = JNZ;
extern "C" constexpr auto ISEL_JNZ_RELBRz_64 [[gnu::used]] = JNZ;
extern "C" constexpr auto ISEL_JNZ_RELBRd [[gnu::used]] = JNZ;

extern "C" constexpr auto ISEL_JNB_RELBRb [[gnu::used]] = JNB;
extern "C" constexpr auto ISEL_JNB_RELBRz_8 [[gnu::used]] = JNB;
extern "C" constexpr auto ISEL_JNB_RELBRz_16 [[gnu::used]] = JNB;
extern "C" constexpr auto ISEL_JNB_RELBRz_32 [[gnu::used]] = JNB;
extern "C" constexpr auto ISEL_JNB_RELBRz_64 [[gnu::used]] = JNB;
extern "C" constexpr auto ISEL_JNB_RELBRd [[gnu::used]] = JNB;

extern "C" constexpr auto ISEL_JNO_RELBRb [[gnu::used]] = JNO;
extern "C" constexpr auto ISEL_JNO_RELBRz_8 [[gnu::used]] = JNO;
extern "C" constexpr auto ISEL_JNO_RELBRz_16 [[gnu::used]] = JNO;
extern "C" constexpr auto ISEL_JNO_RELBRz_32 [[gnu::used]] = JNO;
extern "C" constexpr auto ISEL_JNO_RELBRz_64 [[gnu::used]] = JNO;
extern "C" constexpr auto ISEL_JNO_RELBRd [[gnu::used]] = JNO;

extern "C" constexpr auto ISEL_JNL_RELBRb [[gnu::used]] = JNL;
extern "C" constexpr auto ISEL_JNL_RELBRz_8 [[gnu::used]] = JNL;
extern "C" constexpr auto ISEL_JNL_RELBRz_16 [[gnu::used]] = JNL;
extern "C" constexpr auto ISEL_JNL_RELBRz_32 [[gnu::used]] = JNL;
extern "C" constexpr auto ISEL_JNL_RELBRz_64 [[gnu::used]] = JNL;
extern "C" constexpr auto ISEL_JNL_RELBRd [[gnu::used]] = JNL;

extern "C" constexpr auto ISEL_JNBE_RELBRb [[gnu::used]] = JNBE;
extern "C" constexpr auto ISEL_JNBE_RELBRz_8 [[gnu::used]] = JNBE;
extern "C" constexpr auto ISEL_JNBE_RELBRz_16 [[gnu::used]] = JNBE;
extern "C" constexpr auto ISEL_JNBE_RELBRz_32 [[gnu::used]] = JNBE;
extern "C" constexpr auto ISEL_JNBE_RELBRz_64 [[gnu::used]] = JNBE;
extern "C" constexpr auto ISEL_JNBE_RELBRd [[gnu::used]] = JNBE;

extern "C" constexpr auto ISEL_JBE_RELBRb [[gnu::used]] = JBE;
extern "C" constexpr auto ISEL_JBE_RELBRz_8 [[gnu::used]] = JBE;
extern "C" constexpr auto ISEL_JBE_RELBRz_16 [[gnu::used]] = JBE;
extern "C" constexpr auto ISEL_JBE_RELBRz_32 [[gnu::used]] = JBE;
extern "C" constexpr auto ISEL_JBE_RELBRz_64 [[gnu::used]] = JBE;
extern "C" constexpr auto ISEL_JBE_RELBRd [[gnu::used]] = JBE;

extern "C" constexpr auto ISEL_JZ_RELBRb [[gnu::used]] = JZ;
extern "C" constexpr auto ISEL_JZ_RELBRz_8 [[gnu::used]] = JZ;
extern "C" constexpr auto ISEL_JZ_RELBRz_16 [[gnu::used]] = JZ;
extern "C" constexpr auto ISEL_JZ_RELBRz_32 [[gnu::used]] = JZ;
extern "C" constexpr auto ISEL_JZ_RELBRz_64 [[gnu::used]] = JZ;
extern "C" constexpr auto ISEL_JZ_RELBRd [[gnu::used]] = JZ;

extern "C" constexpr auto ISEL_JP_RELBRb [[gnu::used]] = JP;
extern "C" constexpr auto ISEL_JP_RELBRz_8 [[gnu::used]] = JP;
extern "C" constexpr auto ISEL_JP_RELBRz_16 [[gnu::used]] = JP;
extern "C" constexpr auto ISEL_JP_RELBRz_32 [[gnu::used]] = JP;
extern "C" constexpr auto ISEL_JP_RELBRz_64 [[gnu::used]] = JP;
extern "C" constexpr auto ISEL_JP_RELBRd [[gnu::used]] = JP;

extern "C" constexpr auto ISEL_JS_RELBRb [[gnu::used]] = JS;
extern "C" constexpr auto ISEL_JS_RELBRz_8 [[gnu::used]] = JS;
extern "C" constexpr auto ISEL_JS_RELBRz_16 [[gnu::used]] = JS;
extern "C" constexpr auto ISEL_JS_RELBRz_32 [[gnu::used]] = JS;
extern "C" constexpr auto ISEL_JS_RELBRz_64 [[gnu::used]] = JS;
extern "C" constexpr auto ISEL_JS_RELBRd [[gnu::used]] = JS;

extern "C" constexpr auto ISEL_JO_RELBRb [[gnu::used]] = JO;
extern "C" constexpr auto ISEL_JO_RELBRz_8 [[gnu::used]] = JO;
extern "C" constexpr auto ISEL_JO_RELBRz_16 [[gnu::used]] = JO;
extern "C" constexpr auto ISEL_JO_RELBRz_32 [[gnu::used]] = JO;
extern "C" constexpr auto ISEL_JO_RELBRz_64 [[gnu::used]] = JO;
extern "C" constexpr auto ISEL_JO_RELBRd [[gnu::used]] = JO;

extern "C" constexpr auto ISEL_JB_RELBRb [[gnu::used]] = JB;
extern "C" constexpr auto ISEL_JB_RELBRz_8 [[gnu::used]] = JB;
extern "C" constexpr auto ISEL_JB_RELBRz_16 [[gnu::used]] = JB;
extern "C" constexpr auto ISEL_JB_RELBRz_32 [[gnu::used]] = JB;
extern "C" constexpr auto ISEL_JB_RELBRz_64 [[gnu::used]] = JB;
extern "C" constexpr auto ISEL_JB_RELBRd [[gnu::used]] = JB;

extern "C" constexpr auto ISEL_JLE_RELBRb [[gnu::used]] = JLE;
extern "C" constexpr auto ISEL_JLE_RELBRz_8 [[gnu::used]] = JLE;
extern "C" constexpr auto ISEL_JLE_RELBRz_16 [[gnu::used]] = JLE;
extern "C" constexpr auto ISEL_JLE_RELBRz_32 [[gnu::used]] = JLE;
extern "C" constexpr auto ISEL_JLE_RELBRz_64 [[gnu::used]] = JLE;
extern "C" constexpr auto ISEL_JLE_RELBRd [[gnu::used]] = JLE;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JCXZ(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = UCmpEq(state.gpr.rcx.word, 0_u16);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JECXZ(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = UCmpEq(state.gpr.rcx.dword, 0_u32);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JRCXZ(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
auto take_branch = UCmpEq(state.gpr.rcx.qword, 0_u64);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LOOP(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
addr_t count = USub(state.gpr.rcx.qword, addr_t(1));
auto take_branch = UCmpNeq(count, addr_t(0));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LOOPE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
addr_t count = USub(state.gpr.rcx.qword, addr_t(1));
auto take_branch = BAnd(UCmpNeq(count, addr_t(0)), state.aflag.zf);
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LOOPNE(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
addr_t taken_pc = _Read(memory, taken);
addr_t not_taken_pc = _Read(memory, not_taken);
addr_t count = USub(state.gpr.rcx.qword, addr_t(1));
auto take_branch = BAnd(UCmpNeq(count, addr_t(0)), BNot(state.aflag.zf));
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) ==
sizeof(take_branch),
"Bad write!");
memory = _Write(memory, cond, (take_branch));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(Select<addr_t>(take_branch, taken_pc, not_taken_pc)),
"Bad write!");
memory = _Write(memory, pc_dst,
(Select<addr_t>(take_branch, taken_pc, not_taken_pc)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_JCXZ_RELBRb [[gnu::used]] = JCXZ;
extern "C" constexpr auto ISEL_JECXZ_RELBRb [[gnu::used]] = JECXZ;
extern "C" constexpr auto ISEL_JRCXZ_RELBRb [[gnu::used]] = JRCXZ;

extern "C" constexpr auto ISEL_LOOP_RELBRb [[gnu::used]] = LOOP;
extern "C" constexpr auto ISEL_LOOPE_RELBRb [[gnu::used]] = LOOPE;
extern "C" constexpr auto ISEL_LOOPNE_RELBRb [[gnu::used]] = LOOPNE;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CBW_AL(Memory *memory, State &state) {
do {
static_assert(sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(Unsigned(SExt(state.gpr.rax.byte.low))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.word,
(Unsigned(SExt(state.gpr.rax.byte.low))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CWDE_AX(Memory *memory, State &state) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
SExt(state.gpr.rax.word))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(SExt(state.gpr.rax.word))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CDQE_EAX(Memory *memory, State &state) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
SExt(state.gpr.rax.dword))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(SExt(state.gpr.rax.dword))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CWD_AX(Memory *memory, State &state) {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.word)>::BT) ==
sizeof(Trunc(UShr(Unsigned(SExt(state.gpr.rax.word)), 16_u32))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.word,
(Trunc(UShr(Unsigned(SExt(state.gpr.rax.word)), 16_u32))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CDQ_EAX(Memory *memory, State &state) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(
Trunc(UShr(Unsigned(SExt(state.gpr.rax.dword)), 32_u64)))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(Trunc(
UShr(Unsigned(SExt(state.gpr.rax.dword)), 32_u64)))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CQO_RAX(Memory *memory, State &state) {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(UNot(USub(UShr(state.gpr.rax.qword, 63_u64), 1_u64))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword,
(UNot(USub(UShr(state.gpr.rax.qword, 63_u64), 1_u64))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CBW [[gnu::used]] = CBW_AL;
extern "C" constexpr auto ISEL_CWDE [[gnu::used]] = CWDE_AX;
extern "C" constexpr auto ISEL_CDQE [[gnu::used]] = CDQE_EAX;
extern "C" constexpr auto ISEL_CWD [[gnu::used]] = CWD_AX;
extern "C" constexpr auto ISEL_CDQ [[gnu::used]] = CDQ_EAX;
extern "C" constexpr auto ISEL_CQO [[gnu::used]] = CQO_RAX;

namespace {

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPI2PD(Memory *memory, State &state, V128W dst, S src) {
auto src_vec = _UReadV32(memory, src);
auto a = Float64(SExtractV32(src_vec, 0));
auto b = Float64(SExtractV32(src_vec, 1));
do {
memory = _FWriteV64(
memory, dst,
(FInsertV64(FInsertV64(_FReadV64(memory, dst), 0, a), 1, b)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTPI2PD_XMMpd_MEMq [[gnu::used]] =
CVTPI2PD<MV64>;
extern "C" constexpr auto ISEL_CVTPI2PD_XMMpd_MMXq [[gnu::used]] =
CVTPI2PD<V64>;

namespace {

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPI2PS(Memory *memory, State &state, V128W dst, S src) {
auto src_vec = _UReadV32(memory, src);
auto a = Float32(SExtractV32(src_vec, 0));
auto b = Float32(SExtractV32(src_vec, 1));
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(FInsertV32(_FReadV32(memory, dst), 0, a), 1, b)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTPI2PS_XMMq_MEMq [[gnu::used]] =
CVTPI2PS<MV64>;
extern "C" constexpr auto ISEL_CVTPI2PS_XMMq_MMXq [[gnu::used]] = CVTPI2PS<V64>;

namespace {

template <typename D, typename S1, size_t num_to_convert>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTDQ2PD(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _SReadV32(memory, src);
auto dst_vec = _ZeroVec<float64_t, decltype(_FReadV64(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < num_to_convert; ++i) {
auto entry = Float64(SExtractV32(src_vec, i));
dst_vec = FInsertV64(dst_vec, i, entry);
}
do {
memory = _FWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

typedef float32_t (*FloatConv32)(float32_t);
typedef float64_t (*FloatConv64)(float64_t);

} // namespace

extern "C" constexpr auto ISEL_CVTDQ2PD_XMMpd_MEMq [[gnu::used]] =
CVTDQ2PD<V128W, MV64, 2>;
extern "C" constexpr auto ISEL_CVTDQ2PD_XMMpd_XMMq [[gnu::used]] =
CVTDQ2PD<V128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTDQ2PD_XMMdq_MEMq [[gnu::used]] =
CVTDQ2PD<VV128W, MV64, 2>;
extern "C" constexpr auto ISEL_VCVTDQ2PD_XMMdq_XMMq [[gnu::used]] =
CVTDQ2PD<VV128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTDQ2PD_YMMqq_MEMdq [[gnu::used]] =
CVTDQ2PD<VV128W, MV128, 4>;
extern "C" constexpr auto ISEL_VCVTDQ2PD_YMMqq_XMMdq [[gnu::used]] =
CVTDQ2PD<VV128W, V128, 4>;

namespace {

template <typename D, typename S1, size_t num_to_convert>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTDQ2PS(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _SReadV32(memory, src);
auto dst_vec = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < num_to_convert; ++i) {
auto entry = Float32(SExtractV32(src_vec, i));
dst_vec = FInsertV32(dst_vec, i, entry);
}
do {
memory = _FWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTDQ2PS_XMMps_MEMdq [[gnu::used]] =
CVTDQ2PS<V128W, MV128, 4>;
extern "C" constexpr auto ISEL_CVTDQ2PS_XMMps_XMMdq [[gnu::used]] =
CVTDQ2PS<V128W, V128, 4>;
extern "C" constexpr auto ISEL_VCVTDQ2PS_XMMdq_MEMdq [[gnu::used]] =
CVTDQ2PS<VV128W, MV128, 4>;
extern "C" constexpr auto ISEL_VCVTDQ2PS_XMMdq_XMMdq [[gnu::used]] =
CVTDQ2PS<VV128W, V128, 4>;
extern "C" constexpr auto ISEL_VCVTDQ2PS_YMMqq_MEMqq [[gnu::used]] =
CVTDQ2PS<VV256W, MV256, 8>;
extern "C" constexpr auto ISEL_VCVTDQ2PS_YMMqq_YMMqq [[gnu::used]] =
CVTDQ2PS<VV256W, VV256, 8>;

namespace {

template <typename D, typename S1, size_t num_to_convert,
FloatConv64 FRound = FRoundUsingMode64>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPD2DQ(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _FReadV64(memory, src);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < num_to_convert; ++i) {
float64_t rounded_elem = FRound(FExtractV64(src_vec, i));
auto entry = Float64ToInt32(rounded_elem);
dst_vec = SInsertV32(dst_vec, i, entry);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTPD2DQ_XMMdq_MEMpd [[gnu::used]] =
CVTPD2DQ<V128W, MV128, 2>;
extern "C" constexpr auto ISEL_CVTPD2DQ_XMMdq_XMMpd [[gnu::used]] =
CVTPD2DQ<V128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2DQ_XMMdq_MEMdq [[gnu::used]] =
CVTPD2DQ<VV128W, MV128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2DQ_XMMdq_XMMdq [[gnu::used]] =
CVTPD2DQ<VV128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2DQ_XMMdq_MEMqq [[gnu::used]] =
CVTPD2DQ<VV128W, MV256, 4>;
extern "C" constexpr auto ISEL_VCVTPD2DQ_XMMdq_YMMqq [[gnu::used]] =
CVTPD2DQ<VV128W, V256, 4>;

extern "C" constexpr auto ISEL_CVTTPD2DQ_XMMdq_MEMpd [[gnu::used]] =
CVTPD2DQ<V128W, MV128, 2, FTruncTowardZero64>;
extern "C" constexpr auto ISEL_CVTTPD2DQ_XMMdq_XMMpd [[gnu::used]] =
CVTPD2DQ<V128W, V128, 2, FTruncTowardZero64>;
extern "C" constexpr auto ISEL_VCVTTPD2DQ_XMMdq_MEMdq [[gnu::used]] =
CVTPD2DQ<VV128W, MV128, 2, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTPD2DQ_XMMdq_XMMdq [[gnu::used]] =
CVTPD2DQ<VV128W, V128, 2, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTPD2DQ_XMMdq_MEMqq [[gnu::used]] =
CVTPD2DQ<VV128W, MV256, 4, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTPD2DQ_XMMdq_YMMqq [[gnu::used]] =
CVTPD2DQ<VV128W, V256, 4, FTruncTowardZero64>;

namespace {

template <typename D, typename S1, size_t num_to_convert,
FloatConv32 FRound = FRoundUsingMode32>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPS2DQ(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _FReadV32(memory, src);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < num_to_convert; ++i) {
float32_t rounded_elem = FRound(FExtractV32(src_vec, i));
dst_vec = SInsertV32(dst_vec, i, Float32ToInt32(rounded_elem));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTPS2DQ_XMMdq_MEMps [[gnu::used]] =
CVTPS2DQ<V128W, MV128, 4>;
extern "C" constexpr auto ISEL_CVTPS2DQ_XMMdq_XMMps [[gnu::used]] =
CVTPS2DQ<V128W, V128, 4>;
extern "C" constexpr auto ISEL_VCVTPS2DQ_XMMdq_MEMdq [[gnu::used]] =
CVTPS2DQ<VV128W, MV128, 4>;
extern "C" constexpr auto ISEL_VCVTPS2DQ_XMMdq_XMMdq [[gnu::used]] =
CVTPS2DQ<VV128W, V128, 4>;
extern "C" constexpr auto ISEL_VCVTPS2DQ_YMMqq_MEMqq [[gnu::used]] =
CVTPS2DQ<VV256W, MV256, 8>;
extern "C" constexpr auto ISEL_VCVTPS2DQ_YMMqq_YMMqq [[gnu::used]] =
CVTPS2DQ<VV256W, V256, 8>;

extern "C" constexpr auto ISEL_CVTTPS2DQ_XMMdq_MEMps [[gnu::used]] =
CVTPS2DQ<V128W, MV128, 4, FTruncTowardZero32>;
extern "C" constexpr auto ISEL_CVTTPS2DQ_XMMdq_XMMps [[gnu::used]] =
CVTPS2DQ<V128W, V128, 4, FTruncTowardZero32>;
extern "C" constexpr auto ISEL_VCVTTPS2DQ_XMMdq_MEMdq [[gnu::used]] =
CVTPS2DQ<VV128W, MV128, 4, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTPS2DQ_XMMdq_XMMdq [[gnu::used]] =
CVTPS2DQ<VV128W, V128, 4, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTPS2DQ_YMMqq_MEMqq [[gnu::used]] =
CVTPS2DQ<VV256W, MV256, 8, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTPS2DQ_YMMqq_YMMqq [[gnu::used]] =
CVTPS2DQ<VV256W, V256, 8, FTruncTowardZero32>;

namespace {

template <typename S, FloatConv32 FRound = FRoundUsingMode32>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSS2SI_32(Memory *memory, State &state, R32W dst, S src) {
float32_t rounded_val = FRound(FExtractV32(_FReadV32(memory, src), 0));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Unsigned(Float32ToInt32(rounded_val)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Unsigned(Float32ToInt32(rounded_val)))));
} while (false);
} while (false);
return memory;
}

template <typename S, FloatConv32 FRound = FRoundUsingMode32>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSS2SI_64(Memory *memory, State &state, R64W dst, S src) {
float32_t rounded_val = FRound(FExtractV32(_FReadV32(memory, src), 0));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(Float32ToInt64(rounded_val))),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(Float32ToInt64(rounded_val))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTSS2SI_GPR32d_MEMss [[gnu::used]] =
CVTSS2SI_32<MV32>;
extern "C" constexpr auto ISEL_CVTSS2SI_GPR32d_XMMss [[gnu::used]] =
CVTSS2SI_32<V128>;
extern "C" constexpr auto ISEL_CVTSS2SI_GPR64q_MEMss [[gnu::used]] =
CVTSS2SI_64<MV32>;
extern "C" constexpr auto ISEL_CVTSS2SI_GPR64q_XMMss [[gnu::used]] =
CVTSS2SI_64<V128>;
extern "C" constexpr auto ISEL_VCVTSS2SI_GPR32d_MEMd [[gnu::used]] =
CVTSS2SI_32<MV32>;
extern "C" constexpr auto ISEL_VCVTSS2SI_GPR32d_XMMd [[gnu::used]] =
CVTSS2SI_32<V128>;
extern "C" constexpr auto ISEL_VCVTSS2SI_GPR64q_MEMd [[gnu::used]] =
CVTSS2SI_64<MV32>;
extern "C" constexpr auto ISEL_VCVTSS2SI_GPR64q_XMMd [[gnu::used]] =
CVTSS2SI_64<V128>;

extern "C" constexpr auto ISEL_CVTTSS2SI_GPR32d_MEMss [[gnu::used]] =
CVTSS2SI_32<MV32, FTruncTowardZero32>;
extern "C" constexpr auto ISEL_CVTTSS2SI_GPR32d_XMMss [[gnu::used]] =
CVTSS2SI_32<V128, FTruncTowardZero32>;
extern "C" constexpr auto ISEL_CVTTSS2SI_GPR64q_MEMss [[gnu::used]] =
CVTSS2SI_64<MV32, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_CVTTSS2SI_GPR64q_XMMss [[gnu::used]] =
CVTSS2SI_64<V128, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTSS2SI_GPR32d_MEMd [[gnu::used]] =
CVTSS2SI_32<MV32, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTSS2SI_GPR32d_XMMd [[gnu::used]] =
CVTSS2SI_32<V128, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTSS2SI_GPR64q_MEMd [[gnu::used]] =
CVTSS2SI_64<MV32, FTruncTowardZero32>;

extern "C" constexpr auto ISEL_VCVTTSS2SI_GPR64q_XMMd [[gnu::used]] =
CVTSS2SI_64<V128, FTruncTowardZero32>;

namespace {

template <typename S, FloatConv64 FRound = FRoundUsingMode64>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSD2SI_32(Memory *memory, State &state, R32W dst, S src) {
auto rounded_val = FRound(FExtractV64(_FReadV64(memory, src), 0));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
Unsigned(Float64ToInt32(rounded_val)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(Unsigned(Float64ToInt32(rounded_val)))));
} while (false);
} while (false);
return memory;
}

template <typename S, FloatConv64 FRound = FRoundUsingMode64>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSD2SI_64(Memory *memory, State &state, R64W dst, S src) {
auto rounded_val = FRound(FExtractV64(_FReadV64(memory, src), 0));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(Float64ToInt64(rounded_val))),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(Float64ToInt64(rounded_val))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTSD2SI_GPR32d_MEMsd [[gnu::used]] =
CVTSD2SI_32<MV64>;
extern "C" constexpr auto ISEL_CVTSD2SI_GPR32d_XMMsd [[gnu::used]] =
CVTSD2SI_32<V128>;
extern "C" constexpr auto ISEL_VCVTSD2SI_GPR32d_MEMq [[gnu::used]] =
CVTSD2SI_32<MV64>;
extern "C" constexpr auto ISEL_VCVTSD2SI_GPR32d_XMMq [[gnu::used]] =
CVTSD2SI_32<V128>;
extern "C" constexpr auto ISEL_CVTSD2SI_GPR64q_MEMsd [[gnu::used]] =
CVTSD2SI_64<MV64>;
extern "C" constexpr auto ISEL_CVTSD2SI_GPR64q_XMMsd [[gnu::used]] =
CVTSD2SI_64<V128>;
extern "C" constexpr auto ISEL_VCVTSD2SI_GPR64q_MEMq [[gnu::used]] =
CVTSD2SI_64<MV64>;
extern "C" constexpr auto ISEL_VCVTSD2SI_GPR64q_XMMq [[gnu::used]] =
CVTSD2SI_64<V128>;

extern "C" constexpr auto ISEL_CVTTSD2SI_GPR32d_MEMsd [[gnu::used]] =
CVTSD2SI_32<MV64, FTruncTowardZero64>;
extern "C" constexpr auto ISEL_CVTTSD2SI_GPR32d_XMMsd [[gnu::used]] =
CVTSD2SI_32<V128, FTruncTowardZero64>;
extern "C" constexpr auto ISEL_VCVTTSD2SI_GPR32d_MEMq [[gnu::used]] =
CVTSD2SI_32<MV64, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTSD2SI_GPR32d_XMMq [[gnu::used]] =
CVTSD2SI_32<V128, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_CVTTSD2SI_GPR64q_MEMsd [[gnu::used]] =
CVTSD2SI_64<MV64, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_CVTTSD2SI_GPR64q_XMMsd [[gnu::used]] =
CVTSD2SI_64<V128, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTSD2SI_GPR64q_MEMq [[gnu::used]] =
CVTSD2SI_64<MV64, FTruncTowardZero64>;

extern "C" constexpr auto ISEL_VCVTTSD2SI_GPR64q_XMMq [[gnu::used]] =
CVTSD2SI_64<V128, FTruncTowardZero64>;

namespace {

template <typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSD2SS(Memory *memory, State &state, V128W dst, V128 _nop_read, S1 src) {
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(_FReadV32(memory, dst), 0,
Float32(FExtractV64(_FReadV64(memory, src), 0)))));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VCVTSD2SS(Memory *memory, State &state, VV128W dst, V128W src1, S2 src2) {
auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV64(memory, src2);
auto dst_vec = FInsertV32(src1_vec, 0, Float32(FExtractV64(src2_vec, 0)));
do {
memory = _FWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTSD2SS_XMMss_MEMsd [[gnu::used]] =
CVTSD2SS<MV64>;
extern "C" constexpr auto ISEL_CVTSD2SS_XMMss_XMMsd [[gnu::used]] =
CVTSD2SS<V128>;
extern "C" constexpr auto ISEL_VCVTSD2SS_XMMdq_XMMdq_MEMq [[gnu::used]] =
VCVTSD2SS<MV64>;
extern "C" constexpr auto ISEL_VCVTSD2SS_XMMdq_XMMdq_XMMq [[gnu::used]] =
VCVTSD2SS<V128>;

namespace {
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSI2SS(Memory *memory, State &state, V128W dst, V128 src1, S2 src2) {
auto src1_vec = _FReadV32(memory, src1);
auto conv_val = Float32(Signed(_Read(memory, src2)));
do {
memory = _FWriteV32(memory, dst, (FInsertV32(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSI2SD(Memory *memory, State &state, V128W dst, V128 src1, S2 src2) {
auto src1_vec = _FReadV64(memory, src1);
auto conv_val = Float64(Signed(_Read(memory, src2)));
do {
memory = _FWriteV64(memory, dst, (FInsertV64(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTSS2SD(Memory *memory, State &state, VV128W dst_src1, V128 _nop_read,
S2 src2) {
auto src1_vec = _FReadV64(memory, dst_src1);
auto src2_vec = _FReadV32(memory, src2);
auto conv_val = Float64(FExtractV32(src2_vec, 0));
do {
memory = _FWriteV64(memory, dst_src1, (FInsertV64(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VCVTSI2SS(Memory *memory, State &state, VV128W dst, V128 src1, S2 src2) {
auto src1_vec = _FReadV32(memory, src1);
auto conv_val = Float32(Signed(_Read(memory, src2)));
do {
memory = _FWriteV32(memory, dst, (FInsertV32(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VCVTSI2SD(Memory *memory, State &state, VV128W dst, V128 src1, S2 src2) {
auto src1_vec = _FReadV64(memory, src1);
auto conv_val = Float64(Signed(_Read(memory, src2)));
do {
memory = _FWriteV64(memory, dst, (FInsertV64(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VCVTSS2SD(Memory *memory, State &state, VV128W dst, V128 src1, S2 src2) {
auto src1_vec = _FReadV64(memory, src1);
auto src2_vec = _FReadV32(memory, src2);
auto conv_val = Float64(FExtractV32(src2_vec, 0));
do {
memory = _FWriteV64(memory, dst, (FInsertV64(src1_vec, 0, conv_val)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTSI2SS_XMMss_MEMd [[gnu::used]] =
CVTSI2SS<M32>;
extern "C" constexpr auto ISEL_CVTSI2SS_XMMss_GPR32d [[gnu::used]] =
CVTSI2SS<R32>;
extern "C" constexpr auto ISEL_CVTSI2SS_XMMss_MEMq [[gnu::used]] =
CVTSI2SS<M64>;
extern "C" constexpr auto ISEL_CVTSI2SS_XMMss_GPR64q [[gnu::used]] =
CVTSI2SS<R64>;
extern "C" constexpr auto ISEL_VCVTSI2SS_XMMdq_XMMdq_MEMd [[gnu::used]] =
VCVTSI2SS<M32>;
extern "C" constexpr auto ISEL_VCVTSI2SS_XMMdq_XMMdq_GPR32d [[gnu::used]] =
VCVTSI2SS<R32>;
extern "C" constexpr auto ISEL_VCVTSI2SS_XMMdq_XMMdq_MEMq [[gnu::used]] =
VCVTSI2SS<M64>;
extern "C" constexpr auto ISEL_VCVTSI2SS_XMMdq_XMMdq_GPR64q [[gnu::used]] =
VCVTSI2SS<R64>;

extern "C" constexpr auto ISEL_CVTSI2SD_XMMsd_MEMd [[gnu::used]] =
CVTSI2SD<M32>;
extern "C" constexpr auto ISEL_CVTSI2SD_XMMsd_GPR32d [[gnu::used]] =
CVTSI2SD<R32>;
extern "C" constexpr auto ISEL_CVTSI2SD_XMMsd_MEMq [[gnu::used]] =
CVTSI2SD<M64>;
extern "C" constexpr auto ISEL_CVTSI2SD_XMMsd_GPR64q [[gnu::used]] =
CVTSI2SD<R64>;
extern "C" constexpr auto ISEL_VCVTSI2SD_XMMdq_XMMdq_MEMd [[gnu::used]] =
VCVTSI2SD<M32>;
extern "C" constexpr auto ISEL_VCVTSI2SD_XMMdq_XMMdq_GPR32d [[gnu::used]] =
VCVTSI2SD<R32>;
extern "C" constexpr auto ISEL_VCVTSI2SD_XMMdq_XMMdq_MEMq [[gnu::used]] =
VCVTSI2SD<M64>;
extern "C" constexpr auto ISEL_VCVTSI2SD_XMMdq_XMMdq_GPR64q [[gnu::used]] =
VCVTSI2SD<R64>;

extern "C" constexpr auto ISEL_CVTSS2SD_XMMsd_MEMss [[gnu::used]] =
CVTSS2SD<MV32>;
extern "C" constexpr auto ISEL_CVTSS2SD_XMMsd_XMMss [[gnu::used]] =
CVTSS2SD<V128>;
extern "C" constexpr auto ISEL_VCVTSS2SD_XMMdq_XMMdq_MEMd [[gnu::used]] =
VCVTSS2SD<MV32>;
extern "C" constexpr auto ISEL_VCVTSS2SD_XMMdq_XMMdq_XMMd [[gnu::used]] =
VCVTSS2SD<V128>;

namespace {

template <typename D, typename S1, size_t vec_count>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPS2PD(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _FReadV32(memory, src);
auto dst_vec = _ZeroVec<float64_t, decltype(_FReadV64(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < vec_count; ++i) {
auto conv_val = Float64(FExtractV32(src_vec, i));
dst_vec = FInsertV64(dst_vec, i, conv_val);
}
do {
memory = _FWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, size_t vec_count>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CVTPD2PS(Memory *memory, State &state, D dst, S1 src) {
auto src_vec = _FReadV64(memory, src);
auto dst_vec = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();

#pragma unroll
for (size_t i = 0; i < vec_count; ++i) {
auto conv_val = Float32(FExtractV64(src_vec, i));
dst_vec = FInsertV32(dst_vec, i, conv_val);
}
do {
memory = _FWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CVTPS2PD_XMMpd_MEMq [[gnu::used]] =
CVTPS2PD<V128W, MV64, 2>;
extern "C" constexpr auto ISEL_CVTPS2PD_XMMpd_XMMq [[gnu::used]] =
CVTPS2PD<V128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPS2PD_XMMdq_MEMq [[gnu::used]] =
CVTPS2PD<VV128W, MV64, 2>;
extern "C" constexpr auto ISEL_VCVTPS2PD_XMMdq_XMMq [[gnu::used]] =
CVTPS2PD<VV128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPS2PD_YMMqq_MEMdq [[gnu::used]] =
CVTPS2PD<VV256W, MV128, 4>;
extern "C" constexpr auto ISEL_VCVTPS2PD_YMMqq_XMMdq [[gnu::used]] =
CVTPS2PD<VV256W, V128, 4>;

extern "C" constexpr auto ISEL_CVTPD2PS_XMMps_MEMpd [[gnu::used]] =
CVTPD2PS<V128W, MV128, 2>;
extern "C" constexpr auto ISEL_CVTPD2PS_XMMps_XMMpd [[gnu::used]] =
CVTPD2PS<V128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2PS_XMMdq_MEMdq [[gnu::used]] =
CVTPD2PS<VV128W, MV128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2PS_XMMdq_XMMdq [[gnu::used]] =
CVTPD2PS<VV128W, V128, 2>;
extern "C" constexpr auto ISEL_VCVTPD2PS_XMMdq_MEMqq [[gnu::used]] =
CVTPD2PS<VV128W, MV256, 4>;
extern "C" constexpr auto ISEL_VCVTPD2PS_XMMdq_YMMqq [[gnu::used]] =
CVTPD2PS<VV128W, V256, 4>;

namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV(Memory *memory, State &state, D dst, const S src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(_Read(memory, src))));
} while (false);
} while (false);
return memory;
}

template <typename D1, typename S1, typename D2, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
XCHG(Memory *memory, State &state, D1 dst, S1 dst_val, D2 src, S2 src_val) {
auto old_dst = _Read(memory, dst_val);
auto old_src = _Read(memory, src_val);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(old_src)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(old_src)));
} while (false);
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(src)>::BT) ==
sizeof(ZExtTo<decltype(src)>(old_dst)),
"Bad write!");
memory = _Write(memory, src, (ZExtTo<decltype(src)>(old_dst)));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVBE16(Memory *memory, State &state, D dst, const S src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
__builtin_bswap16(_Read(memory, src)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(__builtin_bswap16(_Read(memory, src)))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVBE32(Memory *memory, State &state, D dst, const S src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
__builtin_bswap32(_Read(memory, src)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(__builtin_bswap32(_Read(memory, src)))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVBE64(Memory *memory, State &state, D dst, const S src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(__builtin_bswap64(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (__builtin_bswap64(_Read(memory, src))));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVQ(Memory *memory, State &state, D dst, S src) {
do {
memory = _UWriteV64(memory, dst, (UExtractV64(_UReadV64(memory, src), 0)));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVD(Memory *memory, State &state, D dst, S src) {
do {
memory = _UWriteV32(memory, dst, (UExtractV32(_UReadV32(memory, src), 0)));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVxPS(Memory *memory, State &state, D dst, S src) {
do {
memory = _FWriteV32(memory, dst, (_FReadV32(memory, src)));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVxPD(Memory *memory, State &state, D dst, S src) {
do {
memory = _FWriteV64(memory, dst, (_FReadV64(memory, src)));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVDQx(Memory *memory, State &state, D dst, S src) {
do {
memory = _UWriteV128(memory, dst, (_UReadV128(memory, src)));
} while (false);
return memory;
}

template <typename D, typename S, typename... Fs>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVLPS(Memory *memory, State &state, D dst, Fs... _nop_fillers, S src) {
auto src_vec = _FReadV32(memory, src);
auto low1 = FExtractV32(src_vec, 0);
auto low2 = FExtractV32(src_vec, 1);
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(FInsertV32(_FReadV32(memory, dst), 0, low1), 1, low2)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVLHPS(Memory *memory, State &state, V128W dst, V128 _noop_read, V128 src) {
auto res = _FReadV32(memory, dst);
auto src1 = _FReadV32(memory, src);
res = FInsertV32(res, 2, FExtractV32(src1, 0));
res = FInsertV32(res, 3, FExtractV32(src1, 1));
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVHLPS(Memory *memory, State &state, V128W dst, V128 _nop_read, V128 src) {
auto res = _FReadV32(memory, dst);
auto src1 = _FReadV32(memory, src);
res = FInsertV32(res, 0, FExtractV32(src1, 2));
res = FInsertV32(res, 1, FExtractV32(src1, 3));
do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S, typename... Fs>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVLPD(Memory *memory, State &state, D dst, Fs... fargs, S src) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, dst), 0,
FExtractV64(_FReadV64(memory, src), 0))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVLPS(Memory *memory, State &state, VV128W dst, V128 src1, MV64 src2) {
auto low_vec = _FReadV32(memory, src2);
do {
memory = _FWriteV32(memory, dst,
(FInsertV32(FInsertV32(_FReadV32(memory, src1), 0,
FExtractV32(low_vec, 0)),
1, FExtractV32(low_vec, 1))));
} while (false)

;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVLPD(Memory *memory, State &state, VV128W dst, V128 src1, MV64 src2) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, src1), 0,
FExtractV64(_FReadV64(memory, src2), 0))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVLHPS(Memory *memory, State &state, VV128W dst, V128 src1, V128 src2) {

auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);

float32v4_t temp_vec = {};
temp_vec = FInsertV32(temp_vec, 0, FExtractV32(src1_vec, 0));
temp_vec = FInsertV32(temp_vec, 1, FExtractV32(src1_vec, 1));
temp_vec = FInsertV32(temp_vec, 2, FExtractV32(src2_vec, 0));
temp_vec = FInsertV32(temp_vec, 3, FExtractV32(src2_vec, 1));

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVHLPS(Memory *memory, State &state, VV128W dst, V128 src1, V128 src2) {
auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);

float32v4_t temp_vec = {};
temp_vec = FInsertV32(temp_vec, 0, FExtractV32(src2_vec, 2));
temp_vec = FInsertV32(temp_vec, 1, FExtractV32(src2_vec, 3));
temp_vec = FInsertV32(temp_vec, 2, FExtractV32(src1_vec, 2));
temp_vec = FInsertV32(temp_vec, 3, FExtractV32(src1_vec, 3));

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CALL_POP_FUSED_32 [[gnu::used]] = MOV<R32W, I32>;
extern "C" constexpr auto ISEL_CALL_POP_FUSED_64 [[gnu::used]] = MOV<R64W, I64>;

extern "C" constexpr auto ISEL_MOV_GPR8_IMMb_C6r0 [[gnu::used]] = MOV<R8W, I8>;
extern "C" constexpr auto ISEL_MOV_MEMb_IMMb [[gnu::used]] = MOV<M8W, I8>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMz_8 [[gnu::used]] = MOV<R8W, I8>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMz_16 [[gnu::used]] = MOV<R16W, I16>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMz_32 [[gnu::used]] = MOV<R32W, I32>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMz_64 [[gnu::used]] = MOV<R64W, I64>;
extern "C" constexpr auto ISEL_MOV_MEMv_IMMz_8 [[gnu::used]] = MOV<M8W, I8>;
extern "C" constexpr auto ISEL_MOV_MEMv_IMMz_16 [[gnu::used]] = MOV<M16W, I16>;
extern "C" constexpr auto ISEL_MOV_MEMv_IMMz_32 [[gnu::used]] = MOV<M32W, I32>;
extern "C" constexpr auto ISEL_MOV_MEMv_IMMz_64 [[gnu::used]] = MOV<M64W, I64>;
extern "C" constexpr auto ISEL_MOVBE_GPRv_MEMv_16 [[gnu::used]] =
MOVBE16<R16W, M16>;
extern "C" constexpr auto ISEL_MOVBE_GPRv_MEMv_32 [[gnu::used]] =
MOVBE32<R32W, M32>;
extern "C" constexpr auto ISEL_MOVBE_GPRv_MEMv_64 [[gnu::used]] =
MOVBE64<R64W, M64>;
extern "C" constexpr auto ISEL_MOV_GPR8_GPR8_88 [[gnu::used]] = MOV<R8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMb_GPR8 [[gnu::used]] = MOV<M8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_8 [[gnu::used]] = MOV<M8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_16 [[gnu::used]] = MOV<M16W, R16>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_32 [[gnu::used]] = MOV<M32W, R32>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_64 [[gnu::used]] = MOV<M64W, R64>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_89_8 [[gnu::used]] = MOV<R8W, R8>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_89_16 [[gnu::used]] =
MOV<R16W, R16>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_89_32 [[gnu::used]] =
MOV<R32W, R32>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_89_64 [[gnu::used]] =
MOV<R64W, R64>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_8B_8 [[gnu::used]] = MOV<R8W, R8>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_8B_16 [[gnu::used]] =
MOV<R16W, R16>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_8B_32 [[gnu::used]] =
MOV<R32W, R32>;
extern "C" constexpr auto ISEL_MOV_GPRv_GPRv_8B_64 [[gnu::used]] =
MOV<R64W, R64>;
extern "C" constexpr auto ISEL_MOV_GPR8_MEMb [[gnu::used]] = MOV<R8W, M8>;
extern "C" constexpr auto ISEL_MOV_GPR8_GPR8_8A [[gnu::used]] = MOV<R8W, R8>;
extern "C" constexpr auto ISEL_MOV_GPRv_MEMv_8 [[gnu::used]] = MOV<R8W, M8>;
extern "C" constexpr auto ISEL_MOV_GPRv_MEMv_16 [[gnu::used]] = MOV<R16W, M16>;
extern "C" constexpr auto ISEL_MOV_GPRv_MEMv_32 [[gnu::used]] = MOV<R32W, M32>;
extern "C" constexpr auto ISEL_MOV_GPRv_MEMv_64 [[gnu::used]] = MOV<R64W, M64>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_8B_8 [[gnu::used]] = MOV<M8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_8B_16 [[gnu::used]] =
MOV<M16W, R16>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_8B_32 [[gnu::used]] =
MOV<M32W, R32>;
extern "C" constexpr auto ISEL_MOV_MEMv_GPRv_8B_64 [[gnu::used]] =
MOV<M64W, R64>;
extern "C" constexpr auto ISEL_MOV_AL_MEMb [[gnu::used]] = MOV<R8W, M8>;
extern "C" constexpr auto ISEL_MOV_OrAX_MEMv_8 [[gnu::used]] = MOV<R8W, M8>;
extern "C" constexpr auto ISEL_MOV_OrAX_MEMv_16 [[gnu::used]] = MOV<R16W, M16>;
extern "C" constexpr auto ISEL_MOV_OrAX_MEMv_32 [[gnu::used]] = MOV<R32W, M32>;
extern "C" constexpr auto ISEL_MOV_OrAX_MEMv_64 [[gnu::used]] = MOV<R64W, M64>;
extern "C" constexpr auto ISEL_MOV_MEMb_AL [[gnu::used]] = MOV<M8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMv_OrAX_8 [[gnu::used]] = MOV<M8W, R8>;
extern "C" constexpr auto ISEL_MOV_MEMv_OrAX_16 [[gnu::used]] = MOV<M16W, R16>;
extern "C" constexpr auto ISEL_MOV_MEMv_OrAX_32 [[gnu::used]] = MOV<M32W, R32>;
extern "C" constexpr auto ISEL_MOV_MEMv_OrAX_64 [[gnu::used]] = MOV<M64W, R64>;
extern "C" constexpr auto ISEL_MOV_GPR8_IMMb_D0 [[gnu::used]] = MOV<R8W, I8>;
extern "C" constexpr auto ISEL_MOV_GPR8_IMMb_B0 [[gnu::used]] = MOV<R8W, I8>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMv_8 [[gnu::used]] = MOV<R8W, I8>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMv_16 [[gnu::used]] = MOV<R16W, I16>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMv_32 [[gnu::used]] = MOV<R32W, I32>;
extern "C" constexpr auto ISEL_MOV_GPRv_IMMv_64 [[gnu::used]] = MOV<R64W, I64>;

extern "C" constexpr auto ISEL_MOVNTI_MEMd_GPR32 [[gnu::used]] = MOV<M32W, R32>;
extern "C" constexpr auto ISEL_MOVNTI_MEMq_GPR64 [[gnu::used]] = MOV<M64W, R64>;

extern "C" constexpr auto ISEL_XCHG_MEMb_GPR8 [[gnu::used]] =
XCHG<M8W, M8, R8W, R8>;
extern "C" constexpr auto ISEL_XCHG_GPR8_GPR8 [[gnu::used]] =
XCHG<R8W, R8, R8W, R8>;
extern "C" constexpr auto ISEL_XCHG_MEMv_GPRv_8 [[gnu::used]] =
XCHG<M8W, M8, R8W, R8>;
extern "C" constexpr auto ISEL_XCHG_MEMv_GPRv_16 [[gnu::used]] =
XCHG<M16W, M16, R16W, R16>;
extern "C" constexpr auto ISEL_XCHG_MEMv_GPRv_32 [[gnu::used]] =
XCHG<M32W, M32, R32W, R32>;
extern "C" constexpr auto ISEL_XCHG_MEMv_GPRv_64 [[gnu::used]] =
XCHG<M64W, M64, R64W, R64>;
extern "C" constexpr auto ISEL_XCHG_GPRv_GPRv_8 [[gnu::used]] =
XCHG<R8W, R8, R8W, R8>;
extern "C" constexpr auto ISEL_XCHG_GPRv_GPRv_16 [[gnu::used]] =
XCHG<R16W, R16, R16W, R16>;
extern "C" constexpr auto ISEL_XCHG_GPRv_GPRv_32 [[gnu::used]] =
XCHG<R32W, R32, R32W, R32>;
extern "C" constexpr auto ISEL_XCHG_GPRv_GPRv_64 [[gnu::used]] =
XCHG<R64W, R64, R64W, R64>;
extern "C" constexpr auto ISEL_XCHG_GPRv_OrAX_8 [[gnu::used]] =
XCHG<R8W, R8, R8W, R8>;
extern "C" constexpr auto ISEL_XCHG_GPRv_OrAX_16 [[gnu::used]] =
XCHG<R16W, R16, R16W, R16>;
extern "C" constexpr auto ISEL_XCHG_GPRv_OrAX_32 [[gnu::used]] =
XCHG<R32W, R32, R32W, R32>;
extern "C" constexpr auto ISEL_XCHG_GPRv_OrAX_64 [[gnu::used]] =
XCHG<R64W, R64, R64W, R64>;

extern "C" constexpr auto ISEL_MOVQ_MMXq_MEMq_0F6E [[gnu::used]] =
MOVQ<V64W, MV64>;
extern "C" constexpr auto ISEL_MOVQ_MMXq_GPR64 [[gnu::used]] = MOVQ<V64W, V64>;
extern "C" constexpr auto ISEL_MOVQ_MEMq_MMXq_0F7E [[gnu::used]] =
MOVQ<V64W, V64>;
extern "C" constexpr auto ISEL_MOVQ_GPR64_MMXq [[gnu::used]] = MOVQ<V64W, V64>;
extern "C" constexpr auto ISEL_MOVQ_MMXq_MEMq_0F6F [[gnu::used]] =
MOVQ<V64W, MV64>;
extern "C" constexpr auto ISEL_MOVQ_MMXq_MMXq_0F6F [[gnu::used]] =
MOVQ<V64W, V64>;
extern "C" constexpr auto ISEL_MOVQ_MEMq_MMXq_0F7F [[gnu::used]] =
MOVQ<MV64W, V64>;
extern "C" constexpr auto ISEL_MOVQ_MMXq_MMXq_0F7F [[gnu::used]] =
MOVQ<V64W, V64>;

extern "C" constexpr auto ISEL_MOVQ_XMMdq_MEMq_0F6E [[gnu::used]] =
MOVQ<V128W, MV64>;
extern "C" constexpr auto ISEL_MOVQ_XMMdq_GPR64 [[gnu::used]] =
MOVQ<V128W, V64>;
extern "C" constexpr auto ISEL_MOVQ_MEMq_XMMq_0F7E [[gnu::used]] =
MOVQ<MV64W, V128>;
extern "C" constexpr auto ISEL_MOVQ_GPR64_XMMq [[gnu::used]] = MOVQ<V64W, V128>;
extern "C" constexpr auto ISEL_MOVQ_MEMq_XMMq_0FD6 [[gnu::used]] =
MOVQ<MV64W, V128>;
extern "C" constexpr auto ISEL_MOVQ_XMMdq_XMMq_0FD6 [[gnu::used]] =
MOVQ<V128W, V128>;
extern "C" constexpr auto ISEL_MOVQ_XMMdq_MEMq_0F7E [[gnu::used]] =
MOVQ<V128W, MV64>;
extern "C" constexpr auto ISEL_MOVQ_XMMdq_XMMq_0F7E [[gnu::used]] =
MOVQ<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVQ_XMMdq_MEMq_6E [[gnu::used]] =
MOVQ<VV128W, MV64>;
extern "C" constexpr auto ISEL_VMOVQ_XMMdq_GPR64q [[gnu::used]] =
MOVQ<VV128W, V64>;
extern "C" constexpr auto ISEL_VMOVQ_MEMq_XMMq_7E [[gnu::used]] =
MOVQ<MV64W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_GPR64q_XMMq [[gnu::used]] =
MOVQ<V64W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_XMMdq_MEMq_7E [[gnu::used]] =
MOVQ<VV128W, MV64>;
extern "C" constexpr auto ISEL_VMOVQ_XMMdq_XMMq_7E [[gnu::used]] =
MOVQ<VV128W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_MEMq_XMMq_D6 [[gnu::used]] =
MOVQ<MV64W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_XMMdq_XMMq_D6 [[gnu::used]] =
MOVQ<VV128W, V128>;

extern "C" constexpr auto ISEL_VMOVQ_XMMu64_MEMu64_AVX512 [[gnu::used]] =
MOVQ<VV128W, MV64>;
extern "C" constexpr auto ISEL_VMOVQ_GPR64u64_XMMu64_AVX512 [[gnu::used]] =
MOVQ<V64W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_XMMu64_GPR64u64_AVX512 [[gnu::used]] =
MOVQ<VV128W, V64>;
extern "C" constexpr auto ISEL_VMOVQ_XMMu64_XMMu64_AVX512 [[gnu::used]] =
MOVQ<VV128W, V128>;
extern "C" constexpr auto ISEL_VMOVQ_MEMu64_XMMu64_AVX512 [[gnu::used]] =
MOVQ<MV64W, V128>;

extern "C" constexpr auto ISEL_MOVD_MMXq_MEMd [[gnu::used]] = MOVD<V32W, MV32>;
extern "C" constexpr auto ISEL_MOVD_MMXq_GPR32 [[gnu::used]] = MOVD<V32W, V32>;
extern "C" constexpr auto ISEL_MOVD_MEMd_MMXd [[gnu::used]] = MOVD<MV32W, V32>;
extern "C" constexpr auto ISEL_MOVD_GPR32_MMXd [[gnu::used]] = MOVD<V32W, V32>;

extern "C" constexpr auto ISEL_MOVD_XMMdq_MEMd [[gnu::used]] =
MOVD<V128W, MV32>;
extern "C" constexpr auto ISEL_MOVD_XMMdq_GPR32 [[gnu::used]] =
MOVD<V128W, V32>;
extern "C" constexpr auto ISEL_MOVD_MEMd_XMMd [[gnu::used]] = MOVD<MV32W, V128>;
extern "C" constexpr auto ISEL_MOVD_GPR32_XMMd [[gnu::used]] = MOVD<V32W, V128>;

extern "C" constexpr auto ISEL_VMOVD_XMMdq_MEMd [[gnu::used]] =
MOVD<VV128W, MV32>;
extern "C" constexpr auto ISEL_VMOVD_XMMdq_GPR32d [[gnu::used]] =
MOVD<VV128W, V32>;
extern "C" constexpr auto ISEL_VMOVD_MEMd_XMMd [[gnu::used]] =
MOVD<MV32W, V128>;
extern "C" constexpr auto ISEL_VMOVD_GPR32d_XMMd [[gnu::used]] =
MOVD<V32W, V128>;

extern "C" constexpr auto ISEL_VMOVD_XMMu32_MEMu32_AVX512 [[gnu::used]] =
MOVD<VV128W, MV32>;
extern "C" constexpr auto ISEL_VMOVD_XMMu32_GPR32u32_AVX512 [[gnu::used]] =
MOVD<VV128W, V32>;
extern "C" constexpr auto ISEL_VMOVD_MEMu32_XMMu32_AVX512 [[gnu::used]] =
MOVD<MV32W, V128>;
extern "C" constexpr auto ISEL_VMOVD_GPR32u32_XMMu32_AVX512 [[gnu::used]] =
MOVD<V32W, V128>;

extern "C" constexpr auto ISEL_MOVAPS_XMMps_MEMps [[gnu::used]] =
MOVxPS<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVAPS_XMMps_XMMps_0F28 [[gnu::used]] =
MOVxPS<V128W, V128>;
extern "C" constexpr auto ISEL_MOVAPS_MEMps_XMMps [[gnu::used]] =
MOVxPS<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVAPS_XMMps_XMMps_0F29 [[gnu::used]] =
MOVxPS<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVAPS_XMMdq_MEMdq [[gnu::used]] =
MOVxPS<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVAPS_XMMdq_XMMdq_28 [[gnu::used]] =
MOVxPS<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPS_MEMdq_XMMdq [[gnu::used]] =
MOVxPS<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPS_XMMdq_XMMdq_29 [[gnu::used]] =
MOVxPS<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPS_YMMqq_MEMqq [[gnu::used]] =
MOVxPS<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVAPS_YMMqq_YMMqq_28 [[gnu::used]] =
MOVxPS<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVAPS_MEMqq_YMMqq [[gnu::used]] =
MOVxPS<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVAPS_YMMqq_YMMqq_29 [[gnu::used]] =
MOVxPS<VV256W, VV256>;
extern "C" constexpr auto ISEL_MOVNTPS_MEMdq_XMMps [[gnu::used]] =
MOVxPS<MV128W, V128>;

extern "C" constexpr auto ISEL_VMOVNTPS_MEMdq_XMMdq [[gnu::used]] =
MOVxPS<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVNTPS_MEMqq_YMMqq [[gnu::used]] =
MOVxPS<MV256W, VV256>;
extern "C" constexpr auto ISEL_MOVUPS_XMMps_MEMps [[gnu::used]] =
MOVxPS<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVUPS_XMMps_XMMps_0F10 [[gnu::used]] =
MOVxPS<V128W, V128>;
extern "C" constexpr auto ISEL_MOVUPS_MEMps_XMMps [[gnu::used]] =
MOVxPS<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVUPS_XMMps_XMMps_0F11 [[gnu::used]] =
MOVxPS<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVUPS_XMMdq_MEMdq [[gnu::used]] =
MOVxPS<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVUPS_XMMdq_XMMdq_10 [[gnu::used]] =
MOVxPS<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPS_MEMdq_XMMdq [[gnu::used]] =
MOVxPS<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPS_XMMdq_XMMdq_11 [[gnu::used]] =
MOVxPS<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPS_YMMqq_MEMqq [[gnu::used]] =
MOVxPS<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVUPS_YMMqq_YMMqq_10 [[gnu::used]] =
MOVxPS<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVUPS_MEMqq_YMMqq [[gnu::used]] =
MOVxPS<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVUPS_YMMqq_YMMqq_11 [[gnu::used]] =
MOVxPS<VV256W, VV256>;
extern "C" constexpr auto ISEL_MOVAPD_XMMpd_MEMpd [[gnu::used]] =
MOVxPD<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVAPD_XMMpd_XMMpd_0F28 [[gnu::used]] =
MOVxPD<V128W, V128>;
extern "C" constexpr auto ISEL_MOVAPD_MEMpd_XMMpd [[gnu::used]] =
MOVxPD<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVAPD_XMMpd_XMMpd_0F29 [[gnu::used]] =
MOVxPD<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVAPD_XMMdq_MEMdq [[gnu::used]] =
MOVxPD<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVAPD_XMMdq_XMMdq_28 [[gnu::used]] =
MOVxPD<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPD_MEMdq_XMMdq [[gnu::used]] =
MOVxPD<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPD_XMMdq_XMMdq_29 [[gnu::used]] =
MOVxPD<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVAPD_YMMqq_MEMqq [[gnu::used]] =
MOVxPD<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVAPD_YMMqq_YMMqq_28 [[gnu::used]] =
MOVxPD<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVAPD_MEMqq_YMMqq [[gnu::used]] =
MOVxPD<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVAPD_YMMqq_YMMqq_29 [[gnu::used]] =
MOVxPD<VV256W, VV256>;
extern "C" constexpr auto ISEL_MOVNTPD_MEMdq_XMMpd [[gnu::used]] =
MOVxPD<MV128W, V128>;

extern "C" constexpr auto ISEL_VMOVNTPD_MEMdq_XMMdq [[gnu::used]] =
MOVxPD<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVNTPD_MEMqq_YMMqq [[gnu::used]] =
MOVxPD<MV256W, VV256>;
extern "C" constexpr auto ISEL_MOVUPD_XMMpd_MEMpd [[gnu::used]] =
MOVxPD<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVUPD_XMMpd_XMMpd_0F10 [[gnu::used]] =
MOVxPD<V128W, V128>;
extern "C" constexpr auto ISEL_MOVUPD_MEMpd_XMMpd [[gnu::used]] =
MOVxPD<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVUPD_XMMpd_XMMpd_0F11 [[gnu::used]] =
MOVxPD<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVUPD_XMMdq_MEMdq [[gnu::used]] =
MOVxPD<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVUPD_XMMdq_XMMdq_10 [[gnu::used]] =
MOVxPD<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPD_MEMdq_XMMdq [[gnu::used]] =
MOVxPD<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPD_XMMdq_XMMdq_11 [[gnu::used]] =
MOVxPD<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVUPD_YMMqq_MEMqq [[gnu::used]] =
MOVxPD<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVUPD_YMMqq_YMMqq_10 [[gnu::used]] =
MOVxPD<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVUPD_MEMqq_YMMqq [[gnu::used]] =
MOVxPD<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVUPD_YMMqq_YMMqq_11 [[gnu::used]] =
MOVxPD<VV256W, VV256>;
extern "C" constexpr auto ISEL_MOVNTDQ_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVNTDQA_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<V128W, MV128>;

extern "C" constexpr auto ISEL_MOVDQU_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVDQU_XMMdq_XMMdq_0F6F [[gnu::used]] =
MOVDQx<V128W, V128>;
extern "C" constexpr auto ISEL_MOVDQU_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVDQU_XMMdq_XMMdq_0F7F [[gnu::used]] =
MOVDQx<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVNTDQ_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, V128>;
extern "C" constexpr auto ISEL_VMOVNTDQ_MEMqq_YMMqq [[gnu::used]] =
MOVDQx<MV256W, VV256>;

extern "C" constexpr auto ISEL_VMOVNTDQA_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVNTDQA_YMMqq_MEMqq [[gnu::used]] =
MOVDQx<VV256W, MV256>;

extern "C" constexpr auto ISEL_VMOVDQU_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVDQU_XMMdq_XMMdq_6F [[gnu::used]] =
MOVDQx<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQU_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQU_XMMdq_XMMdq_7F [[gnu::used]] =
MOVDQx<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQU_YMMqq_MEMqq [[gnu::used]] =
MOVDQx<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVDQU_YMMqq_YMMqq_6F [[gnu::used]] =
MOVDQx<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVDQU_MEMqq_YMMqq [[gnu::used]] =
MOVDQx<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVDQU_YMMqq_YMMqq_7F [[gnu::used]] =
MOVDQx<VV256W, VV256>;

extern "C" constexpr auto ISEL_MOVDQA_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, V128>;
extern "C" constexpr auto ISEL_MOVDQA_XMMdq_XMMdq_0F7F [[gnu::used]] =
MOVDQx<V128W, V128>;
extern "C" constexpr auto ISEL_MOVDQA_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<V128W, MV128>;
extern "C" constexpr auto ISEL_MOVDQA_XMMdq_XMMdq_0F6F [[gnu::used]] =
MOVDQx<V128W, V128>;

extern "C" constexpr auto ISEL_VMOVDQA_XMMdq_MEMdq [[gnu::used]] =
MOVDQx<VV128W, MV128>;
extern "C" constexpr auto ISEL_VMOVDQA_XMMdq_XMMdq_6F [[gnu::used]] =
MOVDQx<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQA_MEMdq_XMMdq [[gnu::used]] =
MOVDQx<MV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQA_XMMdq_XMMdq_7F [[gnu::used]] =
MOVDQx<VV128W, VV128>;
extern "C" constexpr auto ISEL_VMOVDQA_YMMqq_MEMqq [[gnu::used]] =
MOVDQx<VV256W, MV256>;
extern "C" constexpr auto ISEL_VMOVDQA_YMMqq_YMMqq_6F [[gnu::used]] =
MOVDQx<VV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVDQA_MEMqq_YMMqq [[gnu::used]] =
MOVDQx<MV256W, VV256>;
extern "C" constexpr auto ISEL_VMOVDQA_YMMqq_YMMqq_7F [[gnu::used]] =
MOVDQx<VV256W, VV256>;

extern "C" constexpr auto ISEL_MOVLPS_MEMq_XMMq [[gnu::used]] =
MOVLPS<MV64W, V128>;
extern "C" constexpr auto ISEL_MOVLPS_XMMq_MEMq [[gnu::used]] =
MOVLPS<V128W, MV64, V128>;
extern "C" constexpr auto ISEL_VMOVLPS_MEMq_XMMq [[gnu::used]] =
MOVLPS<MV64W, VV128>;
extern "C" constexpr auto ISEL_VMOVLPS_XMMdq_XMMdq_MEMq [[gnu::used]] = VMOVLPS;

extern "C" constexpr auto ISEL_MOVHLPS_XMMq_XMMq [[gnu::used]] = MOVHLPS;
extern "C" constexpr auto ISEL_VMOVHLPS_XMMdq_XMMq_XMMq [[gnu::used]] =
VMOVHLPS;
extern "C" constexpr auto ISEL_VMOVHLPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
VMOVHLPS;

extern "C" constexpr auto ISEL_MOVLHPS_XMMq_XMMq [[gnu::used]] = MOVLHPS;
extern "C" constexpr auto ISEL_VMOVLHPS_XMMdq_XMMq_XMMq [[gnu::used]] =
VMOVLHPS;
extern "C" constexpr auto ISEL_VMOVLHPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
VMOVLHPS;
extern "C" constexpr auto ISEL_MOVLPD_XMMsd_MEMq [[gnu::used]] =
MOVLPD<V128W, MV64, V128>;
extern "C" constexpr auto ISEL_MOVLPD_MEMq_XMMsd [[gnu::used]] =
MOVLPD<MV64W, V128>;
extern "C" constexpr auto ISEL_VMOVLPD_MEMq_XMMq [[gnu::used]] =
MOVLPD<MV64W, VV128>;
extern "C" constexpr auto ISEL_VMOVLPD_XMMdq_XMMdq_MEMq [[gnu::used]] = VMOVLPD;
namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVSD_MEM(Memory *memory, State &state, D dst, S src) {
do {
memory = _FWriteV64(memory, dst, (FExtractV64(_FReadV64(memory, src), 0)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVSD(Memory *memory, State &state, V128W dst, V128 src) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, dst), 0,
FExtractV64(_FReadV64(memory, src), 0))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVSD(Memory *memory, State &state, VV128W dst, V128 src1, V128 src2) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, src2), 1,
FExtractV64(_FReadV64(memory, src1), 1))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVSD_XMM_XMMsd_XMMsd_0F10 [[gnu::used]] = MOVSD;
extern "C" constexpr auto ISEL_MOVSD_XMM_XMMdq_MEMsd [[gnu::used]] =
MOVSD_MEM<V128W, MV64>;
extern "C" constexpr auto ISEL_MOVSD_XMM_MEMsd_XMMsd [[gnu::used]] =
MOVSD_MEM<MV64W, V128>;
extern "C" constexpr auto ISEL_MOVSD_XMM_XMMsd_XMMsd_0F11 [[gnu::used]] = MOVSD;

extern "C" constexpr auto ISEL_VMOVSD_XMMdq_MEMq [[gnu::used]] =
MOVSD_MEM<VV128W, MV64>;
extern "C" constexpr auto ISEL_VMOVSD_MEMq_XMMq [[gnu::used]] =
MOVSD_MEM<MV64W, VV128>;
extern "C" constexpr auto ISEL_VMOVSD_XMMdq_XMMdq_XMMq_10 [[gnu::used]] =
VMOVSD;
extern "C" constexpr auto ISEL_VMOVSD_XMMdq_XMMdq_XMMq_11 [[gnu::used]] =
VMOVSD;
extern "C" constexpr auto ISEL_MOVNTSD_MEMq_XMMq [[gnu::used]] =
MOVSD_MEM<MV64W, V128>;

namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVSS_MEM(Memory *memory, State &state, D dst, S src) {
do {
memory = _FWriteV32(memory, dst, (FExtractV32(_FReadV32(memory, src), 0)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVSS(Memory *memory, State &state, V128W dst, V128 src) {
do {
memory = _FWriteV32(memory, dst,
(FInsertV32(_FReadV32(memory, dst), 0,
FExtractV32(_FReadV32(memory, src), 0))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVSS(Memory *memory, State &state, VV128W dst, V128 src1, V128 src2) {
do {
memory = _FWriteV32(memory, dst,
(FInsertV32(_FReadV32(memory, src1), 0,
FExtractV32(_FReadV32(memory, src2), 0))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVSS_XMMdq_MEMss [[gnu::used]] =
MOVSS_MEM<V128W, MV32>;
extern "C" constexpr auto ISEL_MOVSS_MEMss_XMMss [[gnu::used]] =
MOVSS_MEM<MV32W, V128>;
extern "C" constexpr auto ISEL_MOVSS_XMMss_XMMss_0F10 [[gnu::used]] = MOVSS;
extern "C" constexpr auto ISEL_MOVSS_XMMss_XMMss_0F11 [[gnu::used]] = MOVSS;

extern "C" constexpr auto ISEL_VMOVSS_XMMdq_MEMd [[gnu::used]] =
MOVSS_MEM<VV128W, MV32>;
extern "C" constexpr auto ISEL_VMOVSS_MEMd_XMMd [[gnu::used]] =
MOVSS_MEM<MV32W, V128>;
extern "C" constexpr auto ISEL_VMOVSS_XMMdq_XMMdq_XMMd_10 [[gnu::used]] =
VMOVSS;
extern "C" constexpr auto ISEL_VMOVSS_XMMdq_XMMdq_XMMd_11 [[gnu::used]] =
VMOVSS;
extern "C" constexpr auto ISEL_MOVNTSS_MEMd_XMMd [[gnu::used]] =
MOVSS_MEM<MV32W, V128>;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVHPD(Memory *memory, State &state, V128W dst, V128 _nop_read, MV64 src) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, dst), 1,
FExtractV64(_FReadV64(memory, src), 0))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVHPD_STORE(Memory *memory, State &state, MV64W dst, V128 src) {
do {
memory = _FWriteV64(memory, dst, (FExtractV64(_FReadV64(memory, src), 1)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVHPD(Memory *memory, State &state, VV256W dst, V128 src1, MV64 src2) {
do {
memory = _FWriteV64(memory, dst,
(FInsertV64(_FReadV64(memory, src1), 1,
FExtractV64(_FReadV64(memory, src2), 0))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVHPD_XMMsd_MEMq [[gnu::used]] = MOVHPD;
extern "C" constexpr auto ISEL_MOVHPD_MEMq_XMMsd [[gnu::used]] = MOVHPD_STORE;
extern "C" constexpr auto ISEL_VMOVHPD_XMMdq_XMMq_MEMq [[gnu::used]] = VMOVHPD;
extern "C" constexpr auto ISEL_VMOVHPD_MEMq_XMMdq [[gnu::used]] = MOVHPD_STORE;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVHPS(Memory *memory, State &state, V128W dst, V128 _nop_read, MV64 src) {
auto dst_vec = _FReadV32(memory, dst);
auto src_vec = _FReadV32(memory, src);
auto low_entry = FExtractV32(src_vec, 0);
auto high_entry = FExtractV32(src_vec, 1);
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(FInsertV32(dst_vec, 2, low_entry), 3, high_entry)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVHPS_STORE(Memory *memory, State &state, MV64W dst, V128 src) {
auto dst_vec = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();
auto src_vec = _FReadV32(memory, src);
auto low_entry = FExtractV32(src_vec, 2);
auto high_entry = FExtractV32(src_vec, 3);
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(FInsertV32(dst_vec, 0, low_entry), 1, high_entry)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VMOVHPS(Memory *memory, State &state, VV256W dst, V128 src1, MV64 src2) {
auto dst_vec = _FReadV32(memory, src1);
auto src_vec = _FReadV32(memory, src2);
auto low_entry = FExtractV32(src_vec, 0);
auto high_entry = FExtractV32(src_vec, 1);
do {
memory = _FWriteV32(
memory, dst,
(FInsertV32(FInsertV32(dst_vec, 2, low_entry), 3, high_entry)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVHPS_XMMq_MEMq [[gnu::used]] = MOVHPS;
extern "C" constexpr auto ISEL_MOVHPS_MEMq_XMMps [[gnu::used]] = MOVHPS_STORE;
extern "C" constexpr auto ISEL_VMOVHPS_XMMdq_XMMq_MEMq [[gnu::used]] = VMOVHPS;
extern "C" constexpr auto ISEL_VMOVHPS_MEMq_XMMdq [[gnu::used]] = MOVHPS_STORE;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV_ES(Memory *memory, State &state, R16W dst, T src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentES);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV_SS(Memory *memory, State &state, R16W dst, T src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentSS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV_DS(Memory *memory, State &state, R16W dst, T src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentDS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV_FS(Memory *memory, State &state, R16W dst, T src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentFS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOV_GS(Memory *memory, State &state, R16W dst, T src) {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentGS);
}

} // namespace

extern "C" constexpr auto ISEL_MOV_MEMw_SEG [[gnu::used]] = MOV<M16W, R16>;

extern "C" constexpr auto ISEL_MOV_GPRv_SEG_16 [[gnu::used]] = MOV<R16W, R16>;
extern "C" constexpr auto ISEL_MOV_GPRv_SEG_32 [[gnu::used]] = MOV<R32W, R16>;
extern "C" constexpr auto ISEL_MOV_GPRv_SEG_64 [[gnu::used]] = MOV<R64W, R16>;

extern "C" constexpr auto ISEL_MOV_SEG_MEMw_ES [[gnu::used]] = MOV_ES<M16>;
extern "C" constexpr auto ISEL_MOV_SEG_MEMw_SS [[gnu::used]] = MOV_SS<M16>;
extern "C" constexpr auto ISEL_MOV_SEG_MEMw_DS [[gnu::used]] = MOV_DS<M16>;
extern "C" constexpr auto ISEL_MOV_SEG_MEMw_FS [[gnu::used]] = MOV_FS<M16>;
extern "C" constexpr auto ISEL_MOV_SEG_MEMw_GS [[gnu::used]] = MOV_GS<M16>;

extern "C" constexpr auto ISEL_MOV_SEG_GPR16_ES [[gnu::used]] = MOV_ES<R16>;
extern "C" constexpr auto ISEL_MOV_SEG_GPR16_SS [[gnu::used]] = MOV_SS<R16>;
extern "C" constexpr auto ISEL_MOV_SEG_GPR16_DS [[gnu::used]] = MOV_DS<R16>;
extern "C" constexpr auto ISEL_MOV_SEG_GPR16_FS [[gnu::used]] = MOV_FS<R16>;
extern "C" constexpr auto ISEL_MOV_SEG_GPR16_GS [[gnu::used]] = MOV_GS<R16>;
namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVZX(Memory *memory, State &state, D dst, S src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(_Read(memory, src))));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S, typename SextT>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVSX(Memory *memory, State &state, D dst, S src) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(SExtTo<SextT>(_Read(memory, src)))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(SExtTo<SextT>(_Read(memory, src)))));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVZX_GPRv_MEMb_16 [[gnu::used]] =
MOVZX<R16W, M8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_MEMb_32 [[gnu::used]] =
MOVZX<R32W, M8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_MEMb_64 [[gnu::used]] =
MOVZX<R64W, M8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_GPR8_16 [[gnu::used]] =
MOVZX<R16W, R8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_GPR8_32 [[gnu::used]] =
MOVZX<R32W, R8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_GPR8_64 [[gnu::used]] =
MOVZX<R64W, R8>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_MEMw_32 [[gnu::used]] =
MOVZX<R32W, M16>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_MEMw_64 [[gnu::used]] =
MOVZX<R64W, M16>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_GPR16_32 [[gnu::used]] =
MOVZX<R32W, R16>;
extern "C" constexpr auto ISEL_MOVZX_GPRv_GPR16_64 [[gnu::used]] =
MOVZX<R64W, R16>;

extern "C" constexpr auto ISEL_MOVSX_GPRv_MEMb_16 [[gnu::used]] =
MOVSX<R16W, M8, int16_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_MEMb_32 [[gnu::used]] =
MOVSX<R32W, M8, int32_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_MEMb_64 [[gnu::used]] =
MOVSX<R64W, M8, int64_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_GPR8_16 [[gnu::used]] =
MOVSX<R16W, R8, int16_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_GPR8_32 [[gnu::used]] =
MOVSX<R32W, R8, int32_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_GPR8_64 [[gnu::used]] =
MOVSX<R64W, R8, int64_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_MEMw_32 [[gnu::used]] =
MOVSX<R32W, M16, int32_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_MEMw_64 [[gnu::used]] =
MOVSX<R64W, M16, int64_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_GPR16_32 [[gnu::used]] =
MOVSX<R32W, R16, int32_t>;
extern "C" constexpr auto ISEL_MOVSX_GPRv_GPR16_64 [[gnu::used]] =
MOVSX<R64W, R16, int64_t>;

extern "C" constexpr auto ISEL_MOVSXD_GPRv_GPRz_16 [[gnu::used]] =
MOVSX<R32W, R16, int32_t>;
extern "C" constexpr auto ISEL_MOVSXD_GPRv_GPRz_32 [[gnu::used]] =
MOVSX<R32W, R32, int32_t>;

extern "C" constexpr auto ISEL_MOVSXD_GPRv_MEMd_32 [[gnu::used]] =
MOVSX<R64W, M32, int64_t>;
extern "C" constexpr auto ISEL_MOVSXD_GPRv_GPR32_32 [[gnu::used]] =
MOVSX<R64W, R32, int64_t>;

extern "C" constexpr auto ISEL_MOVSXD_GPRv_MEMd_64 [[gnu::used]] =
MOVSX<R64W, M32, int64_t>;
extern "C" constexpr auto ISEL_MOVSXD_GPRv_MEMz_64 [[gnu::used]] =
MOVSX<R64W, M32, int64_t>;
extern "C" constexpr auto ISEL_MOVSXD_GPRv_GPR32_64 [[gnu::used]] =
MOVSX<R64W, R32, int64_t>;
extern "C" constexpr auto ISEL_MOVSXD_GPRv_GPRz_64 [[gnu::used]] =
MOVSX<R64W, R32, int64_t>;

namespace {

template <typename D, typename K, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPMOVSXBQ_MASKmskw_SIMD128(Memory *memory, State &state, D dst, K k1, S src) {
auto src_vec = _SReadV8(memory, src);
auto dst_vec = _ZeroVec<int64_t, decltype(_SReadV64(memory, dst))>();
auto k_vec = _Read(memory, k1);
for (auto i = 0u; i < 2u; i++) {
if (((k_vec >> i) & 1) == 0) {
dst_vec = SInsertV64(dst_vec, i, 0);
} else {
auto v = SExtTo<int64_t>(SExtractV8(src_vec, i));
dst_vec = SInsertV64(dst_vec, i, v);
}
}
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename K, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPMOVSXWD_MASKmskw_SIMD128(Memory *memory, State &state, D dst, K k1, S src) {
auto src_vec = _SReadV16(memory, src);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();
auto k_vec = _Read(memory, k1);
for (auto i = 0u; i < 4u; i++) {
if (((k_vec >> i) & 1) == 0) {
dst_vec = SInsertV32(dst_vec, i, 0);
} else {
auto v = SExtTo<int32_t>(SExtractV16(src_vec, i));
dst_vec = SInsertV32(dst_vec, i, v);
}
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
KMOVW(Memory *memory, State &state, S1 dst, S2 src) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(UInt16(_Read(memory, src)))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(UInt16(_Read(memory, src)))));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_VPMOVSXBQ_XMMi64_MASKmskw_MEMi8_AVX512
[[gnu::used]] = VPMOVSXBQ_MASKmskw_SIMD128<VV128W, R8, MV16>;
extern "C" constexpr auto ISEL_VPMOVSXBQ_XMMi64_MASKmskw_XMMi8_AVX512
[[gnu::used]] = VPMOVSXBQ_MASKmskw_SIMD128<VV128W, R8, V128>;
extern "C" constexpr auto ISEL_VPMOVSXWD_XMMi32_MASKmskw_MEMi16_AVX512
[[gnu::used]] = VPMOVSXWD_MASKmskw_SIMD128<VV128W, R8, MV64>;
extern "C" constexpr auto ISEL_VPMOVSXWD_XMMi32_MASKmskw_XMMi16_AVX512
[[gnu::used]] = VPMOVSXWD_MASKmskw_SIMD128<VV128W, R8, V128>;

extern "C" constexpr auto ISEL_KMOVW_MASKmskw_MASKu16_AVX512 [[gnu::used]] =
KMOVW<R64W, R64>;
extern "C" constexpr auto ISEL_KMOVW_GPR32u32_MASKmskw_AVX512 [[gnu::used]] =
KMOVW<R32W, R64>;
extern "C" constexpr auto ISEL_KMOVW_MASKmskw_GPR32u32_AVX512 [[gnu::used]] =
KMOVW<R64W, R32>;
extern "C" constexpr auto ISEL_KMOVW_MASKmskw_MEMu16_AVX512 [[gnu::used]] =
KMOVW<R64W, M16>;
extern "C" constexpr auto ISEL_KMOVW_MEMu16_MASKmskw_AVX512 [[gnu::used]] =
KMOVW<M16W, R64>;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
AAS(Memory *memory, State &state) {
auto &rax = state.gpr.rax;
auto af = _Read(memory, state.aflag.af);
auto cf = _Read(memory, state.aflag.cf);

if (UCmpGt(UAnd16(rax.byte.low, 0xf), 9) || UCmpEq(af, 1)) {
rax.word = USub16(rax.word, 6);
rax.byte.high = USub8(rax.byte.high, 1);
cf = 1;
af = 1;

} else {
cf = 0;
af = 0;
}

rax.byte.low = UAnd8(rax.byte.low, 0xf);

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(af),
"Bad write!");
memory = _Write(memory, state.aflag.af, (af));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(cf),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (cf));
} while (false);

state.aflag.of = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();

return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DAA(Memory *memory, State &state) {
auto old_al = _Read(memory, state.gpr.rax.byte.low);
auto al = old_al;
auto cf = _Read(memory, state.aflag.cf);
auto old_cf = _Read(memory, state.aflag.cf);
auto af = _Read(memory, state.aflag.af);
auto sf = _Read(memory, state.aflag.sf);
auto pf = _Read(memory, state.aflag.pf);
auto zf = _Read(memory, state.aflag.zf);

cf = 0;

if (UCmpGt(UAnd8(al, 0xf), 9) || UCmpEq(af, 1)) {
al = UAdd8(al, 6);
bool set_cf = BOr((UCmpLt(al, old_al)), UCmpLt(al, 6));
cf = BOr(old_cf, set_cf);
af = 1;
} else {
af = 0;
}

if (UCmpGt(old_al, 0x99) || UCmpEq(old_cf, 1)) {
al = UAdd8(al, 0x60);
cf = 1;
} else {
cf = 0;
}

sf = SignFlag(al);
zf = ZeroFlag(al);
pf = ParityFlag(al);

do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(al),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low, (al));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(cf),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (cf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(af),
"Bad write!");
memory = _Write(memory, state.aflag.af, (af));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(sf),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (sf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(pf),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (pf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(zf),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (zf));
} while (false);

state.aflag.of = __remill_undefined_8();

return memory;
}

} // namespace

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCLD(Memory *memory, State &state) {
state.aflag.df = false;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTD(Memory *memory, State &state) {
state.aflag.df = true;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCLC(Memory *memory, State &state) {
state.aflag.cf = false;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMC(Memory *memory, State &state) {
state.aflag.cf = BNot(state.aflag.cf);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTC(Memory *memory, State &state) {
state.aflag.cf = true;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSALC(Memory *memory, State &state) {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(Unsigned(state.aflag.cf)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low, (Unsigned(state.aflag.cf)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSAHF(Memory *memory, State &state) {
Flags flags = {ZExtTo<uint64_t>(_Read(memory, state.gpr.rax.byte.high))};
state.aflag.cf = UCmpEq(1, flags.cf);
state.aflag.pf = UCmpEq(1, flags.pf);
state.aflag.af = UCmpEq(1, flags.af);
state.aflag.sf = UCmpEq(1, flags.sf);
state.aflag.zf = UCmpEq(1, flags.zf);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLAHF(Memory *memory, State &state) {
Flags flags = {0};
flags.cf = Unsigned(state.aflag.cf);
flags.must_be_1 = 1;
flags.pf = Unsigned(state.aflag.pf);
flags.must_be_0a = 0;
flags.af = Unsigned(state.aflag.af);
flags.must_be_0b = 0;
flags.zf = Unsigned(state.aflag.zf);
flags.sf = Unsigned(state.aflag.sf);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.high)>::BT) ==
sizeof(TruncTo<uint8_t>(flags.flat)),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.byte.high, (TruncTo<uint8_t>(flags.flat)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCLAC(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.rflag.ac = false;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTAC(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.rflag.ac = true;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCLI(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.rflag._if = false;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTI(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.rflag._if = true;
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_CLD [[gnu::used]] = DoCLD;
extern "C" constexpr auto ISEL_STD [[gnu::used]] = DoSTD;
extern "C" constexpr auto ISEL_CLC [[gnu::used]] = DoCLC;
extern "C" constexpr auto ISEL_CMC [[gnu::used]] = DoCMC;
extern "C" constexpr auto ISEL_STC [[gnu::used]] = DoSTC;
extern "C" constexpr auto ISEL_SALC [[gnu::used]] = DoSALC;
extern "C" constexpr auto ISEL_SAHF [[gnu::used]] = DoSAHF;
extern "C" constexpr auto ISEL_LAHF [[gnu::used]] = DoLAHF;
extern "C" constexpr auto ISEL_CLAC [[gnu::used]] = DoCLAC;
extern "C" constexpr auto ISEL_STAC [[gnu::used]] = DoSTAC;
extern "C" constexpr auto ISEL_CLI [[gnu::used]] = DoCLI;
extern "C" constexpr auto ISEL_STI [[gnu::used]] = DoSTI;
namespace {

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMADD132SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto temp_vec = _FReadV64(memory, src1);
auto src3_vec = _FReadV64(memory, src3);
auto src2_vec = _FReadV64(memory, src2);

auto dst_float = FExtractV64(temp_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);
auto src2_float = FExtractV64(src2_vec, 0);

auto vfmadd132sd_float = (dst_float * src3_float + src2_float);
temp_vec = FInsertV64(temp_vec, 0, vfmadd132sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMADD231SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto src2_vec = _FReadV64(memory, src2);
auto src3_vec = _FReadV64(memory, src3);
auto temp_vec = _FReadV64(memory, src1);

auto src2_float = FExtractV64(src2_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);
auto dst_float = FExtractV64(temp_vec, 0);

auto vfmadd231sd_float = (src2_float * src3_float + dst_float);
temp_vec = FInsertV64(temp_vec, 0, vfmadd231sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMADD213SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto src2_vec = _FReadV64(memory, src2);
auto temp_vec = _FReadV64(memory, src1);
auto src3_vec = _FReadV64(memory, src3);

auto src2_float = FExtractV64(src2_vec, 0);
auto dst_float = FExtractV64(temp_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);

auto vfmadd213sd_float = (src2_float * dst_float + src3_float);
temp_vec = FInsertV64(temp_vec, 0, vfmadd213sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_VFMADD132SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMADD132SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMADD132SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMADD132SD<VV128W, V128, V128, V128>;

extern "C" constexpr auto ISEL_VFMADD231SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMADD231SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMADD231SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMADD231SD<VV128W, V128, V128, V128>;

extern "C" constexpr auto ISEL_VFMADD213SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMADD213SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMADD213SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMADD213SD<VV128W, V128, V128, V128>;

namespace {

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMSUB132SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto temp_vec = _FReadV64(memory, src1);
auto src3_vec = _FReadV64(memory, src3);
auto src2_vec = _FReadV64(memory, src2);

auto dst_float = FExtractV64(temp_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);
auto src2_float = FExtractV64(src2_vec, 0);

auto vfmsub132sd_float = (dst_float * src3_float - src2_float);
temp_vec = FInsertV64(temp_vec, 0, vfmsub132sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMSUB213SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto src2_vec = _FReadV64(memory, src2);
auto temp_vec = _FReadV64(memory, src1);
auto src3_vec = _FReadV64(memory, src3);

auto src2_float = FExtractV64(src2_vec, 0);
auto dst_float = FExtractV64(temp_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);

auto vfmsub213sd_float = (src2_float * dst_float - src3_float);
temp_vec = FInsertV64(temp_vec, 0, vfmsub213sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VFMSUB231SD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {

auto src2_vec = _FReadV64(memory, src2);
auto src3_vec = _FReadV64(memory, src3);
auto temp_vec = _FReadV64(memory, src1);

auto src2_float = FExtractV64(src2_vec, 0);
auto src3_float = FExtractV64(src3_vec, 0);
auto dst_float = FExtractV64(temp_vec, 0);

auto vfmsub231sd_float = (src2_float * src3_float - dst_float);
temp_vec = FInsertV64(temp_vec, 0, vfmsub231sd_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_VFMSUB132SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMSUB132SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMSUB132SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMSUB132SD<VV128W, V128, V128, V128>;

extern "C" constexpr auto ISEL_VFMSUB231SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMSUB231SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMSUB231SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMSUB231SD<VV128W, V128, V128, V128>;

extern "C" constexpr auto ISEL_VFMSUB213SD_XMMdq_XMMq_MEMq [[gnu::used]] =
VFMSUB213SD<VV128W, V128, V128, MV64>;

extern "C" constexpr auto ISEL_VFMSUB213SD_XMMdq_XMMq_XMMq [[gnu::used]] =
VFMSUB213SD<VV128W, V128, V128, V128>;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoINT_IMMb(Memory *memory, State &state, I8 num, R64W) {
state.hyper_call_vector = _Read(memory, num);
state.hyper_call = AsyncHyperCall::kX86IntN;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoINT1(Memory *memory, State &state, R64W) {
state.hyper_call_vector = 1;
state.hyper_call = AsyncHyperCall::kX86Int1;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoINT3(Memory *memory, State &state, R64W) {
state.hyper_call_vector = 3;
state.hyper_call = AsyncHyperCall::kX86Int3;
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_INT_IMMb [[gnu::used]] = DoINT_IMMb;
extern "C" constexpr auto ISEL_INT1 [[gnu::used]] = DoINT1;
extern "C" constexpr auto ISEL_INT3 [[gnu::used]] = DoINT3;
namespace {

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IN8(Memory *memory, State &state, R8W dst, S port) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(__remill_read_io_port_8(memory, _Read(memory, port))),
"Bad write!");
memory = _Write(memory, dst,
(__remill_read_io_port_8(memory, _Read(memory, port))));
} while (false);
return memory;
}

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IN16(Memory *memory, State &state, R16W dst, S port) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(__remill_read_io_port_16(memory, _Read(memory, port))),
"Bad write!");
memory = _Write(memory, dst,
(__remill_read_io_port_16(memory, _Read(memory, port))));
} while (false);
return memory;
}

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
IN32(Memory *memory, State &state, R32W dst, S port) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(__remill_read_io_port_32(
memory, _Read(memory, port)))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(__remill_read_io_port_32(
memory, _Read(memory, port)))));
} while (false);
} while (false);
return memory;
}

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
OUT8(Memory *memory, State &state, S port, R8 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_write_io_port_8(memory, _Read(memory, port),
_Read(memory, src));
}

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
OUT16(Memory *memory, State &state, S port, R16 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_write_io_port_16(memory, _Read(memory, port),
_Read(memory, src));
}

template <typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
OUT32(Memory *memory, State &state, S port, R32 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_write_io_port_32(memory, _Read(memory, port),
_Read(memory, src));
}

} // namespace

extern "C" constexpr auto ISEL_IN_AL_IMMb [[gnu::used]] = IN8<I8>;
extern "C" constexpr auto ISEL_IN_AL_DX [[gnu::used]] = IN8<R16>;
extern "C" constexpr auto ISEL_IN_OeAX_IMMb_16 [[gnu::used]] = IN16<I8>;
extern "C" constexpr auto ISEL_IN_OeAX_DX_16 [[gnu::used]] = IN16<R16>;
extern "C" constexpr auto ISEL_IN_OeAX_IMMb_32 [[gnu::used]] = IN32<I8>;
extern "C" constexpr auto ISEL_IN_OeAX_DX_32 [[gnu::used]] = IN32<R16>;

extern "C" constexpr auto ISEL_OUT_IMMb_AL [[gnu::used]] = OUT8<I8>;
extern "C" constexpr auto ISEL_OUT_DX_AL [[gnu::used]] = OUT8<R16>;
extern "C" constexpr auto ISEL_OUT_IMMb_OeAX_16 [[gnu::used]] = OUT16<I8>;
extern "C" constexpr auto ISEL_OUT_DX_OeAX_16 [[gnu::used]] = OUT16<R16>;
extern "C" constexpr auto ISEL_OUT_IMMb_OeAX_32 [[gnu::used]] = OUT32<I8>;
extern "C" constexpr auto ISEL_OUT_DX_OeAX_32 [[gnu::used]] = OUT32<R16>;

namespace {

template <typename T>
[[gnu::always_inline]] inline void SetFlagsLogical(State &state, T lhs, T rhs,
T res) {
state.aflag.cf = false;
state.aflag.pf = ParityFlag(res);
state.aflag.zf = ZeroFlag(res, lhs, rhs);
state.aflag.sf = SignFlag(res, lhs, rhs);
state.aflag.of = false;
state.aflag.af = false;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
AND(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto res = UAnd(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);
SetFlagsLogical(state, lhs, rhs, res);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
OR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto res = UOr(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);
SetFlagsLogical(state, lhs, rhs, res);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
XOR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto res = UXor(lhs, rhs);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);
SetFlagsLogical(state, lhs, rhs, res);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
NOT(Memory *memory, State &state, D dst, S1 src1) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(UNot(_Read(memory, src1)))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(UNot(_Read(memory, src1)))));
} while (false);
} while (false);
return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
TEST(Memory *memory, State &state, S1 src1, S2 src2) {
auto lhs = _Read(memory, src1);
auto rhs = _Read(memory, src2);
auto res = UAnd(lhs, rhs);
SetFlagsLogical(state, lhs, rhs, res);
do {
state.aflag.af = __remill_undefined_8();
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_AND_MEMb_IMMb_80r4 [[gnu::used]] =
AND<M8W, M8, I8>;
extern "C" constexpr auto ISEL_AND_GPR8_IMMb_80r4 [[gnu::used]] =
AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMz_8 [[gnu::used]] = AND<M8W, M8, I8>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMz_16 [[gnu::used]] =
AND<M16W, M16, I16>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMz_32 [[gnu::used]] =
AND<M32W, M32, I32>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMz_64 [[gnu::used]] =
AND<M64W, M64, I64>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMz_8 [[gnu::used]] = AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMz_16 [[gnu::used]] =
AND<R16W, R16, I16>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMz_32 [[gnu::used]] =
AND<R32W, R32, I32>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMz_64 [[gnu::used]] =
AND<R64W, R64, I64>;
extern "C" constexpr auto ISEL_AND_MEMb_IMMb_82r4 [[gnu::used]] =
AND<M8W, M8, I8>;
extern "C" constexpr auto ISEL_AND_GPR8_IMMb_82r4 [[gnu::used]] =
AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMb_8 [[gnu::used]] = AND<M8W, M8, I8>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMb_16 [[gnu::used]] =
AND<M16W, M16, I16>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMb_32 [[gnu::used]] =
AND<M32W, M32, I32>;
extern "C" constexpr auto ISEL_AND_MEMv_IMMb_64 [[gnu::used]] =
AND<M64W, M64, I64>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMb_8 [[gnu::used]] = AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMb_16 [[gnu::used]] =
AND<R16W, R16, I16>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMb_32 [[gnu::used]] =
AND<R32W, R32, I32>;
extern "C" constexpr auto ISEL_AND_GPRv_IMMb_64 [[gnu::used]] =
AND<R64W, R64, I64>;
extern "C" constexpr auto ISEL_AND_MEMb_GPR8 [[gnu::used]] = AND<M8W, M8, R8>;
extern "C" constexpr auto ISEL_AND_GPR8_GPR8_20 [[gnu::used]] =
AND<R8W, R8, R8>;
extern "C" constexpr auto ISEL_AND_MEMv_GPRv_8 [[gnu::used]] = AND<M8W, M8, R8>;
extern "C" constexpr auto ISEL_AND_MEMv_GPRv_16 [[gnu::used]] =
AND<M16W, M16, R16>;
extern "C" constexpr auto ISEL_AND_MEMv_GPRv_32 [[gnu::used]] =
AND<M32W, M32, R32>;
extern "C" constexpr auto ISEL_AND_MEMv_GPRv_64 [[gnu::used]] =
AND<M64W, M64, R64>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_21_8 [[gnu::used]] =
AND<R8W, R8, R8>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_21_16 [[gnu::used]] =
AND<R16W, R16, R16>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_21_32 [[gnu::used]] =
AND<R32W, R32, R32>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_21_64 [[gnu::used]] =
AND<R64W, R64, R64>;
extern "C" constexpr auto ISEL_AND_GPR8_GPR8_22 [[gnu::used]] =
AND<R8W, R8, R8>;
extern "C" constexpr auto ISEL_AND_GPR8_MEMb [[gnu::used]] = AND<R8W, R8, M8>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_23_8 [[gnu::used]] =
AND<R8W, R8, R8>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_23_16 [[gnu::used]] =
AND<R16W, R16, R16>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_23_32 [[gnu::used]] =
AND<R32W, R32, R32>;
extern "C" constexpr auto ISEL_AND_GPRv_GPRv_23_64 [[gnu::used]] =
AND<R64W, R64, R64>;
extern "C" constexpr auto ISEL_AND_GPRv_MEMv_8 [[gnu::used]] = AND<R8W, R8, M8>;
extern "C" constexpr auto ISEL_AND_GPRv_MEMv_16 [[gnu::used]] =
AND<R16W, R16, M16>;
extern "C" constexpr auto ISEL_AND_GPRv_MEMv_32 [[gnu::used]] =
AND<R32W, R32, M32>;
extern "C" constexpr auto ISEL_AND_GPRv_MEMv_64 [[gnu::used]] =
AND<R64W, R64, M64>;
extern "C" constexpr auto ISEL_AND_AL_IMMb [[gnu::used]] = AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_OrAX_IMMz_8 [[gnu::used]] = AND<R8W, R8, I8>;
extern "C" constexpr auto ISEL_AND_OrAX_IMMz_16 [[gnu::used]] =
AND<R16W, R16, I16>;
extern "C" constexpr auto ISEL_AND_OrAX_IMMz_32 [[gnu::used]] =
AND<R32W, R32, I32>;
extern "C" constexpr auto ISEL_AND_OrAX_IMMz_64 [[gnu::used]] =
AND<R64W, R64, I64>;

extern "C" constexpr auto ISEL_OR_MEMb_IMMb_80r1 [[gnu::used]] =
OR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_OR_GPR8_IMMb_80r1 [[gnu::used]] =
OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMz_8 [[gnu::used]] = OR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMz_16 [[gnu::used]] =
OR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMz_32 [[gnu::used]] =
OR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMz_64 [[gnu::used]] =
OR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMz_8 [[gnu::used]] = OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMz_16 [[gnu::used]] =
OR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMz_32 [[gnu::used]] =
OR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMz_64 [[gnu::used]] =
OR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_OR_MEMb_IMMb_82r1 [[gnu::used]] =
OR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_OR_GPR8_IMMb_82r1 [[gnu::used]] =
OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMb_8 [[gnu::used]] = OR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMb_16 [[gnu::used]] =
OR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMb_32 [[gnu::used]] =
OR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_OR_MEMv_IMMb_64 [[gnu::used]] =
OR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMb_8 [[gnu::used]] = OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMb_16 [[gnu::used]] =
OR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMb_32 [[gnu::used]] =
OR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_OR_GPRv_IMMb_64 [[gnu::used]] =
OR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_OR_MEMb_GPR8 [[gnu::used]] = OR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_OR_GPR8_GPR8_08 [[gnu::used]] = OR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_OR_MEMv_GPRv_8 [[gnu::used]] = OR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_OR_MEMv_GPRv_16 [[gnu::used]] =
OR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_OR_MEMv_GPRv_32 [[gnu::used]] =
OR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_OR_MEMv_GPRv_64 [[gnu::used]] =
OR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_09_8 [[gnu::used]] =
OR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_09_16 [[gnu::used]] =
OR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_09_32 [[gnu::used]] =
OR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_09_64 [[gnu::used]] =
OR<R64W, R64, R64>;
extern "C" constexpr auto ISEL_OR_GPR8_MEMb [[gnu::used]] = OR<R8W, R8, M8>;
extern "C" constexpr auto ISEL_OR_GPR8_GPR8_0A [[gnu::used]] = OR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_OR_GPRv_MEMv_8 [[gnu::used]] = OR<R8W, R8, M8>;
extern "C" constexpr auto ISEL_OR_GPRv_MEMv_16 [[gnu::used]] =
OR<R16W, R16, M16>;
extern "C" constexpr auto ISEL_OR_GPRv_MEMv_32 [[gnu::used]] =
OR<R32W, R32, M32>;
extern "C" constexpr auto ISEL_OR_GPRv_MEMv_64 [[gnu::used]] =
OR<R64W, R64, M64>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_0B_8 [[gnu::used]] =
OR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_0B_16 [[gnu::used]] =
OR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_0B_32 [[gnu::used]] =
OR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_OR_GPRv_GPRv_0B_64 [[gnu::used]] =
OR<R64W, R64, R64>;
extern "C" constexpr auto ISEL_OR_AL_IMMb [[gnu::used]] = OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_OrAX_IMMz_8 [[gnu::used]] = OR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_OR_OrAX_IMMz_16 [[gnu::used]] =
OR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_OR_OrAX_IMMz_32 [[gnu::used]] =
OR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_OR_OrAX_IMMz_64 [[gnu::used]] =
OR<R64W, R64, I64>;

extern "C" constexpr auto ISEL_XOR_MEMb_IMMb_80r6 [[gnu::used]] =
XOR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_XOR_GPR8_IMMb_80r6 [[gnu::used]] =
XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMz_8 [[gnu::used]] = XOR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMz_16 [[gnu::used]] =
XOR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMz_32 [[gnu::used]] =
XOR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMz_64 [[gnu::used]] =
XOR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMz_8 [[gnu::used]] = XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMz_16 [[gnu::used]] =
XOR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMz_32 [[gnu::used]] =
XOR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMz_64 [[gnu::used]] =
XOR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_XOR_MEMb_IMMb_82r6 [[gnu::used]] =
XOR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_XOR_GPR8_IMMb_82r6 [[gnu::used]] =
XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMb_8 [[gnu::used]] = XOR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMb_16 [[gnu::used]] =
XOR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMb_32 [[gnu::used]] =
XOR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_XOR_MEMv_IMMb_64 [[gnu::used]] =
XOR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMb_8 [[gnu::used]] = XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMb_16 [[gnu::used]] =
XOR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMb_32 [[gnu::used]] =
XOR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_XOR_GPRv_IMMb_64 [[gnu::used]] =
XOR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_XOR_MEMb_GPR8 [[gnu::used]] = XOR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_XOR_GPR8_GPR8_30 [[gnu::used]] =
XOR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_XOR_MEMv_GPRv_8 [[gnu::used]] = XOR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_XOR_MEMv_GPRv_16 [[gnu::used]] =
XOR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_XOR_MEMv_GPRv_32 [[gnu::used]] =
XOR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_XOR_MEMv_GPRv_64 [[gnu::used]] =
XOR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_31_8 [[gnu::used]] =
XOR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_31_16 [[gnu::used]] =
XOR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_31_32 [[gnu::used]] =
XOR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_31_64 [[gnu::used]] =
XOR<R64W, R64, R64>;
extern "C" constexpr auto ISEL_XOR_GPR8_GPR8_32 [[gnu::used]] =
XOR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_XOR_GPR8_MEMb [[gnu::used]] = XOR<R8W, R8, M8>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_33_8 [[gnu::used]] =
XOR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_33_16 [[gnu::used]] =
XOR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_33_32 [[gnu::used]] =
XOR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_XOR_GPRv_GPRv_33_64 [[gnu::used]] =
XOR<R64W, R64, R64>;
extern "C" constexpr auto ISEL_XOR_GPRv_MEMv_8 [[gnu::used]] = XOR<R8W, R8, M8>;
extern "C" constexpr auto ISEL_XOR_GPRv_MEMv_16 [[gnu::used]] =
XOR<R16W, R16, M16>;
extern "C" constexpr auto ISEL_XOR_GPRv_MEMv_32 [[gnu::used]] =
XOR<R32W, R32, M32>;
extern "C" constexpr auto ISEL_XOR_GPRv_MEMv_64 [[gnu::used]] =
XOR<R64W, R64, M64>;
extern "C" constexpr auto ISEL_XOR_AL_IMMb [[gnu::used]] = XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_OrAX_IMMz_8 [[gnu::used]] = XOR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_XOR_OrAX_IMMz_16 [[gnu::used]] =
XOR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_XOR_OrAX_IMMz_32 [[gnu::used]] =
XOR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_XOR_OrAX_IMMz_64 [[gnu::used]] =
XOR<R64W, R64, I64>;

extern "C" constexpr auto ISEL_NOT_MEMb [[gnu::used]] = NOT<M8W, M8>;
extern "C" constexpr auto ISEL_NOT_GPR8 [[gnu::used]] = NOT<R8W, R8>;
extern "C" constexpr auto ISEL_NOT_MEMv_8 [[gnu::used]] = NOT<M8W, M8>;
extern "C" constexpr auto ISEL_NOT_MEMv_16 [[gnu::used]] = NOT<M16W, M16>;
extern "C" constexpr auto ISEL_NOT_MEMv_32 [[gnu::used]] = NOT<M32W, M32>;
extern "C" constexpr auto ISEL_NOT_MEMv_64 [[gnu::used]] = NOT<M64W, M64>;
extern "C" constexpr auto ISEL_NOT_GPRv_8 [[gnu::used]] = NOT<R8W, R8>;
extern "C" constexpr auto ISEL_NOT_GPRv_16 [[gnu::used]] = NOT<R16W, R16>;
extern "C" constexpr auto ISEL_NOT_GPRv_32 [[gnu::used]] = NOT<R32W, R32>;
extern "C" constexpr auto ISEL_NOT_GPRv_64 [[gnu::used]] = NOT<R64W, R64>;

extern "C" constexpr auto ISEL_TEST_MEMb_IMMb_F6r0 [[gnu::used]] = TEST<M8, I8>;
extern "C" constexpr auto ISEL_TEST_MEMb_IMMb_F6r1 [[gnu::used]] = TEST<M8, I8>;
extern "C" constexpr auto ISEL_TEST_GPR8_IMMb_F6r0 [[gnu::used]] = TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_GPR8_IMMb_F6r1 [[gnu::used]] = TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r0_8 [[gnu::used]] =
TEST<M8, I8>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r0_16 [[gnu::used]] =
TEST<M16, I16>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r0_32 [[gnu::used]] =
TEST<M32, I32>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r0_64 [[gnu::used]] =
TEST<M64, I64>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r1_8 [[gnu::used]] =
TEST<M8, I8>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r1_16 [[gnu::used]] =
TEST<M16, I16>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r1_32 [[gnu::used]] =
TEST<M32, I32>;
extern "C" constexpr auto ISEL_TEST_MEMv_IMMz_F7r1_64 [[gnu::used]] =
TEST<M64, I64>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r0_8 [[gnu::used]] =
TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r0_16 [[gnu::used]] =
TEST<R16, I16>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r0_32 [[gnu::used]] =
TEST<R32, I32>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r0_64 [[gnu::used]] =
TEST<R64, I64>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r1_8 [[gnu::used]] =
TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r1_16 [[gnu::used]] =
TEST<R16, I16>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r1_32 [[gnu::used]] =
TEST<R32, I32>;
extern "C" constexpr auto ISEL_TEST_GPRv_IMMz_F7r1_64 [[gnu::used]] =
TEST<R64, I64>;
extern "C" constexpr auto ISEL_TEST_MEMb_GPR8 [[gnu::used]] = TEST<M8, R8>;
extern "C" constexpr auto ISEL_TEST_GPR8_GPR8 [[gnu::used]] = TEST<R8, R8>;
extern "C" constexpr auto ISEL_TEST_MEMv_GPRv_8 [[gnu::used]] = TEST<M8, R8>;
extern "C" constexpr auto ISEL_TEST_MEMv_GPRv_16 [[gnu::used]] = TEST<M16, R16>;
extern "C" constexpr auto ISEL_TEST_MEMv_GPRv_32 [[gnu::used]] = TEST<M32, R32>;
extern "C" constexpr auto ISEL_TEST_MEMv_GPRv_64 [[gnu::used]] = TEST<M64, R64>;
extern "C" constexpr auto ISEL_TEST_GPRv_GPRv_8 [[gnu::used]] = TEST<R8, R8>;
extern "C" constexpr auto ISEL_TEST_GPRv_GPRv_16 [[gnu::used]] = TEST<R16, R16>;
extern "C" constexpr auto ISEL_TEST_GPRv_GPRv_32 [[gnu::used]] = TEST<R32, R32>;
extern "C" constexpr auto ISEL_TEST_GPRv_GPRv_64 [[gnu::used]] = TEST<R64, R64>;
extern "C" constexpr auto ISEL_TEST_AL_IMMb [[gnu::used]] = TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_OrAX_IMMz_8 [[gnu::used]] = TEST<R8, I8>;
extern "C" constexpr auto ISEL_TEST_OrAX_IMMz_16 [[gnu::used]] = TEST<R16, I16>;
extern "C" constexpr auto ISEL_TEST_OrAX_IMMz_32 [[gnu::used]] = TEST<R32, I32>;
extern "C" constexpr auto ISEL_TEST_OrAX_IMMz_64 [[gnu::used]] = TEST<R64, I64>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PAND_64(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV64(memory, dst,
(UAndV64(_UReadV64(memory, src1), _UReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PAND(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV32(memory, dst,
(UAndV32(_UReadV32(memory, src1), _UReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PANDN_64(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory = _UWriteV64(
memory, dst,
(UAndNV64(_UReadV64(memory, src2), _UReadV64(memory, src1))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PANDN(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory = _UWriteV32(
memory, dst,
(UAndNV32(_UReadV32(memory, src2), _UReadV32(memory, src1))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POR_64(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV64(memory, dst,
(UOrV64(_UReadV64(memory, src1), _UReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV32(memory, dst,
(UOrV32(_UReadV32(memory, src1), _UReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PXOR_64(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV64(memory, dst,
(UXorV64(_UReadV64(memory, src1), _UReadV64(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PXOR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory =
_UWriteV32(memory, dst,
(UXorV32(_UReadV32(memory, src1), _UReadV32(memory, src2))));
} while (false);
return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PTEST(Memory *memory, State &state, S1 src1, S2 src2) {
auto lhs = _UReadV32(memory, src1);
auto rhs = _UReadV32(memory, src2);
auto res_and = UAndV32(rhs, lhs);
auto res_andn = UAndNV32(rhs, lhs);
auto res_and_ax = AccumulateUOrV32(res_and);
auto res_andn_ax = AccumulateUOrV32(res_andn);
state.aflag.zf = ZeroFlag(res_and_ax);
state.aflag.cf = ZeroFlag(res_andn_ax);
state.aflag.pf = false;
state.aflag.af = false;
state.aflag.sf = false;
state.aflag.of = false;
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PXOR_MMXq_MEMq [[gnu::used]] =
PXOR_64<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PXOR_MMXq_MMXq [[gnu::used]] =
PXOR_64<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PXOR_XMMdq_MEMdq [[gnu::used]] =
PXOR_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PXOR_XMMdq_XMMdq [[gnu::used]] =
PXOR_64<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPXOR_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PXOR<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VPXOR_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PXOR<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VPXOR_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PXOR<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VPXOR_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PXOR<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_XORPD_XMMpd_MEMpd [[gnu::used]] =
PXOR_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_XORPD_XMMpd_XMMpd [[gnu::used]] =
PXOR_64<V128W, V128, V128>;
extern "C" constexpr auto ISEL_XORPD_XMMxuq_MEMxuq [[gnu::used]] =
PXOR_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_XORPD_XMMxuq_XMMxuq [[gnu::used]] =
PXOR_64<V128W, V128, V128>;

extern "C" constexpr auto ISEL_XORPS_XMMps_MEMps [[gnu::used]] =
PXOR<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_XORPS_XMMps_XMMps [[gnu::used]] =
PXOR<V128W, V128, V128>;
extern "C" constexpr auto ISEL_XORPS_XMMxud_XMMxud [[gnu::used]] =
PXOR<V128W, V128, V128>;
extern "C" constexpr auto ISEL_XORPS_XMMxud_MEMxud [[gnu::used]] =
PXOR<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VXORPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PXOR_64<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VXORPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PXOR_64<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VXORPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PXOR_64<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VXORPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PXOR_64<VV256W, VV256, VV256>;
extern "C" constexpr auto ISEL_VXORPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PXOR<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VXORPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PXOR<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VXORPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PXOR<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VXORPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PXOR<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PAND_MMXq_MEMq [[gnu::used]] =
PAND_64<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PAND_MMXq_MMXq [[gnu::used]] =
PAND_64<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PAND_XMMdq_MEMdq [[gnu::used]] =
PAND<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PAND_XMMdq_XMMdq [[gnu::used]] =
PAND<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPAND_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PAND<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VPAND_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PAND<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VPAND_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PAND<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VPAND_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PAND<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_ANDPD_XMMpd_MEMpd [[gnu::used]] =
PAND_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDPD_XMMpd_XMMpd [[gnu::used]] =
PAND_64<V128W, V128, V128>;

extern "C" constexpr auto ISEL_ANDPD_XMMxuq_MEMxuq [[gnu::used]] =
PAND_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDPD_XMMxuq_XMMxuq [[gnu::used]] =
PAND_64<V128W, V128, V128>;

extern "C" constexpr auto ISEL_ANDPS_XMMps_MEMps [[gnu::used]] =
PAND<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDPS_XMMps_XMMps [[gnu::used]] =
PAND<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ANDPS_XMMxud_XMMxud [[gnu::used]] =
PAND<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ANDPS_XMMxud_MEMxud [[gnu::used]] =
PAND<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VANDPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PAND_64<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VANDPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PAND_64<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VANDPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PAND_64<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VANDPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PAND_64<VV256W, VV256, VV256>;
extern "C" constexpr auto ISEL_VANDPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PAND<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VANDPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PAND<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VANDPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PAND<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VANDPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PAND<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PANDN_MMXq_MEMq [[gnu::used]] =
PANDN_64<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PANDN_MMXq_MMXq [[gnu::used]] =
PANDN_64<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PANDN_XMMdq_MEMdq [[gnu::used]] =
PANDN<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PANDN_XMMdq_XMMdq [[gnu::used]] =
PANDN<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPANDN_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PANDN<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VPANDN_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PANDN<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VPANDN_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PANDN<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VPANDN_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PANDN<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_ANDNPD_XMMpd_MEMpd [[gnu::used]] =
PANDN_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDNPD_XMMpd_XMMpd [[gnu::used]] =
PANDN_64<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ANDNPD_XMMxuq_MEMxuq [[gnu::used]] =
PANDN_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDNPD_XMMxuq_XMMxuq [[gnu::used]] =
PANDN_64<V128W, V128, V128>;

extern "C" constexpr auto ISEL_ANDNPS_XMMps_MEMps [[gnu::used]] =
PANDN<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ANDNPS_XMMps_XMMps [[gnu::used]] =
PANDN<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ANDNPS_XMMxud_XMMxud [[gnu::used]] =
PANDN<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ANDNPS_XMMxud_MEMxud [[gnu::used]] =
PANDN<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VANDNPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PANDN_64<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VANDNPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PANDN_64<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VANDNPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PANDN_64<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VANDNPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PANDN_64<VV256W, VV256, VV256>;
extern "C" constexpr auto ISEL_VANDNPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PANDN<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VANDNPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PANDN<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VANDNPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PANDN<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VANDNPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PANDN<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_POR_MMXq_MEMq [[gnu::used]] =
POR_64<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_POR_MMXq_MMXq [[gnu::used]] =
POR_64<V64W, V64, V64>;
extern "C" constexpr auto ISEL_POR_XMMdq_MEMdq [[gnu::used]] =
POR<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_POR_XMMdq_XMMdq [[gnu::used]] =
POR<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPOR_XMMdq_XMMdq_MEMdq [[gnu::used]] =
POR<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VPOR_XMMdq_XMMdq_XMMdq [[gnu::used]] =
POR<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VPOR_YMMqq_YMMqq_MEMqq [[gnu::used]] =
POR<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VPOR_YMMqq_YMMqq_YMMqq [[gnu::used]] =
POR<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_ORPD_XMMpd_MEMpd [[gnu::used]] =
POR_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ORPD_XMMpd_XMMpd [[gnu::used]] =
POR_64<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ORPD_XMMxuq_MEMxuq [[gnu::used]] =
POR_64<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ORPD_XMMxuq_XMMxuq [[gnu::used]] =
POR_64<V128W, V128, V128>;

extern "C" constexpr auto ISEL_ORPS_XMMps_MEMps [[gnu::used]] =
POR<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ORPS_XMMps_XMMps [[gnu::used]] =
POR<V128W, V128, V128>;
extern "C" constexpr auto ISEL_ORPS_XMMxud_MEMxud [[gnu::used]] =
POR<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_ORPS_XMMxud_XMMxud [[gnu::used]] =
POR<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VORPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
POR_64<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VORPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
POR_64<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VORPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
POR_64<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VORPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
POR_64<VV256W, VV256, VV256>;
extern "C" constexpr auto ISEL_VORPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
POR<VV128W, VV128, MV128>;
extern "C" constexpr auto ISEL_VORPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
POR<VV128W, VV128, VV128>;
extern "C" constexpr auto ISEL_VORPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
POR<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VORPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
POR<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PTEST_XMMdq_MEMdq [[gnu::used]] =
PTEST<V128, MV128>;
extern "C" constexpr auto ISEL_PTEST_XMMdq_XMMdq [[gnu::used]] =
PTEST<V128, V128>;
extern "C" constexpr auto ISEL_VPTEST_XMMdq_MEMdq [[gnu::used]] =
PTEST<VV128, MV128>;
extern "C" constexpr auto ISEL_VPTEST_XMMdq_XMMdq [[gnu::used]] =
PTEST<VV128, VV128>;
extern "C" constexpr auto ISEL_VPTEST_YMMqq_MEMqq [[gnu::used]] =
PTEST<VV256, MV256>;
extern "C" constexpr auto ISEL_VPTEST_YMMqq_YMMqq [[gnu::used]] =
PTEST<VV256, VV256>;

#pragma clang diagnostic ignored "-Wpass-failed"

namespace {

template <typename D, typename S, typename DestType>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LEA(Memory *memory, State &state, D dst, S src) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(
static_cast<DestType>(AddressOf(src)))),
"Bad write!");
memory = _Write(
memory, dst,
(ZExtTo<decltype(dst)>(static_cast<DestType>(AddressOf(src)))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LEAVE_16BIT(Memory *memory, State &state) {
addr_t op_size = 2;
addr_t link_pointer = _Read(memory, state.gpr.rbp.qword);
addr_t base_pointer = _Read(memory, ReadPtr<addr_t>(link_pointer));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rbp.qword)>::BT) ==
sizeof(base_pointer),
"Bad write!");
memory = _Write(memory, state.gpr.rbp.qword, (base_pointer));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(link_pointer, op_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(link_pointer, op_size)));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LEAVE_FULL(Memory *memory, State &state) {
addr_t op_size = TruncTo<addr_t>(sizeof(T));
addr_t link_pointer = _Read(memory, state.gpr.rbp.qword);
addr_t base_pointer = _Read(memory, ReadPtr<addr_t>(link_pointer));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rbp.qword)>::BT) ==
sizeof(base_pointer),
"Bad write!");
memory = _Write(memory, state.gpr.rbp.qword, (base_pointer));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(link_pointer, op_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(link_pointer, op_size)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_LEA_GPRv_AGEN_16 [[gnu::used]] =
LEA<R16W, M8, uint16_t>;
extern "C" constexpr auto ISEL_LEA_GPRv_AGEN_32 [[gnu::used]] =
LEA<R32W, M8, uint32_t>;
extern "C" constexpr auto ISEL_LEA_GPRv_AGEN_64 [[gnu::used]] =
LEA<R64W, M8, uint64_t>;

extern "C" constexpr auto ISEL_LEAVE_16 [[gnu::used]] = LEAVE_16BIT;
extern "C" constexpr auto ISEL_LEAVE_64 [[gnu::used]] = LEAVE_FULL<I64>;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ENTER(Memory *memory, State &state, I16 src1, I8 src2) {
addr_t op_size = sizeof(T);
addr_t alloc_size = ZExtTo<addr_t>(_Read(memory, src1));
addr_t nesting_level = ZExtTo<addr_t>(URem(_Read(memory, src2), 32_u8));
addr_t xsp_temp = _Read(memory, state.gpr.rsp.qword);
addr_t frame_temp = USub(xsp_temp, op_size);
addr_t next_xsp =
USub(USub(frame_temp, UMul(op_size, nesting_level)), alloc_size);

do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<T>(next_xsp))>::BT) ==
sizeof(_Read(memory, ReadPtr<T>(next_xsp))),
"Bad write!");
memory = _Write(memory, WritePtr<T>(next_xsp),
(_Read(memory, ReadPtr<T>(next_xsp))));
} while (false);

addr_t xbp_temp = _Read(memory, state.gpr.rbp.qword);
addr_t xsp_after_push = USub(xsp_temp, op_size);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(xsp_after_push),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (xsp_after_push));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<T>(xsp_after_push))>::BT) ==
sizeof(TruncTo<T>(xbp_temp)),
"Bad write!");
memory =
_Write(memory, WritePtr<T>(xsp_after_push), (TruncTo<T>(xbp_temp)));
} while (false);
xsp_temp = xsp_after_push;

if (nesting_level) {
if (1 < nesting_level) {

#pragma unroll
for (addr_t i = 1; i <= (nesting_level - 1); ++i) {
xbp_temp = USub(xbp_temp, op_size);

xsp_after_push = USub(xsp_temp, op_size);
do {
static_assert(sizeof(typename BaseType<decltype(WritePtr<T>(
xsp_after_push))>::BT) ==
sizeof(_Read(memory, ReadPtr<T>(xbp_temp))),
"Bad write!");
memory = _Write(memory, WritePtr<T>(xsp_after_push),
(_Read(memory, ReadPtr<T>(xbp_temp))));
} while (false);
xsp_temp = xsp_after_push;
}
}

xsp_temp = xsp_after_push;
xsp_after_push = USub(xsp_temp, op_size);
do {
static_assert(sizeof(typename BaseType<decltype(WritePtr<addr_t>(
xsp_after_push))>::BT) == sizeof(frame_temp),
"Bad write!");
memory = _Write(memory, WritePtr<addr_t>(xsp_after_push), (frame_temp));
} while (false);
xsp_temp = xsp_after_push;
}

do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rbp.qword)>::BT) ==
sizeof(frame_temp),
"Bad write!");
memory = _Write(memory, state.gpr.rbp.qword, (frame_temp));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(USub(xsp_temp, alloc_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (USub(xsp_temp, alloc_size)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoNothing(Memory *memory, State &state) {
return memory;
}

template <typename... Args>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoNothingWithParam(Memory *memory, State &state, Args...) {
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCLFLUSH_MEMmprefetch(Memory *memory, State &state, M8) {
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMFENCE(Memory *memory, State &state) {
do {
memory = __remill_barrier_store_load(memory);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSFENCE(Memory *memory, State &state) {
do {
memory = __remill_barrier_store_store(memory);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLFENCE(Memory *memory, State &state) {
do {
memory = __remill_barrier_load_load(memory);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoXLAT(Memory *memory, State &state) {
addr_t base = _Read(memory, state.gpr.rbx.qword);
addr_t offset = ZExtTo<addr_t>(_Read(memory, state.gpr.rax.byte.low));
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(_Read(memory, ReadPtr<uint8_t>(UAdd(base, offset)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low,
(_Read(memory, ReadPtr<uint8_t>(UAdd(base, offset)))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCPUID(Memory *memory, State &state) {
return __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86CPUID);
}
} // namespace

extern "C" constexpr auto ISEL_ENTER_IMMw_IMMb_16 [[gnu::used]] =
ENTER<uint16_t>;

extern "C" constexpr auto ISEL_ENTER_IMMw_IMMb_64 [[gnu::used]] =
ENTER<uint64_t>;

extern "C" constexpr auto ISEL_PAUSE [[gnu::used]] = DoNothing;

extern "C" constexpr auto ISEL_CLFLUSH_MEMmprefetch [[gnu::used]] =
DoCLFLUSH_MEMmprefetch;

extern "C" constexpr auto ISEL_MFENCE [[gnu::used]] = DoMFENCE;

extern "C" constexpr auto ISEL_SFENCE [[gnu::used]] = DoSFENCE;

extern "C" constexpr auto ISEL_LFENCE [[gnu::used]] = DoLFENCE;

extern "C" constexpr auto ISEL_XLAT [[gnu::used]] = DoXLAT;

extern "C" constexpr auto ISEL_CPUID [[gnu::used]] = DoCPUID;

extern "C" constexpr auto ISEL_UD0_GPR32_MEMd [[gnu::used]] =
DoNothingWithParam<R32, M32, R64W>;

extern "C" constexpr auto ISEL_UD1_GPR32_MEMd [[gnu::used]] =
DoNothingWithParam<R32, M32, R64W>;

extern "C" constexpr auto ISEL_UD2 [[gnu::used]] = DoNothingWithParam<R64W>;

extern "C" constexpr auto ISEL_HLT [[gnu::used]] = DoNothingWithParam<R64W>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKHBW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = num_elems; i < (num_elems / 2); ++i, j -= 2) {
dst_vec =
UInsertV8(dst_vec, j - 1, UExtractV8(src2_vec, (num_elems - 1) - i));
dst_vec =
UInsertV8(dst_vec, j - 2, UExtractV8(src1_vec, (num_elems - 1) - i));
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKHWD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto src2_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = num_elems; i < (num_elems / 2); ++i, j -= 2) {
dst_vec =
UInsertV16(dst_vec, j - 1, UExtractV16(src2_vec, (num_elems - 1) - i));
dst_vec =
UInsertV16(dst_vec, j - 2, UExtractV16(src1_vec, (num_elems - 1) - i));
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKHDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto src2_vec = _UReadV32(memory, src2);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = num_elems; i < (num_elems / 2); ++i, j -= 2) {
dst_vec =
UInsertV32(dst_vec, j - 1, UExtractV32(src2_vec, (num_elems - 1) - i));
dst_vec =
UInsertV32(dst_vec, j - 2, UExtractV32(src1_vec, (num_elems - 1) - i));
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKHQDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = num_elems; i < (num_elems / 2); ++i, j -= 2) {
dst_vec =
UInsertV64(dst_vec, j - 1, UExtractV64(src2_vec, (num_elems - 1) - i));
dst_vec =
UInsertV64(dst_vec, j - 2, UExtractV64(src1_vec, (num_elems - 1) - i));
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKLBW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = 0; i < (num_elems / 2); ++i, j += 2) {
dst_vec = UInsertV8(dst_vec, j, UExtractV8(src1_vec, i));
dst_vec = UInsertV8(dst_vec, j + 1, UExtractV8(src2_vec, i));
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKLWD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto src2_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = 0; i < (num_elems / 2); ++i, j += 2) {
dst_vec = UInsertV16(dst_vec, j, UExtractV16(src1_vec, i));
dst_vec = UInsertV16(dst_vec, j + 1, UExtractV16(src2_vec, i));
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKLDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto src2_vec = _UReadV32(memory, src2);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = 0; i < (num_elems / 2); ++i, j += 2) {
dst_vec = UInsertV32(dst_vec, j, UExtractV32(src1_vec, i));
dst_vec = UInsertV32(dst_vec, j + 1, UExtractV32(src2_vec, i));
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUNPCKLQDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, j = 0; i < (num_elems / 2); ++i, j += 2) {
dst_vec = UInsertV64(dst_vec, j, UExtractV64(src1_vec, i));
dst_vec = UInsertV64(dst_vec, j + 1, UExtractV64(src2_vec, i));
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PUNPCKHBW_MMXq_MEMq [[gnu::used]] =
PUNPCKHBW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PUNPCKHBW_MMXq_MMXd [[gnu::used]] =
PUNPCKHBW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKHBW_XMMdq_MEMdq [[gnu::used]] =
PUNPCKHBW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKHBW_XMMdq_XMMq [[gnu::used]] =
PUNPCKHBW<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKHWD_MMXq_MEMq [[gnu::used]] =
PUNPCKHWD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PUNPCKHWD_MMXq_MMXd [[gnu::used]] =
PUNPCKHWD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKHWD_XMMdq_MEMdq [[gnu::used]] =
PUNPCKHWD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKHWD_XMMdq_XMMq [[gnu::used]] =
PUNPCKHWD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKHDQ_MMXq_MEMq [[gnu::used]] =
PUNPCKHDQ<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PUNPCKHDQ_MMXq_MMXd [[gnu::used]] =
PUNPCKHDQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKHDQ_XMMdq_MEMdq [[gnu::used]] =
PUNPCKHDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKHDQ_XMMdq_XMMq [[gnu::used]] =
PUNPCKHDQ<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKHQDQ_XMMdq_MEMdq [[gnu::used]] =
PUNPCKHQDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKHQDQ_XMMdq_XMMq [[gnu::used]] =
PUNPCKHQDQ<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKLBW_MMXq_MEMd [[gnu::used]] =
PUNPCKLBW<V64W, V64, MV32>;
extern "C" constexpr auto ISEL_PUNPCKLBW_MMXq_MMXd [[gnu::used]] =
PUNPCKLBW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKLBW_XMMdq_MEMdq [[gnu::used]] =
PUNPCKLBW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKLBW_XMMdq_XMMq [[gnu::used]] =
PUNPCKLBW<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKLWD_MMXq_MEMd [[gnu::used]] =
PUNPCKLWD<V64W, V64, MV32>;
extern "C" constexpr auto ISEL_PUNPCKLWD_MMXq_MMXd [[gnu::used]] =
PUNPCKLWD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKLWD_XMMdq_MEMdq [[gnu::used]] =
PUNPCKLWD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKLWD_XMMdq_XMMq [[gnu::used]] =
PUNPCKLWD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKLDQ_MMXq_MEMd [[gnu::used]] =
PUNPCKLDQ<V64W, V64, MV32>;
extern "C" constexpr auto ISEL_PUNPCKLDQ_MMXq_MMXd [[gnu::used]] =
PUNPCKLDQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PUNPCKLDQ_XMMdq_MEMdq [[gnu::used]] =
PUNPCKLDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKLDQ_XMMdq_XMMq [[gnu::used]] =
PUNPCKLDQ<V128W, V128, V128>;

extern "C" constexpr auto ISEL_PUNPCKLQDQ_XMMdq_MEMdq [[gnu::used]] =
PUNPCKLQDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PUNPCKLQDQ_XMMdq_XMMq [[gnu::used]] =
PUNPCKLQDQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPUNPCKLQDQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PUNPCKLQDQ<V128W, V128, V128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
do {
memory = _UWriteV8(
memory, dst, (UAddV8(_UReadV8(memory, src1), _UReadV8(memory, src2))));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV16(memory, src1);
auto rhs_vec = _UReadV16(memory, src2);
auto dst_vec = UAddV16(lhs_vec, rhs_vec);
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV32(memory, src1);
auto rhs_vec = _UReadV32(memory, src2);
auto dst_vec = UAddV32(lhs_vec, rhs_vec);
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV64(memory, src1);
auto rhs_vec = _UReadV64(memory, src2);
auto dst_vec = UAddV64(lhs_vec, rhs_vec);
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PADDB_MMXq_MMXq [[gnu::used]] =
PADDB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDB_MMXq_MEMq [[gnu::used]] =
PADDB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDB_XMMdq_XMMdq [[gnu::used]] =
PADDB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDB_XMMdq_MEMdq [[gnu::used]] =
PADDB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_VPADDB_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PADDB<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PADDW_MMXq_MMXq [[gnu::used]] =
PADDW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDW_MMXq_MEMq [[gnu::used]] =
PADDW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDW_XMMdq_XMMdq [[gnu::used]] =
PADDW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDW_XMMdq_MEMdq [[gnu::used]] =
PADDW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PADDD_MMXq_MMXq [[gnu::used]] =
PADDD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDD_MMXq_MEMq [[gnu::used]] =
PADDD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDD_XMMdq_XMMdq [[gnu::used]] =
PADDD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDD_XMMdq_MEMdq [[gnu::used]] =
PADDD<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_VPADDD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PADDD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PADDQ_MMXq_MMXq [[gnu::used]] =
PADDQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDQ_MMXq_MEMq [[gnu::used]] =
PADDQ<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDQ_XMMdq_XMMdq [[gnu::used]] =
PADDQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDQ_XMMdq_MEMdq [[gnu::used]] =
PADDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPADDQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PADDQ<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPADDQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PADDQ<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPADDQ_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PADDQ<VV256W, VV256, MV256>;
extern "C" constexpr auto ISEL_VPADDQ_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PADDQ<VV256W, VV256, VV256>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDSB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV8(memory, src1);
auto src2_vec = _SReadV8(memory, src2);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
index++) {
auto v1 = SExtractV8(src1_vec, index);
auto v2 = SExtractV8(src2_vec, index);
auto max = SExt(Maximize(v1));
auto min = SExt(Minimize(v1));
auto sum = SAdd(SExt(v1), SExt(v2));
auto upper_limit = Select(SCmpLt(sum, max), sum, max);
auto lower_limit = Select(SCmpGte(sum, min), sum, min);
sum = Select(SCmpLt(sum, decltype(sum)(0)), lower_limit, upper_limit);
dst_vec = SInsertV8(dst_vec, index, Trunc(sum));
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);

auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
index++) {
auto v1 = SExtractV16(src1_vec, index);
auto v2 = SExtractV16(src2_vec, index);
auto max = SExt(Maximize(v1));
auto min = SExt(Minimize(v1));
auto sum = SAdd(SExt(v1), SExt(v2));
auto upper_limit = Select(SCmpLt(sum, max), sum, max);
auto lower_limit = Select(SCmpGte(sum, min), sum, min);
sum = Select(SCmpLt(sum, decltype(sum)(0)), lower_limit, upper_limit);
dst_vec = SInsertV16(dst_vec, index, Trunc(sum));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PADDSB_MMXq_MMXq [[gnu::used]] =
PADDSB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDSB_MMXq_MEMq [[gnu::used]] =
PADDSB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDSB_XMMdq_XMMdq [[gnu::used]] =
PADDSB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDSB_XMMdq_MEMdq [[gnu::used]] =
PADDSB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PADDSW_MMXq_MMXq [[gnu::used]] =
PADDSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PADDSW_MMXq_MEMq [[gnu::used]] =
PADDSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PADDSW_XMMdq_XMMdq [[gnu::used]] =
PADDSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDSW_XMMdq_MEMdq [[gnu::used]] =
PADDSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDUSB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto num_groups =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < num_groups; ++i) {
auto v1 = UExtractV8(src1_vec, i);
auto v2 = UExtractV8(src2_vec, i);
uint8_t v_sum = v1 + v2;
v_sum = Select(v_sum < v1, static_cast<uint8_t>(-1), v_sum);
dst_vec.elems[i] = v_sum;
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PADDUSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto src2_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();
auto num_groups =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < num_groups; ++i) {
auto v1 = UExtractV16(src1_vec, i);
auto v2 = UExtractV16(src2_vec, i);
uint16_t v_sum = v1 + v2;
v_sum = Select(v_sum < v1, static_cast<uint16_t>(-1), v_sum);
dst_vec.elems[i] = v_sum;
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PADDUSB_XMMdq_XMMdq [[gnu::used]] =
PADDUSB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDUSB_XMMdq_MEMdq [[gnu::used]] =
PADDUSB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PADDUSW_XMMdq_XMMdq [[gnu::used]] =
PADDUSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PADDUSW_XMMdq_MEMdq [[gnu::used]] =
PADDUSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PHADDW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t index = 0; index < vec_count; index += 2) {
auto v1 = SExtractV16(lhs_vec, index);
auto v2 = SExtractV16(lhs_vec, index + 1);
auto i = UDiv(UInt32(index), UInt32(2));
dst_vec = SInsertV16(dst_vec, i, SAdd(v1, v2));
}

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
index += 2) {
auto v1 = SExtractV16(rhs_vec, index);
auto v2 = SExtractV16(rhs_vec, index + 1);
auto i = UAdd(UInt32(index), UInt32(vec_count));
i = UDiv(i, 2);
dst_vec = SInsertV16(dst_vec, i, SAdd(v1, v2));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PHADDD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV32(memory, src1);
auto rhs_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t index = 0; index < vec_count; index += 2) {
auto v1 = SExtractV32(lhs_vec, index);
auto v2 = SExtractV32(lhs_vec, index + 1);
auto i = UDiv(UInt32(index), UInt32(2));
dst_vec = SInsertV32(dst_vec, i, SAdd(v1, v2));
}

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
index += 2) {
auto v1 = SExtractV32(rhs_vec, index);
auto v2 = SExtractV32(rhs_vec, index + 1);
auto i = UDiv(UAdd(UInt32(index), UInt32(vec_count)), UInt32(2));
dst_vec = SInsertV32(dst_vec, i, SAdd(v1, v2));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PHADDW_MMXq_MMXq [[gnu::used]] =
PHADDW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PHADDW_MMXq_MEMq [[gnu::used]] =
PHADDW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PHADDW_XMMdq_XMMdq [[gnu::used]] =
PHADDW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PHADDW_XMMdq_MEMdq [[gnu::used]] =
PHADDW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PHADDD_MMXq_MMXq [[gnu::used]] =
PHADDD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PHADDD_MMXq_MEMq [[gnu::used]] =
PHADDD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PHADDD_XMMdq_XMMdq [[gnu::used]] =
PHADDD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PHADDD_XMMdq_MEMdq [[gnu::used]] =
PHADDD<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_VPHADDD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PHADDD<VV256W, VV256, VV256>;

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PHADDSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t index = 0; index < vec_count; index += 2) {
auto add_elem =
SAdd(SExtractV16(src1_vec, index), SExtractV16(src1_vec, index + 1));
auto or_elem =
SOr(SExtractV16(src1_vec, index), SExtractV16(src1_vec, index + 1));
auto and_elem =
SAnd(SExtractV16(src1_vec, index), SExtractV16(src1_vec, index + 1));
auto tmp =
Select(SCmpLt(SAnd(add_elem, SNot(or_elem)), decltype(add_elem)(0)),
Maximize(add_elem), add_elem);
auto value =
Select(SCmpLt(SAnd(SNot(add_elem), and_elem), decltype(add_elem)(0)),
decltype(add_elem)(0x8000), tmp);
dst_vec = SInsertV16(dst_vec, index / 2, value);
}

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);
index += 2) {
auto add_elem =
SAdd(SExtractV16(src2_vec, index), SExtractV16(src2_vec, index + 1));
auto or_elem =
SOr(SExtractV16(src2_vec, index), SExtractV16(src2_vec, index + 1));
auto and_elem =
SAnd(SExtractV16(src2_vec, index), SExtractV16(src2_vec, index + 1));
auto tmp =
Select(SCmpLt(SAnd(add_elem, SNot(or_elem)), decltype(add_elem)(0)),
Maximize(add_elem), add_elem);
auto value =
Select(SCmpLt(SAnd(SNot(add_elem), and_elem), decltype(add_elem)(0)),
decltype(add_elem)(0x8000), tmp);
dst_vec = SInsertV16(dst_vec, (index + vec_count) / 2, value);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

extern "C" constexpr auto ISEL_PHADDSW_MMXq_MMXq [[gnu::used]] =
PHADDSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PHADDSW_MMXq_MEMq [[gnu::used]] =
PHADDSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PHADDSW_XMMdq_XMMdq [[gnu::used]] =
PHADDSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PHADDSW_XMMdq_MEMdq [[gnu::used]] =
PHADDSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV8(memory, src1);
auto rhs_vec = _SReadV8(memory, src2);
auto dst_vec = SSubV8(lhs_vec, rhs_vec);
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = SSubV16(lhs_vec, rhs_vec);
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV32(memory, src1);
auto rhs_vec = _SReadV32(memory, src2);
auto dst_vec = SSubV32(lhs_vec, rhs_vec);
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV64(memory, src1);
auto rhs_vec = _SReadV64(memory, src2);
auto dst_vec = SSubV64(lhs_vec, rhs_vec);
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSUBB_MMXq_MMXq [[gnu::used]] =
PSUBB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBB_MMXq_MEMq [[gnu::used]] =
PSUBB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBB_XMMdq_XMMdq [[gnu::used]] =
PSUBB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBB_XMMdq_MEMdq [[gnu::used]] =
PSUBB<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSUBB_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PSUBB<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PSUBW_MMXq_MMXq [[gnu::used]] =
PSUBW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBW_MMXq_MEMq [[gnu::used]] =
PSUBW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBW_XMMdq_XMMdq [[gnu::used]] =
PSUBW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBW_XMMdq_MEMdq [[gnu::used]] =
PSUBW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSUBD_MMXq_MMXq [[gnu::used]] =
PSUBD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBD_MMXq_MEMq [[gnu::used]] =
PSUBD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBD_XMMdq_XMMdq [[gnu::used]] =
PSUBD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBD_XMMdq_MEMdq [[gnu::used]] =
PSUBD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSUBD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PSUBD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSUBD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PSUBD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPSUBD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PSUBD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PSUBQ_MMXq_MMXq [[gnu::used]] =
PSUBQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBQ_MMXq_MEMq [[gnu::used]] =
PSUBQ<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBQ_XMMdq_XMMdq [[gnu::used]] =
PSUBQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBQ_XMMdq_MEMdq [[gnu::used]] =
PSUBQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSUBQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PSUBQ<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSUBQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PSUBQ<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPSUBQ_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PSUBQ<VV256W, VV256, VV256>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBUSB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV8(memory, src1);
auto rhs_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems); i++) {
auto v1 = UExtractV8(lhs_vec, i);
auto v2 = UExtractV8(rhs_vec, i);
auto sub = USub(v1, v2);
auto sub_val = Select(UCmpGt(v1, v2), sub, Minimize(v1));
dst_vec = UInsertV8(dst_vec, i, sub_val);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSUBUSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV16(memory, src1);
auto rhs_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems); i++) {
auto v1 = UExtractV16(lhs_vec, i);
auto v2 = UExtractV16(rhs_vec, i);
auto sub = USub(v1, v2);
auto sub_val = Select(UCmpGt(v1, v2), sub, Minimize(v1));
dst_vec = UInsertV16(dst_vec, i, sub_val);
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSUBUSB_MMXq_MMXq [[gnu::used]] =
PSUBUSB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBUSB_MMXq_MEMq [[gnu::used]] =
PSUBUSB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBUSB_XMMdq_XMMdq [[gnu::used]] =
PSUBUSB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBUSB_XMMdq_MEMdq [[gnu::used]] =
PSUBUSB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSUBUSW_MMXq_MMXq [[gnu::used]] =
PSUBUSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSUBUSW_MMXq_MEMq [[gnu::used]] =
PSUBUSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSUBUSW_XMMdq_XMMdq [[gnu::used]] =
PSUBUSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSUBUSW_XMMdq_MEMdq [[gnu::used]] =
PSUBUSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PAVGB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV8(memory, src1);
auto rhs_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV8(lhs_vec, i);
auto v2 = UExtractV8(rhs_vec, i);
auto sum_elem = UAdd(ZExt(v1), ZExt(v2));
auto sum = UAdd(sum_elem, decltype(sum_elem)(1));
dst_vec = UInsertV8(dst_vec, i, UInt8(UShr(sum, decltype(sum)(1))));
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PAVGW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV16(memory, src1);
auto rhs_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = ZExt(UExtractV16(lhs_vec, i));
auto v2 = ZExt(UExtractV16(rhs_vec, i));
auto sum_elem = UAdd(v1, v2);
auto sum = UAdd(sum_elem, decltype(sum_elem)(1));
dst_vec = UInsertV16(dst_vec, i, Trunc(UShr(sum, decltype(sum)(1))));
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PAVGB_MMXq_MMXq [[gnu::used]] =
PAVGB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PAVGB_MMXq_MEMq [[gnu::used]] =
PAVGB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PAVGB_XMMdq_XMMdq [[gnu::used]] =
PAVGB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PAVGB_XMMdq_MEMdq [[gnu::used]] =
PAVGB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PAVGW_MMXq_MMXq [[gnu::used]] =
PAVGW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PAVGW_MMXq_MEMq [[gnu::used]] =
PAVGW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PAVGW_XMMdq_XMMdq [[gnu::used]] =
PAVGW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PAVGW_XMMdq_MEMdq [[gnu::used]] =
PAVGW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PHSUBW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i = i + 2) {
auto v1 = SExtractV16(lhs_vec, i);
auto v2 = SExtractV16(lhs_vec, i + 1);
auto index = UDiv(UInt32(i), UInt32(2));
dst_vec = SInsertV16(dst_vec, index, SSub(v1, v2));
}

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
i = i + 2) {
auto v1 = SExtractV16(rhs_vec, i);
auto v2 = SExtractV16(rhs_vec, i + 1);
auto index = UDiv(UAdd(UInt32(i), UInt32(vec_count)), UInt32(2));
dst_vec = SInsertV16(dst_vec, index, SSub(v1, v2));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PHSUBD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV32(memory, src1);
auto rhs_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i = i + 2) {
dst_vec =
SInsertV32(dst_vec, i / 2,
SSub(SExtractV32(lhs_vec, i), SExtractV32(lhs_vec, i + 1)));
}

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
i = i + 2) {
dst_vec =
SInsertV32(dst_vec, (i + vec_count) / 2,
SSub(SExtractV32(rhs_vec, i), SExtractV32(rhs_vec, i + 1)));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PHSUBW_MMXq_MMXq [[gnu::used]] =
PHSUBW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PHSUBW_MMXq_MEMq [[gnu::used]] =
PHSUBW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PHSUBW_XMMdq_XMMdq [[gnu::used]] =
PHSUBW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PHSUBW_XMMdq_MEMdq [[gnu::used]] =
PHSUBW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PHSUBD_MMXq_MMXq [[gnu::used]] =
PHSUBD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PHSUBD_MMXq_MEMq [[gnu::used]] =
PHSUBD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PHSUBD_XMMdq_XMMdq [[gnu::used]] =
PHSUBD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PHSUBD_XMMdq_MEMdq [[gnu::used]] =
PHSUBD<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMAXSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto max = Select(SCmpGt(SExtractV16(lhs_vec, i), SExtractV16(rhs_vec, i)),
SExtractV16(lhs_vec, i), SExtractV16(rhs_vec, i));
dst_vec = SInsertV16(dst_vec, i, max);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMAXSW_MMXq_MMXq [[gnu::used]] =
PMAXSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMAXSW_MMXq_MEMq [[gnu::used]] =
PMAXSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMAXSW_XMMdq_XMMdq [[gnu::used]] =
PMAXSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMAXSW_XMMdq_MEMdq [[gnu::used]] =
PMAXSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMAXUB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV8(memory, src1);
auto rhs_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto max = Select(UCmpGt(UExtractV8(lhs_vec, i), UExtractV8(rhs_vec, i)),
UExtractV8(lhs_vec, i), UExtractV8(rhs_vec, i));
dst_vec = UInsertV8(dst_vec, i, max);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMAXUB_MMXq_MMXq [[gnu::used]] =
PMAXUB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMAXUB_MMXq_MEMq [[gnu::used]] =
PMAXUB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMAXUB_XMMdq_XMMdq [[gnu::used]] =
PMAXUB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMAXUB_XMMdq_MEMdq [[gnu::used]] =
PMAXUB<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMINSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto max = Select(SCmpLt(SExtractV16(lhs_vec, i), SExtractV16(rhs_vec, i)),
SExtractV16(lhs_vec, i), SExtractV16(rhs_vec, i));
dst_vec = SInsertV16(dst_vec, i, max);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMINSW_MMXq_MMXq [[gnu::used]] =
PMINSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMINSW_MMXq_MEMq [[gnu::used]] =
PMINSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMINSW_XMMdq_XMMdq [[gnu::used]] =
PMINSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMINSW_XMMdq_MEMdq [[gnu::used]] =
PMINSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMINUB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV8(memory, src1);
auto rhs_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto max = Select(UCmpLt(UExtractV8(lhs_vec, i), UExtractV8(rhs_vec, i)),
UExtractV8(lhs_vec, i), UExtractV8(rhs_vec, i));
dst_vec = UInsertV8(dst_vec, i, max);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMINUB_MMXq_MMXq [[gnu::used]] =
PMINUB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMINUB_MMXq_MEMq [[gnu::used]] =
PMINUB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMINUB_XMMdq_XMMdq [[gnu::used]] =
PMINUB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMINUB_XMMdq_MEMdq [[gnu::used]] =
PMINUB<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULHRSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto mul =
SMul(Int32(SExtractV16(lhs_vec, i)), Int32(SExtractV16(rhs_vec, i)));
auto temp = SAdd(SShr(mul, decltype(mul)(14)), decltype(mul)(1));
temp = SShr(temp, decltype(temp)(1));
dst_vec = SInsertV16(dst_vec, i, Int16(temp));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMULHRSW_MMXq_MMXq [[gnu::used]] =
PMULHRSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMULHRSW_MMXq_MEMq [[gnu::used]] =
PMULHRSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMULHRSW_XMMdq_XMMdq [[gnu::used]] =
PMULHRSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMULHRSW_XMMdq_MEMdq [[gnu::used]] =
PMULHRSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMADDWD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _SReadV16(memory, src1);
auto rhs_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i += 2) {
auto mul1 =
SMul(Int32(SExtractV16(lhs_vec, i)), Int32(SExtractV16(rhs_vec, i)));
auto mul2 = SMul(Int32(SExtractV16(lhs_vec, i + 1)),
Int32(SExtractV16(rhs_vec, i + 1)));
dst_vec = SInsertV32(dst_vec, i / 2, SAdd(mul1, mul2));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMADDWD_MMXq_MMXq [[gnu::used]] =
PMADDWD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMADDWD_MMXq_MEMq [[gnu::used]] =
PMADDWD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMADDWD_XMMdq_XMMdq [[gnu::used]] =
PMADDWD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMADDWD_XMMdq_MEMdq [[gnu::used]] =
PMADDWD<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMADDUBSW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _UReadV8(memory, src1);
auto rhs_vec = _SReadV8(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i += 2) {
auto mul1 =
SMul(Int16(UExtractV8(lhs_vec, i)), Int16(SExtractV8(rhs_vec, i)));
auto mul2 = SMul(Int16(UExtractV8(lhs_vec, i + 1)),
Int16(SExtractV8(rhs_vec, i + 1)));
auto add_elem = SAdd(mul2, mul1);
auto or_elem = SOr(mul2, mul1);
auto and_elem = SAnd(mul2, mul1);
auto tmp =
Select(SCmpLt(SAnd(add_elem, SNot(or_elem)), decltype(add_elem)(0)),
decltype(add_elem)(0x7FFF), add_elem);
auto value =
Select(SCmpLt(SAnd(SNot(add_elem), and_elem), decltype(add_elem)(0)),
decltype(add_elem)(0x8000), tmp);
dst_vec = SInsertV16(dst_vec, i / 2, value);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMADDUBSW_MMXq_MMXq [[gnu::used]] =
PMADDUBSW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMADDUBSW_MMXq_MEMq [[gnu::used]] =
PMADDUBSW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMADDUBSW_XMMdq_XMMdq [[gnu::used]] =
PMADDUBSW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMADDUBSW_XMMdq_MEMdq [[gnu::used]] =
PMADDUBSW<V128W, V128, MV128>;

namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PABSB(Memory *memory, State &state, D dst, S1 src1) {
auto src_vec = _SReadV8(memory, src1);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto src_entry = SExtractV8(src_vec, i);
auto mask = SShr(src_entry, decltype(src_entry)(7));
auto abs_value = SSub(SXor(src_entry, mask), mask);
dst_vec = SInsertV8(dst_vec, i, abs_value);
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PABSW(Memory *memory, State &state, D dst, S1 src1) {
auto src_vec = _SReadV16(memory, src1);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto src_entry = SExtractV16(src_vec, i);
auto mask = SShr(src_entry, decltype(src_entry)(15));
auto abs_value = SSub(SXor(src_entry, mask), mask);
dst_vec = SInsertV16(dst_vec, i, abs_value);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PABSD(Memory *memory, State &state, D dst, S1 src1) {
auto src_vec = _SReadV32(memory, src1);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto src_entry = SExtractV32(src_vec, i);
auto mask = SShr(src_entry, decltype(src_entry)(31));
auto abs_value = SSub(SXor(src_entry, mask), mask);
dst_vec = SInsertV32(dst_vec, i, abs_value);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PABSB_MMXq_MMXq [[gnu::used]] = PABSB<V64W, V64>;
extern "C" constexpr auto ISEL_PABSB_MMXq_MEMq [[gnu::used]] =
PABSB<V64W, MV64>;
extern "C" constexpr auto ISEL_PABSB_XMMdq_XMMdq [[gnu::used]] =
PABSB<V128W, V128>;
extern "C" constexpr auto ISEL_PABSB_XMMdq_MEMdq [[gnu::used]] =
PABSB<V128W, MV128>;

extern "C" constexpr auto ISEL_PABSW_MMXq_MMXq [[gnu::used]] = PABSW<V64W, V64>;
extern "C" constexpr auto ISEL_PABSW_MMXq_MEMq [[gnu::used]] =
PABSW<V64W, MV64>;
extern "C" constexpr auto ISEL_PABSW_XMMdq_XMMdq [[gnu::used]] =
PABSW<V128W, V128>;
extern "C" constexpr auto ISEL_PABSW_XMMdq_MEMdq [[gnu::used]] =
PABSW<V128W, MV128>;

extern "C" constexpr auto ISEL_PABSD_MMXq_MMXq [[gnu::used]] = PABSD<V64W, V64>;
extern "C" constexpr auto ISEL_PABSD_MMXq_MEMq [[gnu::used]] =
PABSD<V64W, MV64>;
extern "C" constexpr auto ISEL_PABSD_XMMdq_XMMdq [[gnu::used]] =
PABSD<V128W, V128>;
extern "C" constexpr auto ISEL_PABSD_XMMdq_MEMdq [[gnu::used]] =
PABSD<V128W, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PACKSSWB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto v2 = SExtractV8(dst_vec, i);
auto value =
Select(SCmpGt(v1, SExt(Maximize(v2))), Maximize(v2), Trunc(v1));
value = Select(SCmpLt(v1, SExt(Minimize(v2))), Minimize(v2), value);
dst_vec = SInsertV8(dst_vec, i, value);
}

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);
i++) {
auto v1 = SExtractV16(src2_vec, i);
auto v2 = SExtractV8(dst_vec, i);
auto value =
Select(SCmpGt(v1, SExt(Maximize(v2))), Maximize(v2), Trunc(v1));
value = Select(SCmpLt(v1, SExt(Minimize(v2))), Minimize(v2), value);
dst_vec = SInsertV8(dst_vec, i + vec_count, value);
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PACKSSWB_MMXq_MMXq [[gnu::used]] =
PACKSSWB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PACKSSWB_MMXq_MEMq [[gnu::used]] =
PACKSSWB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PACKSSWB_XMMdq_XMMdq [[gnu::used]] =
PACKSSWB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PACKSSWB_XMMdq_MEMdq [[gnu::used]] =
PACKSSWB<V128W, V128, MV128>;

namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PACKSSDW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
auto v2 = SExtractV16(dst_vec, i);
auto value =
Select(SCmpGt(v1, SExt(Maximize(v2))), Maximize(v2), Trunc(v1));
value = Select(SCmpLt(v1, SExt(Minimize(v2))), Minimize(v2), value);
dst_vec = SInsertV16(dst_vec, i, value);
}

#pragma unroll
for (size_t i = 0;
i < static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);
i++) {
auto v1 = SExtractV32(src2_vec, i);
auto v2 = SExtractV16(dst_vec, i);
auto value =
Select(SCmpGt(v1, SExt(Maximize(v2))), Maximize(v2), Trunc(v1));
value = Select(SCmpLt(v1, SExt(Minimize(v2))), Minimize(v2), value);
dst_vec = SInsertV16(dst_vec, i + vec_count, value);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PACKSSDW_MMXq_MMXq [[gnu::used]] =
PACKSSDW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PACKSSDW_MMXq_MEMq [[gnu::used]] =
PACKSSDW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PACKSSDW_XMMdq_XMMdq [[gnu::used]] =
PACKSSDW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PACKSSDW_XMMdq_MEMdq [[gnu::used]] =
PACKSSDW<V128W, V128, MV128>;

namespace {
template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PEXTRB(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto count = _Read(memory, src2);
auto vec_count =
UInt8(static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems));
auto sel_index = URem(count, vec_count);
auto word = UExtractV8(src1_vec, sel_index);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(word)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(word)));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PEXTRW(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto count = _Read(memory, src2);
auto vec_count =
UInt8(static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems));
auto sel_index = URem(count, vec_count);
auto word = UExtractV16(src1_vec, sel_index);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(word)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(word)));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PEXTRD(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto count = _Read(memory, src2);
auto vec_count =
UInt8(static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems));
auto sel_index = URem(count, vec_count);
auto word = UExtractV32(src1_vec, sel_index);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(word)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(word)));
} while (false);
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PEXTRQ(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto src1_vec = _UReadV64(memory, src1);
auto count = _Read(memory, src2);
auto vec_count =
UInt8(static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems));
auto sel_index = URem(count, vec_count);
auto word = UExtractV64(src1_vec, sel_index);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(word)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(word)));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PEXTRB_MEMb_XMMdq_IMMb [[gnu::used]] =
PEXTRB<M8W, V128>;
extern "C" constexpr auto ISEL_PEXTRB_GPR32d_XMMdq_IMMb [[gnu::used]] =
PEXTRB<R32W, V128>;
extern "C" constexpr auto ISEL_VPEXTRB_MEMb_XMMdq_IMMb [[gnu::used]] =
PEXTRB<M8W, V128>;
extern "C" constexpr auto ISEL_VPEXTRB_GPR32d_XMMdq_IMMb [[gnu::used]] =
PEXTRB<R32W, V128>;

extern "C" constexpr auto ISEL_PEXTRW_GPR32_MMXq_IMMb [[gnu::used]] =
PEXTRW<R32W, V64>;
extern "C" constexpr auto ISEL_PEXTRW_GPR32_XMMdq_IMMb [[gnu::used]] =
PEXTRW<R32W, V128>;
extern "C" constexpr auto ISEL_PEXTRW_SSE4_MEMw_XMMdq_IMMb [[gnu::used]] =
PEXTRW<M16W, V128>;
extern "C" constexpr auto ISEL_PEXTRW_SSE4_GPR32_XMMdq_IMMb [[gnu::used]] =
PEXTRW<R32W, V128>;
extern "C" constexpr auto ISEL_VPEXTRW_MEMw_XMMdq_IMMb [[gnu::used]] =
PEXTRW<M16W, V128>;
extern "C" constexpr auto ISEL_VPEXTRW_GPR32d_XMMdq_IMMb_15 [[gnu::used]] =
PEXTRW<R32W, V128>;
extern "C" constexpr auto ISEL_VPEXTRW_GPR32d_XMMdq_IMMb_C5 [[gnu::used]] =
PEXTRW<R32W, V128>;

extern "C" constexpr auto ISEL_PEXTRD_MEMd_XMMdq_IMMb [[gnu::used]] =
PEXTRD<M32W, V128>;
extern "C" constexpr auto ISEL_PEXTRD_GPR32d_XMMdq_IMMb [[gnu::used]] =
PEXTRD<R32W, V128>;
extern "C" constexpr auto ISEL_VPEXTRD_MEMd_XMMdq_IMMb [[gnu::used]] =
PEXTRD<M32W, V128>;
extern "C" constexpr auto ISEL_VPEXTRD_GPR32d_XMMdq_IMMb [[gnu::used]] =
PEXTRD<R32W, V128>;

extern "C" constexpr auto ISEL_PEXTRQ_MEMq_XMMdq_IMMb [[gnu::used]] =
PEXTRQ<M64W, V128>;
extern "C" constexpr auto ISEL_PEXTRQ_GPR64q_XMMdq_IMMb [[gnu::used]] =
PEXTRQ<R64W, V128>;
extern "C" constexpr auto ISEL_VPEXTRQ_MEMq_XMMdq_IMMb [[gnu::used]] =
PEXTRQ<M64W, V128>;
extern "C" constexpr auto ISEL_VPEXTRQ_GPR64q_XMMdq_IMMb [[gnu::used]] =
PEXTRQ<R64W, V128>;
namespace {
template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PALIGNR_64(Memory *memory, State &state, V64W dst, V64 src1, S2 src2, I8 imm1) {
auto src1_vec = _UReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto shift =
URem(static_cast<uint64_t>(UMul(_Read(memory, imm1), 0x8_u8)), 65_u64);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();

auto src1_elem = UExtractV64(src1_vec, 0);
auto src2_elem = UExtractV64(src2_vec, 0);
auto zero_shift = UCmpEq(shift, 0_u64);
auto max_shift = UCmpEq(shift, 64_u64);

auto src1_elem_high =
Select(zero_shift, 0_u64, UShl(src1_elem, USub(64_u64, shift)));

auto src2_elem_low = Select(max_shift, src1_elem, UShr(src2_elem, shift));

auto combined = UOr(src1_elem_high, src2_elem_low);
do {
memory = _UWriteV64(memory, dst, (UInsertV64(dst_vec, 0, combined)));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PALIGNR_128(Memory *memory, State &state, V128W dst, V128 src1, S2 src2,
I8 imm1) {
auto src1_vec = _UReadV128(memory, src1);
auto src2_vec = _UReadV128(memory, src2);
auto shift =
URem(static_cast<uint128_t>(UMul(_Read(memory, imm1), 0x8_u8)), 129_u128);
auto dst_vec = _ZeroVec<uint128_t, decltype(_UReadV128(memory, dst))>();

auto src1_elem = UExtractV128(src1_vec, 0);
auto src2_elem = UExtractV128(src2_vec, 0);
auto zero_shift = UCmpEq(shift, 0_u128);
auto max_shift = UCmpEq(shift, 128_u128);

auto src1_elem_high =
Select(zero_shift, 0_u128, UShl(src1_elem, USub(128_u128, shift)));
auto src2_elem_low = Select(max_shift, src1_elem, UShr(src2_elem, shift));

auto combined = UOr(src1_elem_high, src2_elem_low);
do {
memory = _UWriteV128(memory, dst, (UInsertV128(dst_vec, 0, combined)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PALIGNR_MMXq_MMXq_IMMb [[gnu::used]] =
PALIGNR_64<V64>;
extern "C" constexpr auto ISEL_PALIGNR_MMXq_MEMq_IMMb [[gnu::used]] =
PALIGNR_64<MV64>;
extern "C" constexpr auto ISEL_PALIGNR_XMMdq_XMMdq_IMMb [[gnu::used]] =
PALIGNR_128<V128>;
extern "C" constexpr auto ISEL_PALIGNR_XMMdq_MEMdq_IMMb [[gnu::used]] =
PALIGNR_128<MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV16(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(15)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV16(dst_vec, i, temp);
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLW_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV16(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(15)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV16(dst_vec, i, temp);
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV32(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(31)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV32(dst_vec, i, temp);
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLD_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV32(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(31)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV32(dst_vec, i, temp);
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV64(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV64(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(63)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV64(dst_vec, i, temp);
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLQ_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV64(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(63)),
static_cast<decltype(v1)>(0),
UShr(v1, static_cast<decltype(v1)>(count)));
dst_vec = UInsertV64(dst_vec, i, temp);
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRAW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
count = Select(UCmpGt(count, static_cast<decltype(count)>(15)),
static_cast<decltype(count)>(16), count);
dst_vec =
SInsertV16(dst_vec, i, SShr(v1, static_cast<decltype(v1)>(count)));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRAW_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
count = Select(UCmpGt(count, static_cast<decltype(count)>(15)),
static_cast<decltype(count)>(16), count);
dst_vec =
SInsertV16(dst_vec, i, SShr(v1, static_cast<decltype(v1)>(count)));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRAD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
count = Select(UCmpGt(count, static_cast<decltype(count)>(31)),
static_cast<decltype(count)>(32), count);
dst_vec =
SInsertV32(dst_vec, i, SShr(v1, static_cast<decltype(v1)>(count)));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRAD_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
count = Select(UCmpGt(count, static_cast<decltype(count)>(31)),
static_cast<decltype(count)>(32), count);
dst_vec =
SInsertV32(dst_vec, i, SShr(v1, static_cast<decltype(v1)>(count)));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSRLW_MMXq_IMMb [[gnu::used]] =
PSRLW<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSRLW_MMXq_MMXq [[gnu::used]] =
PSRLW<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSRLW_MMXq_MEMq [[gnu::used]] =
PSRLW<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSRLW_XMMdq_IMMb [[gnu::used]] =
PSRLW<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSRLW_XMMdq_XMMdq [[gnu::used]] =
PSRLW_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSRLW_XMMdq_MEMdq [[gnu::used]] =
PSRLW_V<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSRLD_MMXq_IMMb [[gnu::used]] =
PSRLD<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSRLD_MMXq_MMXq [[gnu::used]] =
PSRLD<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSRLD_MMXq_MEMq [[gnu::used]] =
PSRLD<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSRLD_XMMdq_IMMb [[gnu::used]] =
PSRLD<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSRLD_XMMdq_XMMdq [[gnu::used]] =
PSRLD_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSRLD_XMMdq_MEMdq [[gnu::used]] =
PSRLD_V<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSRLQ_MMXq_IMMb [[gnu::used]] =
PSRLQ<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSRLQ_MMXq_MMXq [[gnu::used]] =
PSRLQ<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSRLQ_MMXq_MEMq [[gnu::used]] =
PSRLQ<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSRLQ_XMMdq_IMMb [[gnu::used]] =
PSRLQ<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSRLQ_XMMdq_XMMdq [[gnu::used]] =
PSRLQ_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSRLQ_XMMdq_MEMdq [[gnu::used]] =
PSRLQ_V<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSRLQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PSRLQ_V<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSRLQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PSRLQ_V<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPSRLQ_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSRLQ<VV128W, V128, I8>;
extern "C" constexpr auto ISEL_VPSRLQ_YMMqq_YMMqq_IMMb [[gnu::used]] =
PSRLQ<VV256W, V256, I8>;
extern "C" constexpr auto ISEL_VPSRLQ_YMMqq_YMMqq_XMMq [[gnu::used]] =
PSRLQ_V<VV256W, V256, V128>;
extern "C" constexpr auto ISEL_VPSRLQ_YMMqq_YMMqq_MEMdq [[gnu::used]] =
PSRLQ_V<VV256W, V256, MV128>;
extern "C" constexpr auto ISEL_PSRAW_MMXq_IMMb [[gnu::used]] =
PSRAW<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSRAW_MMXq_MMXq [[gnu::used]] =
PSRAW<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSRAW_MMXq_MEMq [[gnu::used]] =
PSRAW<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSRAW_XMMdq_IMMb [[gnu::used]] =
PSRAW<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSRAW_XMMdq_XMMdq [[gnu::used]] =
PSRAW_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSRAW_XMMdq_MEMdq [[gnu::used]] =
PSRAW_V<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSRAD_MMXq_IMMb [[gnu::used]] =
PSRAD<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSRAD_MMXq_MMXq [[gnu::used]] =
PSRAD<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSRAD_MMXq_MEMq [[gnu::used]] =
PSRAD<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSRAD_XMMdq_IMMb [[gnu::used]] =
PSRAD<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSRAD_XMMdq_XMMdq [[gnu::used]] =
PSRAD_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSRAD_XMMdq_MEMdq [[gnu::used]] =
PSRAD_V<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(15)), 0_s16,
SShl(v1, static_cast<int16_t>(count)));
dst_vec = SInsertV16(dst_vec, i, temp);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLW_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto temp = Select(UCmpGt(count, 15_u64), 0_s16,
SShl(v1, static_cast<int16_t>(count)));
dst_vec = SInsertV16(dst_vec, i, temp);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(31)), 0_s32,
SShl(v1, static_cast<int32_t>(count)));
dst_vec = SInsertV32(dst_vec, i, temp);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLD_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
auto temp = Select(UCmpGt(count, 31_u64), 0_s32,
SShl(v1, static_cast<int32_t>(count)));
dst_vec = SInsertV32(dst_vec, i, temp);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV64(memory, src1);
auto count = _Read(memory, src2);
auto dst_vec = _ZeroVec<int64_t, decltype(_SReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV64(src1_vec, i);
auto temp = Select(UCmpGt(count, static_cast<decltype(count)>(63)), 0_s64,
SShl(v1, static_cast<int64_t>(count)));
dst_vec = SInsertV64(dst_vec, i, temp);
}
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLQ_V(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto count = UExtractV64(src2_vec, 0);
auto dst_vec = _ZeroVec<int64_t, decltype(_SReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV64(src1_vec, i);
auto temp = Select(UCmpGt(count, 63_u64), 0_s64,
SShl(v1, static_cast<int64_t>(count)));
dst_vec = SInsertV64(dst_vec, i, temp);
}
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSLLW_MMXq_IMMb [[gnu::used]] =
PSLLW<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSLLW_MMXq_MMXq [[gnu::used]] =
PSLLW<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSLLW_MMXq_MEMq [[gnu::used]] =
PSLLW<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSLLW_XMMdq_IMMb [[gnu::used]] =
PSLLW<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSLLW_XMMdq_XMMdq [[gnu::used]] =
PSLLW_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSLLW_XMMdq_MEMdq [[gnu::used]] =
PSLLW_V<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSLLD_MMXq_IMMb [[gnu::used]] =
PSLLD<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSLLD_MMXq_MMXq [[gnu::used]] =
PSLLD<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSLLD_MMXq_MEMq [[gnu::used]] =
PSLLD<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSLLD_XMMdq_IMMb [[gnu::used]] =
PSLLD<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSLLD_XMMdq_XMMdq [[gnu::used]] =
PSLLD_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSLLD_XMMdq_MEMdq [[gnu::used]] =
PSLLD_V<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSLLQ_MMXq_IMMb [[gnu::used]] =
PSLLQ<V64W, V64, I8>;
extern "C" constexpr auto ISEL_PSLLQ_MMXq_MMXq [[gnu::used]] =
PSLLQ<V64W, V64, R64>;
extern "C" constexpr auto ISEL_PSLLQ_MMXq_MEMq [[gnu::used]] =
PSLLQ<V64W, V64, M64>;
extern "C" constexpr auto ISEL_PSLLQ_XMMdq_IMMb [[gnu::used]] =
PSLLQ<V128W, V128, I8>;
extern "C" constexpr auto ISEL_PSLLQ_XMMdq_XMMdq [[gnu::used]] =
PSLLQ_V<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSLLQ_XMMdq_MEMdq [[gnu::used]] =
PSLLQ_V<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSLLQ_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSLLQ<VV128W, V128, I8>;
extern "C" constexpr auto ISEL_VPSLLQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PSLLQ_V<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPSLLQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PSLLQ_V<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSLLQ_YMMqq_YMMqq_IMMb [[gnu::used]] =
PSLLQ<VV256W, V256, I8>;
extern "C" constexpr auto ISEL_VPSLLQ_YMMqq_YMMqq_XMMq [[gnu::used]] =
PSLLQ_V<VV256W, V256, V128>;
extern "C" constexpr auto ISEL_VPSLLQ_YMMqq_YMMqq_MEMdq [[gnu::used]] =
PSLLQ_V<VV256W, V256, MV128>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSIGNB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV8(memory, src1);
auto src2_vec = _SReadV8(memory, src2);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV8(src1_vec, i);
auto v2 = SExtractV8(src2_vec, i);
auto is_neg = SignFlag(v2);
auto is_zero = ZeroFlag(v2);
auto value = Select(is_zero, 0_s8, Select(is_neg, SNeg(v1), v1));
dst_vec = SInsertV8(dst_vec, i, value);
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSIGNW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto v2 = SExtractV16(src2_vec, i);
auto is_neg = SignFlag(v2);
auto is_zero = ZeroFlag(v2);
auto value = Select(is_zero, 0_s16, Select(is_neg, SNeg(v1), v1));
dst_vec = SInsertV16(dst_vec, i, value);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSIGND(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
auto v2 = SExtractV32(src2_vec, i);
auto is_neg = SignFlag(v2);
auto is_zero = ZeroFlag(v2);
auto value = Select(is_zero, 0_s32, Select(is_neg, SNeg(v1), v1));
dst_vec = SInsertV32(dst_vec, i, value);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSIGNB_MMXq_MMXq [[gnu::used]] =
PSIGNB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSIGNB_MMXq_MEMq [[gnu::used]] =
PSIGNB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSIGNB_XMMdq_XMMdq [[gnu::used]] =
PSIGNB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSIGNB_XMMdq_MEMdq [[gnu::used]] =
PSIGNB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSIGNW_MMXq_MMXq [[gnu::used]] =
PSIGNW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSIGNW_MMXq_MEMq [[gnu::used]] =
PSIGNW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSIGNW_XMMdq_XMMdq [[gnu::used]] =
PSIGNW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSIGNW_XMMdq_MEMdq [[gnu::used]] =
PSIGNW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSIGND_MMXq_MMXq [[gnu::used]] =
PSIGND<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSIGND_MMXq_MEMq [[gnu::used]] =
PSIGND<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSIGND_XMMdq_XMMdq [[gnu::used]] =
PSIGND<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSIGND_XMMdq_MEMdq [[gnu::used]] =
PSIGND<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSHUFB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
uint8_t mask = static_cast<uint8_t>(vec_count - 1u);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
uint8_t v1 = UExtractV8(src2_vec, i);
uint8_t index = UAnd(v1, mask);
uint8_t v2 = UExtractV8(src1_vec, index);
uint8_t value = Select(SignFlag(v1), 0_u8, v2);
dst_vec = UInsertV8(dst_vec, i, value);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSHUFW(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto src_vec = _UReadV16(memory, src1);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();
auto order = _Read(memory, src2);

auto vec_count =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);

#pragma unroll
for (uint8_t i = 0; i < vec_count; i++) {
auto mask = UAnd(UShr(order, i), 3_u8);
auto v1 = UExtractV16(src_vec, mask);
dst_vec = UInsertV16(dst_vec, i, v1);
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSHUFB_MMXq_MMXq [[gnu::used]] =
PSHUFB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSHUFB_MMXq_MEMq [[gnu::used]] =
PSHUFB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSHUFB_XMMdq_XMMdq [[gnu::used]] =
PSHUFB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSHUFB_XMMdq_MEMdq [[gnu::used]] =
PSHUFB<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PSHUFW_MMXq_MMXq_IMMb [[gnu::used]] =
PSHUFW<V64W, V64>;
extern "C" constexpr auto ISEL_PSHUFW_MMXq_MEMq_IMMb [[gnu::used]] =
PSHUFW<V64W, MV64>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSADBW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto vec_count =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0, k = 0; i < vec_count; i++) {
uint16_t sum = 0;

#pragma unroll
for (size_t j = 0; j < 8UL; ++j, ++k) {
uint8_t v1 = UExtractV8(src1_vec, k);
uint8_t v2 = UExtractV8(src2_vec, k);
uint8_t abs_diff = Select(UCmpGte(v1, v2), USub(v1, v2), USub(v2, v1));
sum = UAdd(sum, ZExt(abs_diff));
}
dst_vec = UInsertV64(dst_vec, i, UInt64(sum));
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSADBW_MMXq_MMXq [[gnu::used]] =
PSADBW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PSADBW_MMXq_MEMq [[gnu::used]] =
PSADBW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PSADBW_XMMdq_XMMdq [[gnu::used]] =
PSADBW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PSADBW_XMMdq_MEMdq [[gnu::used]] =
PSADBW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_VPSADBW_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PSADBW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPSADBW_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PSADBW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VPSADBW_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PSADBW<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPSADBW_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PSADBW<VV256W, V256, V256>;

namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULUDQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV32(memory, src1);
auto src2_vec = _UReadV32(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count / 2; i++) {
auto v1 = ZExt(UExtractV32(src1_vec, i * 2));
auto v2 = ZExt(UExtractV32(src2_vec, i * 2));
auto mul = UMul(v1, v2);
dst_vec = UInsertV64(dst_vec, i, mul);
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULLD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV32(src1_vec, i);
auto v2 = SExtractV32(src2_vec, i);
auto mul = SMul(SExt(v1), SExt(v2));
dst_vec = SInsertV32(dst_vec, i, Trunc(mul));
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULLW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto v2 = SExtractV16(src2_vec, i);
auto mul = SMul(SExt(v1), SExt(v2));
dst_vec = SInsertV16(dst_vec, i, Trunc(mul));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULHW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = SExtractV16(src1_vec, i);
auto v2 = SExtractV16(src2_vec, i);
auto mul = SMul(SExt(v1), SExt(v2));
dst_vec = SInsertV16(dst_vec, i, Trunc(SShr(mul, 16_s32)));
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMULHUW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _UReadV16(memory, src1);
auto src2_vec = _UReadV16(memory, src2);
auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
auto v1 = UExtractV16(src1_vec, i);
auto v2 = UExtractV16(src2_vec, i);
auto mul = UMul(ZExt(v1), ZExt(v2));
dst_vec = UInsertV16(dst_vec, i, Trunc(UShr(mul, 16_u32)));
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMULUDQ_MMXq_MMXq [[gnu::used]] =
PMULUDQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMULUDQ_MMXq_MEMq [[gnu::used]] =
PMULUDQ<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMULUDQ_XMMdq_XMMdq [[gnu::used]] =
PMULUDQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMULUDQ_XMMdq_MEMdq [[gnu::used]] =
PMULUDQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPMULUDQ_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PMULUDQ<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_VPMULLD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PMULLD<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PMULLW_MMXq_MMXq [[gnu::used]] =
PMULLW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMULLW_MMXq_MEMq [[gnu::used]] =
PMULLW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMULLW_XMMdq_XMMdq [[gnu::used]] =
PMULLW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMULLW_XMMdq_MEMdq [[gnu::used]] =
PMULLW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPMULLW_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PMULLW<VV256W, VV256, VV256>;

extern "C" constexpr auto ISEL_PMULHW_MMXq_MMXq [[gnu::used]] =
PMULHW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMULHW_MMXq_MEMq [[gnu::used]] =
PMULHW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMULHW_XMMdq_XMMdq [[gnu::used]] =
PMULHW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMULHW_XMMdq_MEMdq [[gnu::used]] =
PMULHW<V128W, V128, MV128>;

extern "C" constexpr auto ISEL_PMULHUW_MMXq_MMXq [[gnu::used]] =
PMULHUW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PMULHUW_MMXq_MEMq [[gnu::used]] =
PMULHUW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PMULHUW_XMMdq_XMMdq [[gnu::used]] =
PMULHUW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PMULHUW_XMMdq_MEMdq [[gnu::used]] =
PMULHUW<V128W, V128, MV128>;

namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PMOVMSKB(Memory *memory, State &state, D dst, S src2) {
auto src_vec = _UReadV8(memory, src2);
uint32_t r32 = 0U;

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (size_t i = vec_count; i-- > 0;) {
auto v1 = UExtractV8(src_vec, i);
r32 = UOr(UShl(r32, 1_u32), static_cast<uint32_t>(UShr(v1, 7_u8)));
}
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(r32)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(r32)));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PMOVMSKB_GPR32_MMXq [[gnu::used]] =
PMOVMSKB<R32W, V64>;
extern "C" constexpr auto ISEL_PMOVMSKB_GPR32_XMMdq [[gnu::used]] =
PMOVMSKB<R32W, V128>;
extern "C" constexpr auto ISEL_VPMOVMSKB_GPR32d_XMMdq [[gnu::used]] =
PMOVMSKB<R32W, V128>;
extern "C" constexpr auto ISEL_VPMOVMSKB_GPR32d_YMMqq [[gnu::used]] =
PMOVMSKB<R32W, V256>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PINSRW(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto dst_vec = _UReadV16(memory, src1);
auto value = UInt16(_Read(memory, src2));
auto index = URem(
_Read(memory, src3),
UInt8(static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems)));
do {
memory = _UWriteV16(memory, dst, (UInsertV16(dst_vec, index, value)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMOVNTQ_MEMq_MMXq(Memory *memory, State &state, MV64W dst, V64 src1) {
do {
memory = _UWriteV64(memory, dst, (_UReadV64(memory, src1)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMASKMOVQ_MMXq_MMXq(Memory *memory, State &state, V64 src1, V64 src2) {
auto dst = VWritePtr<vec64_t>(_Read(memory, state.gpr.rdi.qword));
auto dst_vec = _UReadV8(memory, dst);
auto src1_vec = _UReadV8(memory, src1);
auto src2_vec = _UReadV8(memory, src2);
auto vec_count =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (size_t i = 0; i < vec_count; i++) {
uint8_t src_byte = UExtractV8(src1_vec, i);
uint8_t mask_byte = UExtractV8(src2_vec, i);
uint8_t mem_byte = UExtractV8(dst_vec, i);
uint8_t new_byte = Select(SignFlag(mask_byte), src_byte, mem_byte);
dst_vec = UInsertV8(dst_vec, i, new_byte);
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoEMMS(Memory *memory, State &state) {
state.mmx.elems[0].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[1].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[2].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[3].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[4].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[5].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[6].val.qwords.elems[0] = __remill_undefined_64();
state.mmx.elems[7].val.qwords.elems[0] = __remill_undefined_64();

state.st.elems[0].val = __remill_undefined_f80();
state.st.elems[1].val = __remill_undefined_f80();
state.st.elems[2].val = __remill_undefined_f80();
state.st.elems[3].val = __remill_undefined_f80();
state.st.elems[4].val = __remill_undefined_f80();
state.st.elems[5].val = __remill_undefined_f80();
state.st.elems[6].val = __remill_undefined_f80();
state.st.elems[7].val = __remill_undefined_f80();

return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PINSRW_MMXq_MEMw_IMMb [[gnu::used]] =
PINSRW<V64W, V64, M16>;
extern "C" constexpr auto ISEL_PINSRW_MMXq_GPR32_IMMb [[gnu::used]] =
PINSRW<V64W, V64, R32>;
extern "C" constexpr auto ISEL_PINSRW_XMMdq_MEMw_IMMb [[gnu::used]] =
PINSRW<V128W, V128, M16>;
extern "C" constexpr auto ISEL_PINSRW_XMMdq_GPR32_IMMb [[gnu::used]] =
PINSRW<V128W, V128, R32>;
extern "C" constexpr auto ISEL_VPINSRW_XMMdq_XMMdq_MEMw_IMMb [[gnu::used]] =
PINSRW<VV128W, V128, M16>;
extern "C" constexpr auto ISEL_VPINSRW_XMMdq_XMMdq_GPR32d_IMMb [[gnu::used]] =
PINSRW<VV128W, V128, R32>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFMUL(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
do {
memory = _FWriteV32(memory, dst, (FMulV32(src1, src2)));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFADD(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
do {
memory = _FWriteV32(memory, dst, (FAddV32(src1, src2)));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFSUB(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
do {
memory = _FWriteV32(memory, dst, (FSubV32(src1, src2)));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFSUBR(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src);
auto src2 = _FReadV32(memory, src_dst);
do {
memory = _FWriteV32(memory, dst, (FSubV32(src1, src2)));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFMAX(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
auto out = src1;

#pragma unroll
for (auto i = 0u; i < 2; ++i) {
auto s1_val = FExtractV32(src1, i);
auto s2_val = FExtractV32(src2, i);
if (!std::isunordered(s1_val, s2_val) && s2_val > s1_val) {
out = FInsertV32(out, i, s2_val);
}
}
do {
memory = _FWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFMIN(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
auto out = src1;

#pragma unroll
for (auto i = 0u; i < 2; ++i) {
auto s1_val = FExtractV32(src1, i);
auto s2_val = FExtractV32(src2, i);
if (!std::isunordered(s1_val, s2_val) && s2_val < s1_val) {
out = FInsertV32(out, i, s2_val);
}
}
do {
memory = _FWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFCMPGT(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
uint32v2_t out = {};

#pragma unroll
for (auto i = 0u; i < 2; ++i) {
auto s1_val = FExtractV32(src1, i);
auto s2_val = FExtractV32(src2, i);
if (!std::isunordered(s1_val, s2_val) && s1_val > s2_val) {
out.elems[i] = ~0u;
}
}
do {
memory = _UWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFCMPGE(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
uint32v2_t out = {};

#pragma unroll
for (auto i = 0u; i < 2; ++i) {
auto s1_val = FExtractV32(src1, i);
auto s2_val = FExtractV32(src2, i);
if (!std::isunordered(s1_val, s2_val) && s1_val >= s2_val) {
out.elems[i] = ~0u;
}
}
do {
memory = _UWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFCMPEQ(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
uint32v2_t out = {};

#pragma unroll
for (auto i = 0u; i < 2; ++i) {
auto s1_val = FExtractV32(src1, i);
auto s2_val = FExtractV32(src2, i);
if (!std::isunordered(s1_val, s2_val) && s1_val == s2_val) {
out.elems[i] = ~0u;
}
}
do {
memory = _UWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFRSQRT(Memory *memory, State &state, D dst, S1, S2 src) {
auto src2 = _FReadV32(memory, src);
auto out = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();
out = FInsertV32(
out, 0, FDiv(1.0f, SquareRoot32(memory, state, FExtractV32(src2, 0))));
out = FInsertV32(
out, 1, FDiv(1.0f, SquareRoot32(memory, state, FExtractV32(src2, 1))));
do {
memory = _FWriteV32(memory, dst, (out));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PFACC(Memory *memory, State &state, D dst, S1 src_dst, S2 src) {
auto src1 = _FReadV32(memory, src_dst);
auto src2 = _FReadV32(memory, src);
auto out = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();
out = FInsertV32(out, 0, FAdd(FExtractV32(src1, 0), FExtractV32(src1, 1)));
out = FInsertV32(out, 1, FAdd(FExtractV32(src2, 0), FExtractV32(src2, 1)));
do {
memory = _FWriteV32(memory, dst, (out));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PFMUL_MMXq_MEMq [[gnu::used]] =
PFMUL<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFMUL_MMXq_MMXq [[gnu::used]] =
PFMUL<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFADD_MMXq_MEMq [[gnu::used]] =
PFADD<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFADD_MMXq_MMXq [[gnu::used]] =
PFADD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFSUB_MMXq_MEMq [[gnu::used]] =
PFSUB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFSUB_MMXq_MMXq [[gnu::used]] =
PFSUB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFSUBR_MMXq_MEMq [[gnu::used]] =
PFSUBR<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFSUBR_MMXq_MMXq [[gnu::used]] =
PFSUBR<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFMAX_MMXq_MEMq [[gnu::used]] =
PFMAX<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFMAX_MMXq_MMXq [[gnu::used]] =
PFMAX<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFMIN_MMXq_MEMq [[gnu::used]] =
PFMIN<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFMIN_MMXq_MMXq [[gnu::used]] =
PFMIN<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFCMPGT_MMXq_MEMq [[gnu::used]] =
PFCMPGT<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFCMPGT_MMXq_MMXq [[gnu::used]] =
PFCMPGT<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFCMPGE_MMXq_MEMq [[gnu::used]] =
PFCMPGE<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFCMPGE_MMXq_MMXq [[gnu::used]] =
PFCMPGE<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFCMPEQ_MMXq_MEMq [[gnu::used]] =
PFCMPEQ<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFCMPEQ_MMXq_MMXq [[gnu::used]] =
PFCMPEQ<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFRSQRT_MMXq_MEMq [[gnu::used]] =
PFRSQRT<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFRSQRT_MMXq_MMXq [[gnu::used]] =
PFRSQRT<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PFACC_MMXq_MEMq [[gnu::used]] =
PFACC<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PFACC_MMXq_MMXq [[gnu::used]] =
PFACC<V64W, V64, V64>;

extern "C" constexpr auto ISEL_MOVNTQ_MEMq_MMXq [[gnu::used]] =
DoMOVNTQ_MEMq_MMXq;

extern "C" constexpr auto ISEL_MASKMOVQ_MMXq_MMXq [[gnu::used]] =
DoMASKMOVQ_MMXq_MMXq;

extern "C" constexpr auto ISEL_EMMS [[gnu::used]] = DoEMMS;

extern "C" constexpr auto ISEL_FEMMS [[gnu::used]] = DoEMMS;

namespace {

template <typename... Types>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
NOP_IMPL(Memory *memory, State &state, Types...) {
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_NOP_GPRv_0F18r0_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r0_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r0_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r0_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r1_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r1_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r1_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r1_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r2_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r2_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r2_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r2_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r3_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r3_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r3_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r3_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r4_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r4_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r4_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r4_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r5_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r5_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r5_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r5_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r6_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r6_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r6_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r6_64 [[gnu::used]] = NOP_IMPL<R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r7_8 [[gnu::used]] = NOP_IMPL<R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r7_16 [[gnu::used]] = NOP_IMPL<R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r7_32 [[gnu::used]] = NOP_IMPL<R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_0F18r7_64 [[gnu::used]] = NOP_IMPL<R64>;

extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F19_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F19_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F19_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F19_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1C_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1C_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1C_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1C_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1D_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1D_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1D_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1D_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1E_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1E_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1E_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1E_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1F_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1F_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1F_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1F_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;

extern "C" constexpr auto ISEL_NOP_MEMv_0F18r4_8 [[gnu::used]] = NOP_IMPL<M8>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r4_16 [[gnu::used]] = NOP_IMPL<M16>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r4_32 [[gnu::used]] = NOP_IMPL<M32>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r4_64 [[gnu::used]] = NOP_IMPL<M64>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r5_8 [[gnu::used]] = NOP_IMPL<M8>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r5_16 [[gnu::used]] = NOP_IMPL<M16>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r5_32 [[gnu::used]] = NOP_IMPL<M32>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r5_64 [[gnu::used]] = NOP_IMPL<M64>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r6_8 [[gnu::used]] = NOP_IMPL<M8>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r6_16 [[gnu::used]] = NOP_IMPL<M16>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r6_32 [[gnu::used]] = NOP_IMPL<M32>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r6_64 [[gnu::used]] = NOP_IMPL<M64>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r7_8 [[gnu::used]] = NOP_IMPL<M8>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r7_16 [[gnu::used]] = NOP_IMPL<M16>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r7_32 [[gnu::used]] = NOP_IMPL<M32>;
extern "C" constexpr auto ISEL_NOP_MEMv_0F18r7_64 [[gnu::used]] = NOP_IMPL<M64>;

extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F19_8 [[gnu::used]] =
NOP_IMPL<M8, R8>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F19_16 [[gnu::used]] =
NOP_IMPL<M16, R16>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F19_32 [[gnu::used]] =
NOP_IMPL<M32, R32>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F19_64 [[gnu::used]] =
NOP_IMPL<M64, R64>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1C_8 [[gnu::used]] =
NOP_IMPL<M8, R8>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1C_16 [[gnu::used]] =
NOP_IMPL<M16, R16>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1C_32 [[gnu::used]] =
NOP_IMPL<M32, R32>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1C_64 [[gnu::used]] =
NOP_IMPL<M64, R64>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1D_8 [[gnu::used]] =
NOP_IMPL<M8, R8>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1D_16 [[gnu::used]] =
NOP_IMPL<M16, R16>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1D_32 [[gnu::used]] =
NOP_IMPL<M32, R32>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1D_64 [[gnu::used]] =
NOP_IMPL<M64, R64>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1E_8 [[gnu::used]] =
NOP_IMPL<M8, R8>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1E_16 [[gnu::used]] =
NOP_IMPL<M16, R16>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1E_32 [[gnu::used]] =
NOP_IMPL<M32, R32>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1E_64 [[gnu::used]] =
NOP_IMPL<M64, R64>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1F_8 [[gnu::used]] =
NOP_IMPL<M8, R8>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1F_16 [[gnu::used]] =
NOP_IMPL<M16, R16>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1F_32 [[gnu::used]] =
NOP_IMPL<M32, R32>;
extern "C" constexpr auto ISEL_NOP_MEMv_GPRv_0F1F_64 [[gnu::used]] =
NOP_IMPL<M64, R64>;

extern "C" constexpr auto ISEL_NOP_90 [[gnu::used]] = NOP_IMPL<>;

extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F0D_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F0D_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F0D_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F0D_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1A_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1A_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1A_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1A_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1B_8 [[gnu::used]] =
NOP_IMPL<R8, R8>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1B_16 [[gnu::used]] =
NOP_IMPL<R16, R16>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1B_32 [[gnu::used]] =
NOP_IMPL<R32, R32>;
extern "C" constexpr auto ISEL_NOP_GPRv_GPRv_0F1B_64 [[gnu::used]] =
NOP_IMPL<R64, R64>;

extern "C" constexpr auto ISEL_NOP_GPRv_MEMv_0F1A_8 [[gnu::used]] =
NOP_IMPL<R8, M8>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEMv_0F1A_16 [[gnu::used]] =
NOP_IMPL<R16, M16>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEMv_0F1A_32 [[gnu::used]] =
NOP_IMPL<R32, M32>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEMv_0F1A_64 [[gnu::used]] =
NOP_IMPL<R64, M64>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEM_0F1B_8 [[gnu::used]] =
NOP_IMPL<R8, M8>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEM_0F1B_16 [[gnu::used]] =
NOP_IMPL<R16, M16>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEM_0F1B_32 [[gnu::used]] =
NOP_IMPL<R32, M32>;
extern "C" constexpr auto ISEL_NOP_GPRv_MEM_0F1B_64 [[gnu::used]] =
NOP_IMPL<R64, M64>;

namespace {

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP(Memory *memory, State &state, D dst) {
addr_t op_size = ZExtTo<D>(ByteSizeOf(dst));
addr_t old_xsp = _Read(memory, state.gpr.rsp.qword);
addr_t new_xsp = UAdd(old_xsp, op_size);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(new_xsp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (new_xsp));
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(_Read(memory, ReadPtr<D>(old_xsp)))),
"Bad write!");
memory =
_Write(memory, dst,
(ZExtTo<decltype(dst)>(_Read(memory, ReadPtr<D>(old_xsp)))));
} while (false);
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_MEM_XSP(Memory *memory, State &state, D dst) {
addr_t op_size = ZExtTo<D>(ByteSizeOf(dst));
addr_t old_xsp = _Read(memory, state.gpr.rsp.qword);
addr_t new_xsp = UAdd(old_xsp, op_size);

do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(new_xsp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (new_xsp));
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(D{dst.addr + op_size})>::BT) ==
sizeof(ZExtTo<decltype(D{dst.addr + op_size})>(
_Read(memory, ReadPtr<D>(old_xsp)))),
"Bad write!");
memory = _Write(memory, D{dst.addr + op_size},
(ZExtTo<decltype(D{dst.addr + op_size})>(
_Read(memory, ReadPtr<D>(old_xsp)))));
} while (false);
} while (false);
return memory;
}
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPOPFQ(Memory *memory, State &state) {
Flags f;
f.flat = PopFromStack<uint64_t>(memory, state);
state.aflag.af = f.af;
state.aflag.cf = f.cf;
state.aflag.df = f.df;
state.aflag.of = f.of;
state.aflag.pf = f.pf;
state.aflag.sf = f.sf;
state.aflag.zf = f.zf;

state.rflag.id = f.id;

return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPOPF(Memory *memory, State &state) {
Flags f;
f.flat = ZExt(ZExt(PopFromStack<uint16_t>(memory, state)));
state.aflag.af = f.af;
state.aflag.cf = f.cf;
state.aflag.df = f.df;
state.aflag.of = f.of;
state.aflag.pf = f.pf;
state.aflag.sf = f.sf;
state.aflag.zf = f.zf;
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_POP_GPRv_8F_16 [[gnu::used]] = POP<R16W>;
extern "C" constexpr auto ISEL_POP_GPRv_8F_64 [[gnu::used]] = POP<R64W>;

extern "C" constexpr auto ISEL_POP_GPRv_51_16 [[gnu::used]] = POP<R16W>;
extern "C" constexpr auto ISEL_POP_GPRv_58_16 [[gnu::used]] = POP<R16W>;
extern "C" constexpr auto ISEL_POP_GPRv_51_64 [[gnu::used]] = POP<R64W>;
extern "C" constexpr auto ISEL_POP_GPRv_58_64 [[gnu::used]] = POP<R64W>;

extern "C" constexpr auto ISEL_POP_MEM_XSP_16 [[gnu::used]] = POP_MEM_XSP<M16W>;
extern "C" constexpr auto ISEL_POP_MEM_XSP_64 [[gnu::used]] = POP_MEM_XSP<M64W>;

extern "C" constexpr auto ISEL_POP_MEMv_16 [[gnu::used]] = POP<M16W>;
extern "C" constexpr auto ISEL_POP_MEMv_64 [[gnu::used]] = POP<M64W>;

extern "C" constexpr auto ISEL_POPF [[gnu::used]] = DoPOPF;

extern "C" constexpr auto ISEL_POPFQ [[gnu::used]] = DoPOPFQ;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_ES(Memory *memory, State &state, R16W dst) {
addr_t addr_size = static_cast<addr_t>(sizeof(T));
addr_t stack_ptr = _Read(memory, state.gpr.rsp.qword);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))),
"Bad write!");
memory = _Write(memory, dst,
(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(stack_ptr, addr_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(stack_ptr, addr_size)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentES);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_SS(Memory *memory, State &state, R16W dst) {
addr_t addr_size = static_cast<addr_t>(sizeof(T));
addr_t stack_ptr = _Read(memory, state.gpr.rsp.qword);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))),
"Bad write!");
memory = _Write(memory, dst,
(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(stack_ptr, addr_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(stack_ptr, addr_size)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentSS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_DS(Memory *memory, State &state, R16W dst) {
addr_t addr_size = static_cast<addr_t>(sizeof(T));
addr_t stack_ptr = _Read(memory, state.gpr.rsp.qword);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))),
"Bad write!");
memory = _Write(memory, dst,
(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(stack_ptr, addr_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(stack_ptr, addr_size)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentDS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_FS(Memory *memory, State &state, R16W dst) {
addr_t addr_size = static_cast<addr_t>(sizeof(T));
addr_t stack_ptr = _Read(memory, state.gpr.rsp.qword);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))),
"Bad write!");
memory = _Write(memory, dst,
(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(stack_ptr, addr_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(stack_ptr, addr_size)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentFS);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
POP_GS(Memory *memory, State &state, R16W dst) {
addr_t addr_size = static_cast<addr_t>(sizeof(T));
addr_t stack_ptr = _Read(memory, state.gpr.rsp.qword);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))),
"Bad write!");
memory = _Write(memory, dst,
(TruncTo<uint16_t>(_Read(memory, ReadPtr<T>(stack_ptr)))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(UAdd(stack_ptr, addr_size)),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (UAdd(stack_ptr, addr_size)));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetSegmentGS);
}

} // namespace
extern "C" constexpr auto ISEL_POP_ES_16 [[gnu::used]] = POP_ES<uint16_t>;
extern "C" constexpr auto ISEL_POP_ES_64 [[gnu::used]] = POP_ES<uint64_t>;

extern "C" constexpr auto ISEL_POP_SS_16 [[gnu::used]] = POP_SS<uint16_t>;
extern "C" constexpr auto ISEL_POP_SS_64 [[gnu::used]] = POP_SS<uint64_t>;

extern "C" constexpr auto ISEL_POP_DS_16 [[gnu::used]] = POP_DS<uint16_t>;
extern "C" constexpr auto ISEL_POP_DS_64 [[gnu::used]] = POP_DS<uint64_t>;

extern "C" constexpr auto ISEL_POP_FS_16 [[gnu::used]] = POP_FS<uint16_t>;
extern "C" constexpr auto ISEL_POP_FS_64 [[gnu::used]] = POP_FS<uint64_t>;

extern "C" constexpr auto ISEL_POP_GS_16 [[gnu::used]] = POP_GS<uint16_t>;
extern "C" constexpr auto ISEL_POP_GS_64 [[gnu::used]] = POP_GS<uint64_t>;
namespace {

template <typename... Args>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PREFETCH(Memory *memory, State &state, Args...) {
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CLWB_MEMmprefetch [[gnu::used]] = PREFETCH<>;
extern "C" constexpr auto ISEL_PREFETCH_RESERVED_0F0Dr4 [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCH_RESERVED_0F0Dr5 [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCH_RESERVED_0F0Dr6 [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCH_RESERVED_0F0Dr7 [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHT2_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHT1_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHT0_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_CLFLUSHOPT_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCH_EXCLUSIVE_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHWT1_MEMu8 [[gnu::used]] = PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHW_0F0Dr1 [[gnu::used]] = PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHW_0F0Dr3 [[gnu::used]] = PREFETCH<M8>;
extern "C" constexpr auto ISEL_PREFETCHNTA_MEMmprefetch [[gnu::used]] =
PREFETCH<M8>;

namespace {

static void SerializeFlags(State &state) {
state.rflag.cf = state.aflag.cf;

state.rflag.pf = state.aflag.pf;

state.rflag.af = state.aflag.af;

state.rflag.zf = state.aflag.zf;
state.rflag.sf = state.aflag.sf;

state.rflag.df = state.aflag.df;
state.rflag.of = state.aflag.of;
}

} // namespace

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static auto
PushToStack(Memory *&memory, State &state, T val) -> void {
addr_t op_size = ZExtTo<addr_t>(ByteSizeOf(val));
addr_t old_xsp = _Read(memory, state.gpr.rsp.qword);
addr_t new_xsp = USub(old_xsp, op_size);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<T>(new_xsp))>::BT) ==
sizeof(val),
"Bad write!");
memory = _Write(memory, WritePtr<T>(new_xsp), (val));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsp.qword)>::BT) ==
sizeof(new_xsp),
"Bad write!");
memory = _Write(memory, state.gpr.rsp.qword, (new_xsp));
} while (false);
}

template <typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PUSH(Memory *memory, State &state, S1 src1) {
PushToStack(memory, state, _Read(memory, src1));
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPUSHA(Memory *memory, State &state) {
uint16_t sp = _Read(memory, state.gpr.rsp.word);
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rax.word));
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rcx.word));
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rdx.word));
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rbx.word));
PushToStack<uint16_t>(memory, state, sp);
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rbp.word));
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rsi.word));
PushToStack<uint16_t>(memory, state, _Read(memory, state.gpr.rdi.word));
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPUSHAD(Memory *memory, State &state) {
uint32_t esp = _Read(memory, state.gpr.rsp.dword);
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rax.dword));
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rcx.dword));
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rdx.dword));
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rbx.dword));
PushToStack<uint32_t>(memory, state, esp);
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rbp.dword));
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rsi.dword));
PushToStack<uint32_t>(memory, state, _Read(memory, state.gpr.rdi.dword));
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPUSHF(Memory *memory, State &state) {
SerializeFlags(state);
PushToStack<uint16_t>(memory, state, TruncTo<uint16_t>(state.rflag.flat));
return memory;
}
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPUSHFQ(Memory *memory, State &state) {
SerializeFlags(state);
PushToStack<uint64_t>(memory, state, state.rflag.flat);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PUSH_GPRv_FFr6_16 [[gnu::used]] = PUSH<R16>;
extern "C" constexpr auto ISEL_PUSH_GPRv_FFr6_64 [[gnu::used]] = PUSH<I64>;

extern "C" constexpr auto ISEL_PUSH_GPRv_50_16 [[gnu::used]] = PUSH<R16>;
extern "C" constexpr auto ISEL_PUSH_GPRv_50_64 [[gnu::used]] = PUSH<I64>;

extern "C" constexpr auto ISEL_PUSH_IMMz_16 [[gnu::used]] = PUSH<I16>;
extern "C" constexpr auto ISEL_PUSH_IMMz_64 [[gnu::used]] = PUSH<I64>;

extern "C" constexpr auto ISEL_PUSH_IMMb_16 [[gnu::used]] = PUSH<I16>;
extern "C" constexpr auto ISEL_PUSH_IMMb_64 [[gnu::used]] = PUSH<I64>;

extern "C" constexpr auto ISEL_PUSH_MEMv_16 [[gnu::used]] = PUSH<M16>;
extern "C" constexpr auto ISEL_PUSH_MEMv_64 [[gnu::used]] = PUSH<M64>;

extern "C" constexpr auto ISEL_PUSHF [[gnu::used]] = DoPUSHF;

extern "C" constexpr auto ISEL_PUSHFQ [[gnu::used]] = DoPUSHFQ;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ROL(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto count = ZExtTo<S1>(_Read(memory, src2));
auto one = Literal<S1>(1);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto count_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_count = UAnd(count, count_mask);
auto temp_count = URem(masked_count, op_size);
if (temp_count) {
auto new_val =
UOr(UShl(val, temp_count), UShr(val, USub(op_size, temp_count)));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpEq(UAnd(new_val, one), one)),
"Bad write!");
memory =
_Write(memory, state.aflag.cf, (UCmpEq(UAnd(new_val, one), one)));
} while (false);
if (1 == temp_count) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(state.aflag.cf, SignFlag(new_val))),
"Bad write!");
memory = _Write(memory, state.aflag.of,
(BXor(state.aflag.cf, SignFlag(new_val))));
} while (false);

} else {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);
}
} else {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
}
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
ROR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto count = ZExtTo<S1>(_Read(memory, src2));
auto one = Literal<S1>(1);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto count_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_count = UAnd(count, count_mask);
auto temp_count = URem(masked_count, op_size);
if (temp_count) {
auto new_val =
UOr(UShr(val, temp_count), UShl(val, USub(op_size, temp_count)));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(SignFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (SignFlag(new_val)));
} while (false);

if (temp_count == 1)
do {
static_assert(
sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(state.aflag.cf, SignFlag(UShl(new_val, one)))),
"Bad write!");
memory = _Write(memory, state.aflag.of,
(BXor(state.aflag.cf, SignFlag(UShl(new_val, one)))));
} while (false);
else
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);

} else {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
}
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RORX(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto count = ZExtTo<S1>(_Read(memory, src2));
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto count_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_count = UAnd(count, count_mask);
auto temp_count = URem(masked_count, op_size);
auto new_val =
UOr(UShr(val, temp_count), UShl(val, USub(op_size, temp_count)));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_ROL_MEMb_IMMb [[gnu::used]] = ROL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROL_GPR8_IMMb [[gnu::used]] = ROL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROL_MEMv_IMMb_8 [[gnu::used]] = ROL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROL_MEMv_IMMb_16 [[gnu::used]] =
ROL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ROL_MEMv_IMMb_32 [[gnu::used]] =
ROL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ROL_MEMv_IMMb_64 [[gnu::used]] =
ROL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ROL_GPRv_IMMb_8 [[gnu::used]] = ROL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROL_GPRv_IMMb_16 [[gnu::used]] =
ROL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ROL_GPRv_IMMb_32 [[gnu::used]] =
ROL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ROL_GPRv_IMMb_64 [[gnu::used]] =
ROL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ROL_MEMb_ONE [[gnu::used]] = ROL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROL_GPR8_ONE [[gnu::used]] = ROL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROL_MEMv_ONE_8 [[gnu::used]] = ROL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROL_MEMv_ONE_16 [[gnu::used]] =
ROL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ROL_MEMv_ONE_32 [[gnu::used]] =
ROL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ROL_MEMv_ONE_64 [[gnu::used]] =
ROL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ROL_GPRv_ONE_8 [[gnu::used]] = ROL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROL_GPRv_ONE_16 [[gnu::used]] =
ROL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ROL_GPRv_ONE_32 [[gnu::used]] =
ROL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ROL_GPRv_ONE_64 [[gnu::used]] =
ROL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ROL_MEMb_CL [[gnu::used]] = ROL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ROL_GPR8_CL [[gnu::used]] = ROL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ROL_MEMv_CL_8 [[gnu::used]] = ROL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ROL_MEMv_CL_16 [[gnu::used]] =
ROL<M16W, M16, R16>;
extern "C" constexpr auto ISEL_ROL_MEMv_CL_32 [[gnu::used]] =
ROL<M32W, M32, R32>;
extern "C" constexpr auto ISEL_ROL_MEMv_CL_64 [[gnu::used]] =
ROL<M64W, M64, R64>;
extern "C" constexpr auto ISEL_ROL_GPRv_CL_8 [[gnu::used]] = ROL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ROL_GPRv_CL_16 [[gnu::used]] =
ROL<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ROL_GPRv_CL_32 [[gnu::used]] =
ROL<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ROL_GPRv_CL_64 [[gnu::used]] =
ROL<R64W, R64, R64>;

extern "C" constexpr auto ISEL_ROR_MEMb_IMMb [[gnu::used]] = ROR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROR_GPR8_IMMb [[gnu::used]] = ROR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROR_MEMv_IMMb_8 [[gnu::used]] = ROR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROR_MEMv_IMMb_16 [[gnu::used]] =
ROR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ROR_MEMv_IMMb_32 [[gnu::used]] =
ROR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ROR_MEMv_IMMb_64 [[gnu::used]] =
ROR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ROR_GPRv_IMMb_8 [[gnu::used]] = ROR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROR_GPRv_IMMb_16 [[gnu::used]] =
ROR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ROR_GPRv_IMMb_32 [[gnu::used]] =
ROR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ROR_GPRv_IMMb_64 [[gnu::used]] =
ROR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ROR_MEMb_ONE [[gnu::used]] = ROR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROR_GPR8_ONE [[gnu::used]] = ROR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROR_MEMv_ONE_8 [[gnu::used]] = ROR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_ROR_MEMv_ONE_16 [[gnu::used]] =
ROR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_ROR_MEMv_ONE_32 [[gnu::used]] =
ROR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_ROR_MEMv_ONE_64 [[gnu::used]] =
ROR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_ROR_GPRv_ONE_8 [[gnu::used]] = ROR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_ROR_GPRv_ONE_16 [[gnu::used]] =
ROR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_ROR_GPRv_ONE_32 [[gnu::used]] =
ROR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_ROR_GPRv_ONE_64 [[gnu::used]] =
ROR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_ROR_MEMb_CL [[gnu::used]] = ROR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ROR_GPR8_CL [[gnu::used]] = ROR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ROR_MEMv_CL_8 [[gnu::used]] = ROR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_ROR_MEMv_CL_16 [[gnu::used]] =
ROR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_ROR_MEMv_CL_32 [[gnu::used]] =
ROR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_ROR_MEMv_CL_64 [[gnu::used]] =
ROR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_ROR_GPRv_CL_8 [[gnu::used]] = ROR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_ROR_GPRv_CL_16 [[gnu::used]] =
ROR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_ROR_GPRv_CL_32 [[gnu::used]] =
ROR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_ROR_GPRv_CL_64 [[gnu::used]] =
ROR<R64W, R64, R64>;

extern "C" constexpr auto ISEL_RORX_VGPR32d_VGPR32d_IMMb [[gnu::used]] =
RORX<R32W, R32, I8>;
extern "C" constexpr auto ISEL_RORX_VGPR32d_MEMd_IMMb [[gnu::used]] =
RORX<R32W, M32, I8>;
extern "C" constexpr auto ISEL_RORX_VGPR64q_VGPR64q_IMMb [[gnu::used]] =
RORX<R64W, R64, I8>;
extern "C" constexpr auto ISEL_RORX_VGPR64q_MEMq_IMMb [[gnu::used]] =
RORX<R64W, M64, I8>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RCL(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto count = ZExtTo<S1>(_Read(memory, src2));
auto zero = Literal<S1>(0);
auto one = Literal<S1>(1);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto count_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto count_mod =
Select(UCmpLt(op_size, 32), UAdd(op_size, one), UAdd(count_mask, one));

auto masked_count = UAnd(count, count_mask);
auto temp_count = URem(masked_count, count_mod);
auto carry = Select(state.aflag.cf, one, zero);

if (temp_count) {
auto right = UShr(val, USub(op_size, temp_count));
auto new_val =
UOr(UOr(UShl(val, temp_count), UShl(carry, USub(temp_count, one))),
UShr(right, one));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(SignFlag(UShl(val, USub(temp_count, one)))),
"Bad write!");
memory = _Write(memory, state.aflag.cf,
(SignFlag(UShl(val, USub(temp_count, one)))));
} while (false);

if (temp_count == 1) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(state.aflag.cf, SignFlag(new_val))),
"Bad write!");
memory = _Write(memory, state.aflag.of,
(BXor(state.aflag.cf, SignFlag(new_val))));
} while (false);
} else {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);
}

} else {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
}
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RCR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto count = ZExtTo<S1>(_Read(memory, src2));
auto one = Literal<S1>(1);
auto zero = Literal<S1>(0);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto count_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto count_mod =
Select(UCmpLt(op_size, 32), UAdd(op_size, one), UAdd(count_mask, one));

auto masked_count = UAnd(count, count_mask);
auto temp_count = URem(masked_count, count_mod);
auto carry = Select(state.aflag.cf, one, zero);

if (temp_count) {
auto left = UShr(val, USub(temp_count, one));
auto right = UShl(val, USub(op_size, temp_count));
auto new_val =
UOr(UOr(UShr(left, one), UShl(carry, USub(op_size, temp_count))),
UShl(right, one));
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(UCmpNeq(UAnd(left, one), zero)),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (UCmpNeq(UAnd(left, one), zero)));
} while (false);
if (temp_count == 1) {
do {
static_assert(
sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(SignFlag(UShl(new_val, one)), SignFlag(new_val))),
"Bad write!");
memory =
_Write(memory, state.aflag.of,
(BXor(SignFlag(UShl(new_val, one)), SignFlag(new_val))));
} while (false);
} else {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.of, (__remill_undefined_8()));
} while (false);
}

} else {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
}
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_RCL_MEMb_IMMb [[gnu::used]] = RCL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCL_GPR8_IMMb [[gnu::used]] = RCL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCL_MEMv_IMMb_8 [[gnu::used]] = RCL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCL_MEMv_IMMb_16 [[gnu::used]] =
RCL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_RCL_MEMv_IMMb_32 [[gnu::used]] =
RCL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_RCL_MEMv_IMMb_64 [[gnu::used]] =
RCL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_RCL_GPRv_IMMb_8 [[gnu::used]] = RCL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCL_GPRv_IMMb_16 [[gnu::used]] =
RCL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_RCL_GPRv_IMMb_32 [[gnu::used]] =
RCL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_RCL_GPRv_IMMb_64 [[gnu::used]] =
RCL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_RCL_MEMb_ONE [[gnu::used]] = RCL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCL_GPR8_ONE [[gnu::used]] = RCL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCL_MEMv_ONE_8 [[gnu::used]] = RCL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCL_MEMv_ONE_16 [[gnu::used]] =
RCL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_RCL_MEMv_ONE_32 [[gnu::used]] =
RCL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_RCL_MEMv_ONE_64 [[gnu::used]] =
RCL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_RCL_GPRv_ONE_8 [[gnu::used]] = RCL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCL_GPRv_ONE_16 [[gnu::used]] =
RCL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_RCL_GPRv_ONE_32 [[gnu::used]] =
RCL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_RCL_GPRv_ONE_64 [[gnu::used]] =
RCL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_RCL_MEMb_CL [[gnu::used]] = RCL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_RCL_GPR8_CL [[gnu::used]] = RCL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_RCL_MEMv_CL_8 [[gnu::used]] = RCL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_RCL_MEMv_CL_16 [[gnu::used]] =
RCL<M16W, M16, R16>;
extern "C" constexpr auto ISEL_RCL_MEMv_CL_32 [[gnu::used]] =
RCL<M32W, M32, R32>;
extern "C" constexpr auto ISEL_RCL_MEMv_CL_64 [[gnu::used]] =
RCL<M64W, M64, R64>;
extern "C" constexpr auto ISEL_RCL_GPRv_CL_8 [[gnu::used]] = RCL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_RCL_GPRv_CL_16 [[gnu::used]] =
RCL<R16W, R16, R16>;
extern "C" constexpr auto ISEL_RCL_GPRv_CL_32 [[gnu::used]] =
RCL<R32W, R32, R32>;
extern "C" constexpr auto ISEL_RCL_GPRv_CL_64 [[gnu::used]] =
RCL<R64W, R64, R64>;

extern "C" constexpr auto ISEL_RCR_MEMb_IMMb [[gnu::used]] = RCR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCR_GPR8_IMMb [[gnu::used]] = RCR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCR_MEMv_IMMb_8 [[gnu::used]] = RCR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCR_MEMv_IMMb_16 [[gnu::used]] =
RCR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_RCR_MEMv_IMMb_32 [[gnu::used]] =
RCR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_RCR_MEMv_IMMb_64 [[gnu::used]] =
RCR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_RCR_GPRv_IMMb_8 [[gnu::used]] = RCR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCR_GPRv_IMMb_16 [[gnu::used]] =
RCR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_RCR_GPRv_IMMb_32 [[gnu::used]] =
RCR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_RCR_GPRv_IMMb_64 [[gnu::used]] =
RCR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_RCR_MEMb_ONE [[gnu::used]] = RCR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCR_GPR8_ONE [[gnu::used]] = RCR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCR_MEMv_ONE_8 [[gnu::used]] = RCR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_RCR_MEMv_ONE_16 [[gnu::used]] =
RCR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_RCR_MEMv_ONE_32 [[gnu::used]] =
RCR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_RCR_MEMv_ONE_64 [[gnu::used]] =
RCR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_RCR_GPRv_ONE_8 [[gnu::used]] = RCR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_RCR_GPRv_ONE_16 [[gnu::used]] =
RCR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_RCR_GPRv_ONE_32 [[gnu::used]] =
RCR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_RCR_GPRv_ONE_64 [[gnu::used]] =
RCR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_RCR_MEMb_CL [[gnu::used]] = RCR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_RCR_GPR8_CL [[gnu::used]] = RCR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_RCR_MEMv_CL_8 [[gnu::used]] = RCR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_RCR_MEMv_CL_16 [[gnu::used]] =
RCR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_RCR_MEMv_CL_32 [[gnu::used]] =
RCR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_RCR_MEMv_CL_64 [[gnu::used]] =
RCR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_RCR_GPRv_CL_8 [[gnu::used]] = RCR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_RCR_GPRv_CL_16 [[gnu::used]] =
RCR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_RCR_GPRv_CL_32 [[gnu::used]] =
RCR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_RCR_GPRv_CL_64 [[gnu::used]] =
RCR<R64W, R64, R64>;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
XBEGIN(Memory *memory, State &state, R8W cond, PC taken, PC not_taken,
R64W pc_dst) {
do {
static_assert(sizeof(typename BaseType<decltype(cond)>::BT) == sizeof(true),
"Bad write!");
memory = _Write(memory, cond, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(_Read(memory, taken)),
"Bad write!");
memory = _Write(memory, pc_dst, (_Read(memory, taken)));
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
static_cast<addr_t>(8))),
"Bad write!");
memory = _Write(
memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(static_cast<addr_t>(8))));
} while (false);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoXTEST(Memory *memory, State &state) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (true));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoXEND(Memory *memory, State &state, PC next_pc) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
XABORT(Memory *memory, State &state, I8) {
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_XBEGIN_RELBRz_16 [[gnu::used]] = XBEGIN;
extern "C" constexpr auto ISEL_XBEGIN_RELBRz_32 [[gnu::used]] = XBEGIN;
extern "C" constexpr auto ISEL_XEND [[gnu::used]] = DoXEND;
extern "C" constexpr auto ISEL_XTEST [[gnu::used]] = DoXTEST;
extern "C" constexpr auto ISEL_XABORT_IMMb [[gnu::used]] = XABORT;
namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPXCHG_AL(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto desired_val = _Read(memory, src2);
auto check_val = _Read(memory, state.gpr.rax.byte.low);
auto prev_value = check_val;
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
auto sub_res = USub(prev_value, check_val);
WriteFlagsAddSub<tag_sub>(state, prev_value, check_val, sub_res);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
if (!swap_flag) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(check_val)));
} while (false);
} while (false);
}
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPXCHG_AX(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto desired_val = _Read(memory, src2);
auto check_val = _Read(memory, state.gpr.rax.word);
auto prev_value = check_val;
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
auto sub_res = USub(prev_value, check_val);
WriteFlagsAddSub<tag_sub>(state, prev_value, check_val, sub_res);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
if (!swap_flag) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(check_val)));
} while (false);
} while (false);
}
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPXCHG_EAX(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto desired_val = _Read(memory, src2);
auto check_val = _Read(memory, state.gpr.rax.dword);
auto prev_value = check_val;
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
auto sub_res = USub(prev_value, check_val);
WriteFlagsAddSub<tag_sub>(state, prev_value, check_val, sub_res);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
if (!swap_flag) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(check_val)));
} while (false);
} while (false);
}
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPXCHG_RAX(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto desired_val = _Read(memory, src2);
auto check_val = _Read(memory, state.gpr.rax.qword);
auto prev_value = check_val;
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
auto sub_res = USub(prev_value, check_val);
WriteFlagsAddSub<tag_sub>(state, prev_value, check_val, sub_res);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
if (!swap_flag) {
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(check_val)));
} while (false);
} while (false);
}
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPXCHG8B_MEMq(Memory *memory, State &state, M64W dst, M64 src1) {
auto xdx = _Read(memory, state.gpr.rdx.dword);
auto xax = _Read(memory, state.gpr.rax.dword);
auto xcx = _Read(memory, state.gpr.rcx.dword);
auto xbx = _Read(memory, state.gpr.rbx.dword);
auto desired_val = UOr(UShl(ZExt(xcx), 32), ZExt(xbx));
auto check_val = UOr(UShl(ZExt(xdx), 32), ZExt(xax));
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.dword)>::BT) ==
sizeof(Trunc(UShr(check_val, 32))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.dword, (Trunc(UShr(check_val, 32))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.dword)>::BT) ==
sizeof(Trunc(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.dword, (Trunc(check_val)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPXCHG16B_MEMdq(Memory *memory, State &state, M128W dst, M128 src1) {
auto xdx = _Read(memory, state.gpr.rdx.qword);
auto xax = _Read(memory, state.gpr.rax.qword);
auto xcx = _Read(memory, state.gpr.rcx.qword);
auto xbx = _Read(memory, state.gpr.rbx.qword);
auto desired_val = UOr(UShl(ZExt(xcx), 64), ZExt(xbx));
auto check_val = UOr(UShl(ZExt(xdx), 64), ZExt(xax));
auto swap_flag = _CmpXchg(memory, dst, check_val, desired_val);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(swap_flag),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (swap_flag));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(Trunc(UShr(check_val, 64))),
"Bad write!");
memory = _Write(memory, state.gpr.rdx.qword, (Trunc(UShr(check_val, 64))));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(Trunc(check_val)),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword, (Trunc(check_val)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CMPXCHG_MEMb_GPR8 [[gnu::used]] =
CMPXCHG_AL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_CMPXCHG_GPR8_GPR8 [[gnu::used]] =
CMPXCHG_AL<R8W, R8, R8>;

extern "C" constexpr auto ISEL_CMPXCHG_MEMv_GPRv_8 [[gnu::used]] =
CMPXCHG_AL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_CMPXCHG_GPRv_GPRv_8 [[gnu::used]] =
CMPXCHG_AL<R8W, R8, R8>;

extern "C" constexpr auto ISEL_CMPXCHG_MEMv_GPRv_16 [[gnu::used]] =
CMPXCHG_AX<M16W, M16, R16>;
extern "C" constexpr auto ISEL_CMPXCHG_GPRv_GPRv_16 [[gnu::used]] =
CMPXCHG_AX<R16W, R16, R16>;

extern "C" constexpr auto ISEL_CMPXCHG_MEMv_GPRv_32 [[gnu::used]] =
CMPXCHG_EAX<M32W, M32, R32>;
extern "C" constexpr auto ISEL_CMPXCHG_GPRv_GPRv_32 [[gnu::used]] =
CMPXCHG_EAX<R32W, R32, R32>;

extern "C" constexpr auto ISEL_CMPXCHG_MEMv_GPRv_64 [[gnu::used]] =
CMPXCHG_RAX<M64W, M64, R64>;
extern "C" constexpr auto ISEL_CMPXCHG_GPRv_GPRv_64 [[gnu::used]] =
CMPXCHG_RAX<R64W, R64, R64>;

extern "C" constexpr auto ISEL_CMPXCHG8B_MEMq [[gnu::used]] = DoCMPXCHG8B_MEMq;

extern "C" constexpr auto ISEL_CMPXCHG16B_MEMdq [[gnu::used]] =
DoCMPXCHG16B_MEMdq;

namespace {

template <typename D1, typename S1, typename D2, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
XADD(Memory *memory, State &state, D1 dst1, S1 src1, D2 dst2, S2 src2) {

if (IsRegister(dst1)) {
do {
memory = __remill_barrier_store_load(memory);
} while (false);
}

auto rhs = _Read(memory, src1);
auto lhs = _Read(memory, src2);
auto sum = _UAddFetch(memory, dst2, rhs);
WriteFlagsAddSub<tag_add>(state, rhs, lhs, sum);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst1)>::BT) ==
sizeof(ZExtTo<decltype(dst1)>(sum)),
"Bad write!");
memory = _Write(memory, dst1, (ZExtTo<decltype(dst1)>(sum)));
} while (false);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_XADD_MEMb_GPR8 [[gnu::used]] =
XADD<M8W, M8, R8W, R8>;
extern "C" constexpr auto ISEL_XADD_GPR8_GPR8 [[gnu::used]] =
XADD<R8W, R8, R8W, R8>;
extern "C" constexpr auto ISEL_XADD_MEMv_GPRv_8 [[gnu::used]] =
XADD<M8W, M8, R8W, R8>;
extern "C" constexpr auto ISEL_XADD_MEMv_GPRv_16 [[gnu::used]] =
XADD<M16W, M16, R16W, R16>;
extern "C" constexpr auto ISEL_XADD_MEMv_GPRv_32 [[gnu::used]] =
XADD<M32W, M32, R32W, R32>;
extern "C" constexpr auto ISEL_XADD_MEMv_GPRv_64 [[gnu::used]] =
XADD<M64W, M64, R64W, R64>;
extern "C" constexpr auto ISEL_XADD_GPRv_GPRv_8 [[gnu::used]] =
XADD<R8W, R8, R8W, R8>;
extern "C" constexpr auto ISEL_XADD_GPRv_GPRv_16 [[gnu::used]] =
XADD<R16W, R16, R16W, R16>;
extern "C" constexpr auto ISEL_XADD_GPRv_GPRv_32 [[gnu::used]] =
XADD<R32W, R32, R32W, R32>;
extern "C" constexpr auto ISEL_XADD_GPRv_GPRv_64 [[gnu::used]] =
XADD<R64W, R64, R64W, R64>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto shift = _Read(memory, src2);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto shift_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_shift = UAnd(shift, shift_mask);
if (UCmpEq(masked_shift, 0)) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
return memory;
}
auto new_val = val;
auto new_of = false;
auto new_cf = false;

if (UCmpEq(masked_shift, 1)) {
new_of = SignFlag(val);
new_cf = UCmpEq(UAnd(val, 1), 1);
new_val = UShr(val, 1);

} else if (UCmpLt(masked_shift, op_size)) {
auto res = UShr(val, USub(masked_shift, 1));
new_of = __remill_undefined_8();
new_cf = UCmpEq(UAnd(res, 1), 1);
new_val = UShr(res, 1);

} else {
new_of = __remill_undefined_8();
new_cf = __remill_undefined_8();
new_val = 0;
}
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(new_cf),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (new_cf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(new_of),
"Bad write!");
memory = _Write(memory, state.aflag.of, (new_of));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SAR(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto uval = _Read(memory, src1);
auto shift = _Read(memory, src2);
auto val = Signed(uval);
auto one = SLiteral<S1>(1);
auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto shift_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_shift = UAnd(shift, shift_mask);
if (UCmpEq(masked_shift, 0)) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(uval)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(uval)));
} while (false);
} while (false);
return memory;
}
auto new_val = uval;
auto new_of = false;
auto new_cf = false;

if (UCmpEq(masked_shift, 1)) {
new_of = false;
new_cf = UCmpEq(UAnd(uval, 1), 1);
new_val = Unsigned(SShr(val, one));

} else if (UCmpLt(masked_shift, op_size)) {
auto res = SShr(val, Signed(USub(masked_shift, 1)));
new_of = __remill_undefined_8();
new_cf = SCmpEq(SAnd(res, one), one);
new_val = Unsigned(SShr(res, one));

} else {
new_of = __remill_undefined_8();
new_cf = __remill_undefined_8();
if (SignFlag(val)) {
new_val = Maximize(uval);
} else {
new_val = 0;
}
}

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(new_cf),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (new_cf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(SignFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (SignFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(new_of),
"Bad write!");
memory = _Write(memory, state.aflag.of, (new_of));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHL(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto val = _Read(memory, src1);
auto shift = _Read(memory, src2);

auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto shift_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_shift = UAnd(shift, shift_mask);

if (UCmpEq(masked_shift, 0)) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val)));
} while (false);
} while (false);
return memory;
}

auto new_val = val;
auto new_of = false;
auto new_cf = false;

if (UCmpEq(masked_shift, 1)) {
auto res = UShl(val, 1);
auto msb = SignFlag(val);
auto new_msb = SignFlag(res);

new_of = BXor(msb, new_msb);
new_cf = msb;
new_val = res;

} else if (UCmpLt(masked_shift, op_size)) {
auto res = UShl(val, USub(masked_shift, 1));
auto msb = SignFlag(res);
new_of = __remill_undefined_8();
new_cf = msb;
new_val = UShl(res, 1);

} else {
new_of = __remill_undefined_8();

new_cf = 0;
new_val = 0;
}

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(new_val)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(new_val)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(new_cf),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (new_cf));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(SignFlag(new_val)),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (SignFlag(new_val)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(new_of),
"Bad write!");
memory = _Write(memory, state.aflag.of, (new_of));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_SHR_MEMb_IMMb [[gnu::used]] = SHR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHR_GPR8_IMMb [[gnu::used]] = SHR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHR_MEMv_IMMb_8 [[gnu::used]] = SHR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHR_MEMv_IMMb_16 [[gnu::used]] =
SHR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHR_MEMv_IMMb_32 [[gnu::used]] =
SHR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHR_MEMv_IMMb_64 [[gnu::used]] =
SHR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHR_GPRv_IMMb_8 [[gnu::used]] = SHR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHR_GPRv_IMMb_16 [[gnu::used]] =
SHR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHR_GPRv_IMMb_32 [[gnu::used]] =
SHR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHR_GPRv_IMMb_64 [[gnu::used]] =
SHR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHR_MEMb_ONE [[gnu::used]] = SHR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHR_GPR8_ONE [[gnu::used]] = SHR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHR_MEMv_ONE_8 [[gnu::used]] = SHR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHR_MEMv_ONE_16 [[gnu::used]] =
SHR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHR_MEMv_ONE_32 [[gnu::used]] =
SHR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHR_MEMv_ONE_64 [[gnu::used]] =
SHR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHR_GPRv_ONE_8 [[gnu::used]] = SHR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHR_GPRv_ONE_16 [[gnu::used]] =
SHR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHR_GPRv_ONE_32 [[gnu::used]] =
SHR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHR_GPRv_ONE_64 [[gnu::used]] =
SHR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHR_MEMb_CL [[gnu::used]] = SHR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHR_GPR8_CL [[gnu::used]] = SHR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHR_MEMv_CL_8 [[gnu::used]] = SHR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHR_MEMv_CL_16 [[gnu::used]] =
SHR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SHR_MEMv_CL_32 [[gnu::used]] =
SHR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SHR_MEMv_CL_64 [[gnu::used]] =
SHR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SHR_GPRv_CL_8 [[gnu::used]] = SHR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHR_GPRv_CL_16 [[gnu::used]] =
SHR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SHR_GPRv_CL_32 [[gnu::used]] =
SHR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SHR_GPRv_CL_64 [[gnu::used]] =
SHR<R64W, R64, R64>;

extern "C" constexpr auto ISEL_SAR_MEMb_IMMb [[gnu::used]] = SAR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SAR_GPR8_IMMb [[gnu::used]] = SAR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SAR_MEMv_IMMb_8 [[gnu::used]] = SAR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SAR_MEMv_IMMb_16 [[gnu::used]] =
SAR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SAR_MEMv_IMMb_32 [[gnu::used]] =
SAR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SAR_MEMv_IMMb_64 [[gnu::used]] =
SAR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SAR_GPRv_IMMb_8 [[gnu::used]] = SAR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SAR_GPRv_IMMb_16 [[gnu::used]] =
SAR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SAR_GPRv_IMMb_32 [[gnu::used]] =
SAR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SAR_GPRv_IMMb_64 [[gnu::used]] =
SAR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SAR_MEMb_ONE [[gnu::used]] = SAR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SAR_GPR8_ONE [[gnu::used]] = SAR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SAR_MEMv_ONE_8 [[gnu::used]] = SAR<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SAR_MEMv_ONE_16 [[gnu::used]] =
SAR<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SAR_MEMv_ONE_32 [[gnu::used]] =
SAR<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SAR_MEMv_ONE_64 [[gnu::used]] =
SAR<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SAR_GPRv_ONE_8 [[gnu::used]] = SAR<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SAR_GPRv_ONE_16 [[gnu::used]] =
SAR<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SAR_GPRv_ONE_32 [[gnu::used]] =
SAR<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SAR_GPRv_ONE_64 [[gnu::used]] =
SAR<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SAR_MEMb_CL [[gnu::used]] = SAR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SAR_GPR8_CL [[gnu::used]] = SAR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SAR_MEMv_CL_8 [[gnu::used]] = SAR<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SAR_MEMv_CL_16 [[gnu::used]] =
SAR<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SAR_MEMv_CL_32 [[gnu::used]] =
SAR<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SAR_MEMv_CL_64 [[gnu::used]] =
SAR<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SAR_GPRv_CL_8 [[gnu::used]] = SAR<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SAR_GPRv_CL_16 [[gnu::used]] =
SAR<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SAR_GPRv_CL_32 [[gnu::used]] =
SAR<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SAR_GPRv_CL_64 [[gnu::used]] =
SAR<R64W, R64, R64>;

extern "C" constexpr auto ISEL_SHL_MEMb_IMMb_C0r4 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_GPR8_IMMb_C0r4 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMb_IMMb_C0r6 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_GPR8_IMMb_C0r6 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r4_8 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r4_16 [[gnu::used]] =
SHL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r4_32 [[gnu::used]] =
SHL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r4_64 [[gnu::used]] =
SHL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r4_8 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r4_16 [[gnu::used]] =
SHL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r4_32 [[gnu::used]] =
SHL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r4_64 [[gnu::used]] =
SHL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r6_8 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r6_16 [[gnu::used]] =
SHL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r6_32 [[gnu::used]] =
SHL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHL_MEMv_IMMb_C1r6_64 [[gnu::used]] =
SHL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r6_8 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r6_16 [[gnu::used]] =
SHL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r6_32 [[gnu::used]] =
SHL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHL_GPRv_IMMb_C1r6_64 [[gnu::used]] =
SHL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHL_MEMb_ONE_D0r4 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_GPR8_ONE_D0r4 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMb_ONE_D0r6 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_GPR8_ONE_D0r6 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r6_8 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r6_16 [[gnu::used]] =
SHL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r6_32 [[gnu::used]] =
SHL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r6_64 [[gnu::used]] =
SHL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r6_8 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r6_16 [[gnu::used]] =
SHL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r6_32 [[gnu::used]] =
SHL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r6_64 [[gnu::used]] =
SHL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r4_8 [[gnu::used]] =
SHL<M8W, M8, I8>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r4_16 [[gnu::used]] =
SHL<M16W, M16, I16>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r4_32 [[gnu::used]] =
SHL<M32W, M32, I32>;
extern "C" constexpr auto ISEL_SHL_MEMv_ONE_D1r4_64 [[gnu::used]] =
SHL<M64W, M64, I64>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r4_8 [[gnu::used]] =
SHL<R8W, R8, I8>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r4_16 [[gnu::used]] =
SHL<R16W, R16, I16>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r4_32 [[gnu::used]] =
SHL<R32W, R32, I32>;
extern "C" constexpr auto ISEL_SHL_GPRv_ONE_D1r4_64 [[gnu::used]] =
SHL<R64W, R64, I64>;
extern "C" constexpr auto ISEL_SHL_MEMb_CL_D2r4 [[gnu::used]] =
SHL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHL_GPR8_CL_D2r4 [[gnu::used]] =
SHL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHL_MEMb_CL_D2r6 [[gnu::used]] =
SHL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHL_GPR8_CL_D2r6 [[gnu::used]] =
SHL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r4_8 [[gnu::used]] =
SHL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r4_16 [[gnu::used]] =
SHL<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r4_32 [[gnu::used]] =
SHL<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r4_64 [[gnu::used]] =
SHL<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r4_8 [[gnu::used]] =
SHL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r4_16 [[gnu::used]] =
SHL<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r4_32 [[gnu::used]] =
SHL<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r4_64 [[gnu::used]] =
SHL<R64W, R64, R64>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r6_8 [[gnu::used]] =
SHL<M8W, M8, R8>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r6_16 [[gnu::used]] =
SHL<M16W, M16, R16>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r6_32 [[gnu::used]] =
SHL<M32W, M32, R32>;
extern "C" constexpr auto ISEL_SHL_MEMv_CL_D3r6_64 [[gnu::used]] =
SHL<M64W, M64, R64>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r6_8 [[gnu::used]] =
SHL<R8W, R8, R8>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r6_16 [[gnu::used]] =
SHL<R16W, R16, R16>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r6_32 [[gnu::used]] =
SHL<R32W, R32, R32>;
extern "C" constexpr auto ISEL_SHL_GPRv_CL_D3r6_64 [[gnu::used]] =
SHL<R64W, R64, R64>;

namespace {

template <typename T>
[[gnu::always_inline]] inline static uint8_t SHRDCarryFlag(T val, T count) {
return UCmpEq(UAnd(UShr(val, USub(count, 1)), 1), 1);
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHRD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {
auto val1 = _Read(memory, src1);
auto val2 = _Read(memory, src2);
auto shift = _Read(memory, src3);

auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto shift_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_shift = UAnd(shift, shift_mask);

if (UCmpEq(masked_shift, 0)) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val1)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val1)));
} while (false);
} while (false);
return memory;

} else if (UCmpLt(op_size, masked_shift)) {
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val1)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val1)));
} while (false);
} while (false);
return memory;
}

auto left = UShl(val2, USub(op_size, masked_shift));
auto right = UShr(val1, masked_shift);
auto res = UOr(left, right);

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(SHRDCarryFlag(val1, masked_shift)),
"Bad write!");
memory =
_Write(memory, state.aflag.cf, (SHRDCarryFlag(val1, masked_shift)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(SignFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (SignFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(SignFlag(val1), state.aflag.sf)),
"Bad write!");
memory =
_Write(memory, state.aflag.of, (BXor(SignFlag(val1), state.aflag.sf)));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_IMMb_8 [[gnu::used]] =
SHRD<M8W, M8, R8, I8>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_IMMb_16 [[gnu::used]] =
SHRD<M16W, M16, R16, I16>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_IMMb_32 [[gnu::used]] =
SHRD<M32W, M32, R32, I32>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_IMMb_64 [[gnu::used]] =
SHRD<M64W, M64, R64, I64>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_IMMb_8 [[gnu::used]] =
SHRD<R8W, R8, R8, I8>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_IMMb_16 [[gnu::used]] =
SHRD<R16W, R16, R16, I16>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_IMMb_32 [[gnu::used]] =
SHRD<R32W, R32, R32, I32>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_IMMb_64 [[gnu::used]] =
SHRD<R64W, R64, R64, I64>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_CL_8 [[gnu::used]] =
SHRD<M8W, M8, R8, R8>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_CL_16 [[gnu::used]] =
SHRD<M16W, M16, R16, R16>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_CL_32 [[gnu::used]] =
SHRD<M32W, M32, R32, R32>;
extern "C" constexpr auto ISEL_SHRD_MEMv_GPRv_CL_64 [[gnu::used]] =
SHRD<M64W, M64, R64, R64>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_CL_8 [[gnu::used]] =
SHRD<R8W, R8, R8, R8>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_CL_16 [[gnu::used]] =
SHRD<R16W, R16, R16, R16>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_CL_32 [[gnu::used]] =
SHRD<R32W, R32, R32, R32>;
extern "C" constexpr auto ISEL_SHRD_GPRv_GPRv_CL_64 [[gnu::used]] =
SHRD<R64W, R64, R64, R64>;

namespace {

template <typename T>
[[gnu::always_inline]] inline static uint8_t SHLDCarryFlag(T val, T count) {
return UCmpEq(UAnd(UShr(val, USub(BitSizeOf(count), count)), 1), 1);
}

template <typename D, typename S1, typename S2, typename S3>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHLD(Memory *memory, State &state, D dst, S1 src1, S2 src2, S3 src3) {
auto val1 = _Read(memory, src1);
auto val2 = _Read(memory, src2);
auto shift = _Read(memory, src3);

auto long_mask = Literal<S1>(0x3F);
auto short_mask = Literal<S1>(0x1F);
auto op_size = BitSizeOf(src1);
auto shift_mask = Select(UCmpEq(op_size, 64), long_mask, short_mask);
auto masked_shift = UAnd(shift, shift_mask);

if (UCmpEq(masked_shift, 0)) {
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val1)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val1)));
} while (false);
} while (false);
return memory;

} else if (UCmpLt(op_size, masked_shift)) {
do {
state.aflag.cf = __remill_undefined_8();
state.aflag.pf = __remill_undefined_8();
state.aflag.af = __remill_undefined_8();
state.aflag.zf = __remill_undefined_8();
state.aflag.sf = __remill_undefined_8();
state.aflag.of = __remill_undefined_8();
} while (false);

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(val1)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(val1)));
} while (false);
} while (false);

return memory;
}

auto left = UShl(val1, masked_shift);
auto right = UShr(val2, USub(op_size, masked_shift));
auto res = UOr(left, right);

do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(res)),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(res)));
} while (false);
} while (false);

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(SHLDCarryFlag(val1, masked_shift)),
"Bad write!");
memory =
_Write(memory, state.aflag.cf, (SHLDCarryFlag(val1, masked_shift)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(ParityFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (ParityFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(__remill_undefined_8()),
"Bad write!");
memory = _Write(memory, state.aflag.af, (__remill_undefined_8()));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(ZeroFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (ZeroFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(SignFlag(res)),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (SignFlag(res)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(BXor(SignFlag(val1), state.aflag.sf)),
"Bad write!");
memory =
_Write(memory, state.aflag.of, (BXor(SignFlag(val1), state.aflag.sf)));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_IMMb_8 [[gnu::used]] =
SHLD<M8W, M8, R8, I8>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_IMMb_16 [[gnu::used]] =
SHLD<M16W, M16, R16, I16>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_IMMb_32 [[gnu::used]] =
SHLD<M32W, M32, R32, I32>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_IMMb_64 [[gnu::used]] =
SHLD<M64W, M64, R64, I64>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_IMMb_8 [[gnu::used]] =
SHLD<R8W, R8, R8, I8>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_IMMb_16 [[gnu::used]] =
SHLD<R16W, R16, R16, I16>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_IMMb_32 [[gnu::used]] =
SHLD<R32W, R32, R32, I32>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_IMMb_64 [[gnu::used]] =
SHLD<R64W, R64, R64, I64>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_CL_8 [[gnu::used]] =
SHLD<M8W, M8, R8, R8>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_CL_16 [[gnu::used]] =
SHLD<M16W, M16, R16, R16>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_CL_32 [[gnu::used]] =
SHLD<M32W, M32, R32, R32>;
extern "C" constexpr auto ISEL_SHLD_MEMv_GPRv_CL_64 [[gnu::used]] =
SHLD<M64W, M64, R64, R64>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_CL_8 [[gnu::used]] =
SHLD<R8W, R8, R8, R8>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_CL_16 [[gnu::used]] =
SHLD<R16W, R16, R16, R16>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_CL_32 [[gnu::used]] =
SHLD<R32W, R32, R32, R32>;
extern "C" constexpr auto ISEL_SHLD_GPRv_GPRv_CL_64 [[gnu::used]] =
SHLD<R64W, R64, R64, R64>;

namespace {

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSLLDQ(Memory *memory, State &state, D dst, V128 src1, I8 src2) {
uint8v16_t src1_vec = _UReadV8(memory, src1);
uint8v16_t dst_vec = {};
size_t shift_amount =
std::min<size_t>(ZExtTo<size_t>(_Read(memory, src2)), 16);

#pragma unroll
for (size_t i = 0; i < 16; ++i) {
if (i < (16 - shift_amount)) {
dst_vec = UInsertV8(dst_vec, i + shift_amount, UExtractV8(src1_vec, i));
}
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPSLLDQ(Memory *memory, State &state, D dst, V256 src1, I8 src2) {
uint8v32_t src1_vec = _UReadV8(memory, src1);
uint8v32_t dst_vec = {};
size_t shift_amount =
std::min<size_t>(ZExtTo<size_t>(_Read(memory, src2)), 16);

#pragma unroll
for (size_t i = 0, j = 16; i < 16; ++i, ++j) {
if (i < (16 - shift_amount)) {
dst_vec = UInsertV8(dst_vec, i + shift_amount, UExtractV8(src1_vec, i));
dst_vec = UInsertV8(dst_vec, j + shift_amount, UExtractV8(src1_vec, j));
}
}
do {
memory = _UWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSLLDQ_XMMdq_IMMb [[gnu::used]] = PSLLDQ<V128W>;
extern "C" constexpr auto ISEL_VPSLLDQ_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSLLDQ<VV128W>;
extern "C" constexpr auto ISEL_VPSLLDQ_YMMqq_YMMqq_IMMb [[gnu::used]] =
VPSLLDQ<VV256W>;

#pragma clang diagnostic ignored "-Wpass-failed"

namespace {

enum FloatCompareOperator {
kEqOrderedQuiet,
kLtOrderedSignal,
kLeOrderedSignal,
kUnorderedQuiet,
kNeUnorderedQuiet,
kNltUnorderedSignal,
kNleUnorderedSignal,
kOrderedQuiet,
kEqUnorderedQuiet,
kNgeUnorderedSignal,
kNgtUnorderedSignal,
kFalseOrderedQuiet,
kNeOrderedQuiet,
kGeOrderedSignal,
kGtOrderedSignal,
kTrueUnorderedQuiet,
kEqOrderedSignal,
kLtOrderedQuiet,
kLeOrderedQuiet,
kUnorderedSignal,
kNeUnorderedSignal,
kNltUnorderedQuiet,
kNleUnorderedQuiet,
kOrderedSignal,
kEqUnorderedSignal,
kNgeUnorderedQuiet,
kNgtUnorderedQuiet,
kFalseOrderedSignal,
kNeOrderedSignal,
kGeOrderedQuiet,
kGtOrderedQuiet,
kTrueUnorderedSignal,
};

template <typename T>
[[gnu::always_inline]] inline static bool CompareFloats(FloatCompareOperator op,
T v1, T v2) {
auto is_unordered = __builtin_isunordered(v1, v2);
auto is_ordered = !is_unordered;
switch (op) {
case kEqOrderedQuiet:
return !__builtin_islessgreater(v1, v2) && is_ordered;
case kLtOrderedSignal:
return v1 < v2 && is_ordered;
case kLeOrderedSignal:
return v1 <= v2 && is_ordered;
case kUnorderedQuiet:
return is_unordered;
case kNeUnorderedQuiet:
return __builtin_islessgreater(v1, v2) || is_unordered;
case kNltUnorderedSignal:
return !(v1 < v2) || is_unordered;
case kNleUnorderedSignal:
return !(v1 <= v2) || is_unordered;
case kOrderedQuiet:
return is_ordered;
case kEqUnorderedQuiet:
return !__builtin_islessgreater(v1, v2);
case kNgeUnorderedSignal:
return !(v1 >= v2) || is_unordered;
case kNgtUnorderedSignal:
return !(v1 > v2) || is_unordered;
case kFalseOrderedQuiet:
return false;
case kNeOrderedQuiet:
return __builtin_islessgreater(v1, v2);
case kGeOrderedSignal:
return v1 >= v2 && is_ordered;
case kGtOrderedSignal:
return v1 > v2 && is_ordered;
case kTrueUnorderedQuiet:
return true;
case kEqOrderedSignal:
return v1 == v2 && is_ordered;
case kLtOrderedQuiet:
return __builtin_isless(v1, v2);
case kLeOrderedQuiet:
return __builtin_islessequal(v1, v2);
case kUnorderedSignal:
return is_unordered;
case kNeUnorderedSignal:
return v1 != v2 || is_unordered;
case kNltUnorderedQuiet:
return !__builtin_isless(v1, v2);
case kNleUnorderedQuiet:
return !__builtin_islessequal(v1, v2);
case kOrderedSignal:
return is_ordered;
case kEqUnorderedSignal:
return v1 == v2 || is_unordered;
case kNgeUnorderedQuiet:
return !__builtin_isgreaterequal(v1, v2);
case kNgtUnorderedQuiet:
return !__builtin_isgreater(v1, v2);
case kFalseOrderedSignal:
return false;
case kNeOrderedSignal:
return !(v1 == v2) && is_ordered;
case kGeOrderedQuiet:
return __builtin_isgreaterequal(v1, v2);
case kGtOrderedQuiet:
return __builtin_isgreater(v1, v2);
case kTrueUnorderedSignal:
return true;
}
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
COMISS(Memory *memory, State &state, S1 src1, S2 src2) {
auto left = FExtractV32(_FReadV32(memory, src1), 0);
auto right = FExtractV32(_FReadV32(memory, src2), 0);

if (__builtin_isunordered(left, right)) {
if (IsSignalingNaN(left + right)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (true));
} while (false);

} else if (FCmpGt(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (false));
} while (false);
} else if (FCmpLt(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (true));
} while (false);

} else if (FCmpEq(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (false));
} while (false);
}

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.of, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.af, (false));
} while (false);
return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
COMISD(Memory *memory, State &state, S1 src1, S2 src2) {
auto left = FExtractV64(_FReadV64(memory, src1), 0);
auto right = FExtractV64(_FReadV64(memory, src2), 0);

if (__builtin_isunordered(left, right)) {
if (IsSignalingNaN(left + right)) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}

do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (true));
} while (false);

} else if (FCmpGt(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (false));
} while (false);
} else if (FCmpLt(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (true));
} while (false);

} else if (FCmpEq(left, right)) {
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(true),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (true));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (false));
} while (false);
}
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.of, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.af, (false));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_COMISD_XMMsd_MEMsd [[gnu::used]] =
COMISD<V128, MV64>;
extern "C" constexpr auto ISEL_COMISD_XMMsd_XMMsd [[gnu::used]] =
COMISD<V128, V128>;
extern "C" constexpr auto ISEL_COMISS_XMMss_MEMss [[gnu::used]] =
COMISS<V128, MV32>;
extern "C" constexpr auto ISEL_COMISS_XMMss_XMMss [[gnu::used]] =
COMISS<V128, V128>;

extern "C" constexpr auto ISEL_VCOMISD_XMMq_MEMq [[gnu::used]] =
COMISD<V128, MV64>;
extern "C" constexpr auto ISEL_VCOMISD_XMMq_XMMq [[gnu::used]] =
COMISD<V128, V128>;
extern "C" constexpr auto ISEL_VCOMISS_XMMd_MEMd [[gnu::used]] =
COMISS<V128, MV32>;
extern "C" constexpr auto ISEL_VCOMISS_XMMd_XMMd [[gnu::used]] =
COMISS<V128, V128>;

extern "C" constexpr auto ISEL_UCOMISD_XMMsd_MEMsd [[gnu::used]] =
COMISD<V128, MV64>;
extern "C" constexpr auto ISEL_UCOMISD_XMMsd_XMMsd [[gnu::used]] =
COMISD<V128, V128>;
extern "C" constexpr auto ISEL_UCOMISS_XMMss_MEMss [[gnu::used]] =
COMISS<V128, MV32>;
extern "C" constexpr auto ISEL_UCOMISS_XMMss_XMMss [[gnu::used]] =
COMISS<V128, V128>;

extern "C" constexpr auto ISEL_VUCOMISD_XMMdq_MEMq [[gnu::used]] =
COMISD<V128, MV64>;
extern "C" constexpr auto ISEL_VUCOMISD_XMMdq_XMMq [[gnu::used]] =
COMISD<V128, V128>;
extern "C" constexpr auto ISEL_VUCOMISS_XMMdq_MEMd [[gnu::used]] =
COMISS<V128, MV32>;
extern "C" constexpr auto ISEL_VUCOMISS_XMMdq_XMMd [[gnu::used]] =
COMISS<V128, V128>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHUFPS(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, src1))>();
auto src1_vec = _UReadV32(memory, src1);
auto src2_vec = _UReadV32(memory, src2);
auto imm = _Read(memory, src3);
auto num_groups =
static_cast<addr_t>(VectorType<decltype(dst_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < num_groups; ++i) {
auto order = UShr8(imm, TruncTo<uint8_t>(i * 2));
auto sel = UAnd8(order, 0x3_u8);
auto sel_val = UExtractV32(Select(i < 2, src1_vec, src2_vec), sel);
dst_vec.elems[i] = sel_val;
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SHUFPS_XMMps_XMMps_IMMb [[gnu::used]] =
SHUFPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_SHUFPS_XMMps_MEMps_IMMb [[gnu::used]] =
SHUFPS<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SHUFPD(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, src1))>();
auto src1_vec = _UReadV64(memory, src1);
auto src2_vec = _UReadV64(memory, src2);
auto imm = _Read(memory, src3);
auto num_groups =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < num_groups; i += 2) {
auto order = UShr8(imm, TruncTo<uint8_t>(i));
auto sel1 = UAnd8(order, 0x1_u8);
auto sel2 = Select(UAnd8(order, 0x2_u8) == 0x2_u8, 1_u8, 0_u8);
dst_vec.elems[i] = UExtractV64(src1_vec, i + sel1);
dst_vec.elems[i + 1] = UExtractV64(src2_vec, i + sel2);
}

do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SHUFPD_XMMpd_XMMpd_IMMb [[gnu::used]] =
SHUFPD<V128W, V128, V128>;

namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSHUFD(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, src1))>();
auto src_vec = _UReadV128(memory, src1);
auto num_groups =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0, k = 0; i < num_groups; ++i) {
auto group = UExtractV128(src_vec, i);
auto order = _Read(memory, src2);

#pragma unroll
for (std::size_t j = 0; j < 4; ++j, ++k) {
auto sel = UAnd(order, 0x3_u8);
auto shift = UMul(sel, 32_u8);
order = UShr(order, 2_u8);
auto sel_val = UShr(group, UInt128(shift));
UUpdateV32(dst_vec, k, TruncTo<uint32_t>(sel_val));
}
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSHUFD_XMMdq_MEMdq_IMMb [[gnu::used]] =
PSHUFD<V128W, MV128>;
extern "C" constexpr auto ISEL_PSHUFD_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSHUFD<V128W, V128>;
extern "C" constexpr auto ISEL_VPSHUFD_XMMdq_MEMdq_IMMb [[gnu::used]] =
PSHUFD<VV128W, MV128>;
extern "C" constexpr auto ISEL_VPSHUFD_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSHUFD<VV128W, V128>;
extern "C" constexpr auto ISEL_VPSHUFD_YMMqq_MEMqq_IMMb [[gnu::used]] =
PSHUFD<VV256W, MV256>;
extern "C" constexpr auto ISEL_VPSHUFD_YMMqq_YMMqq_IMMb [[gnu::used]] =
PSHUFD<VV256W, V256>;
namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSHUFLW(Memory *memory, State &state, D dst, S1 src1, I8 src2) {

auto src_vec = _UReadV128(memory, src1);
auto src_words_vec = _UReadV16(memory, src1);

auto dst_vec = _ZeroVec<uint16_t, decltype(_UReadV16(memory, dst))>();

auto num_lanes = static_cast<addr_t>(
VectorType<decltype(_UReadV128(memory, src1))>::kNumElems);

#pragma unroll
for (std::size_t lane_index = 0, word_index = 0; lane_index < num_lanes;
++lane_index) {
auto lane = UExtractV128(src_vec, lane_index);

auto order = _Read(memory, src2);

#pragma unroll
for (std::size_t word_count = 0; word_count < 4;
++word_count, ++word_index) {
auto sel = UAnd(order, 0x3_u8);
auto shift = UMul(sel, 16_u8);
order = UShr(order, 2_u8);
auto sel_val = UShr(lane, UInt128(shift));
dst_vec = UInsertV16(dst_vec, word_index, TruncTo<uint16_t>(sel_val));
}

#pragma unroll
for (std::size_t word_count = 0; word_count < 4;
++word_count, ++word_index) {
dst_vec = UInsertV16(dst_vec, word_index,
UExtractV16(src_words_vec, word_index));
}
}

do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSHUFHW(Memory *memory, State &state, D dst, S1 src1, I8 src2) {
auto dst_vec = _UReadV16(memory, src1);
auto src_vec = _UReadV16(memory, src1);
auto imm = _Read(memory, src2);
auto num_groups =
static_cast<addr_t>(VectorType<decltype(src_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 4; i < num_groups; ++i) {
auto order = UShr8(imm, TruncTo<uint8_t>((i - 4) * 2_u8));
auto sel = UAnd8(order, 0x3_u8);
auto sel_val = UExtractV16(src_vec, sel + 4);
dst_vec.elems[i] = sel_val;
}
do {
memory = _UWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSHUFLW_XMMdq_MEMdq_IMMb [[gnu::used]] =
PSHUFLW<V128W, MV128>;
extern "C" constexpr auto ISEL_PSHUFLW_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSHUFLW<V128W, V128>;
extern "C" constexpr auto ISEL_VPSHUFLW_XMMdq_MEMdq_IMMb [[gnu::used]] =
PSHUFLW<VV128W, MV128>;
extern "C" constexpr auto ISEL_VPSHUFLW_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSHUFLW<VV128W, V128>;
extern "C" constexpr auto ISEL_VPSHUFLW_YMMqq_MEMqq_IMMb [[gnu::used]] =
PSHUFLW<VV256W, MV256>;
extern "C" constexpr auto ISEL_VPSHUFLW_YMMqq_YMMqq_IMMb [[gnu::used]] =
PSHUFLW<VV256W, V256>;
extern "C" constexpr auto ISEL_PSHUFHW_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSHUFHW<V128W, V128>;

namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPGTQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV64(memory, src1);
auto src2_vec = _SReadV64(memory, src2);
auto dst_vec = _ZeroVec<int64_t, decltype(_SReadV64(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV64(src1_vec, i);
auto src2_elem = SExtractV64(src2_vec, i);
auto res = Select<int64_t>(SCmpGt(src1_elem, src2_elem), -1_s64, 0_s64);
dst_vec = SInsertV64(dst_vec, i, res);
}
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPGTW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV16(src1_vec, i);
auto src2_elem = SExtractV16(src2_vec, i);
auto res = Select<int16_t>(SCmpGt(src1_elem, src2_elem), -1_s16, 0_s16);
dst_vec = SInsertV16(dst_vec, i, res);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPGTB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV8(memory, src1);
auto src2_vec = _SReadV8(memory, src2);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV8(src1_vec, i);
auto src2_elem = SExtractV8(src2_vec, i);
auto res = Select<int8_t>(SCmpGt(src1_elem, src2_elem), -1_s8, 0_s8);
dst_vec = SInsertV8(dst_vec, i, res);
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPGTD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV32(src1_vec, i);
auto src2_elem = SExtractV32(src2_vec, i);
auto res = Select<int32_t>(SCmpGt(src1_elem, src2_elem), -1_s32, 0_s32);
dst_vec = SInsertV32(dst_vec, i, res);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPEQQ(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV64(memory, src1);
auto src2_vec = _SReadV64(memory, src2);
auto dst_vec = _ZeroVec<int64_t, decltype(_SReadV64(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV64(src1_vec, i);
auto src2_elem = SExtractV64(src2_vec, i);
auto res = Select<int64_t>(SCmpEq(src1_elem, src2_elem), -1_s64, 0_s64);
dst_vec = SInsertV64(dst_vec, i, res);
}
do {
memory = _SWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPEQW(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);
auto dst_vec = _ZeroVec<int16_t, decltype(_SReadV16(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV16(src1_vec, i);
auto src2_elem = SExtractV16(src2_vec, i);
auto res = Select<int16_t>(SCmpEq(src1_elem, src2_elem), -1_s16, 0_s16);
dst_vec = SInsertV16(dst_vec, i, res);
}
do {
memory = _SWriteV16(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPEQB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV8(memory, src1);
auto src2_vec = _SReadV8(memory, src2);
auto dst_vec = _ZeroVec<int8_t, decltype(_SReadV8(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV8(src1_vec, i);
auto src2_elem = SExtractV8(src2_vec, i);
auto res = Select<int8_t>(SCmpEq(src1_elem, src2_elem), -1_s8, 0_s8);
dst_vec = SInsertV8(dst_vec, i, res);
}
do {
memory = _SWriteV8(memory, dst, (dst_vec));
} while (false);
return memory;
}
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPEQD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV32(memory, src1);
auto src2_vec = _SReadV32(memory, src2);
auto dst_vec = _ZeroVec<int32_t, decltype(_SReadV32(memory, dst))>();
auto num_elems =
static_cast<addr_t>(VectorType<decltype(src1_vec)>::kNumElems);
#pragma unroll
for (std::size_t i = 0; i < num_elems; ++i) {
auto src1_elem = SExtractV32(src1_vec, i);
auto src2_elem = SExtractV32(src2_vec, i);
auto res = Select<int32_t>(SCmpEq(src1_elem, src2_elem), -1_s32, 0_s32);
dst_vec = SInsertV32(dst_vec, i, res);
}
do {
memory = _SWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_PCMPGTB_MMXq_MMXq [[gnu::used]] =
PCMPGTB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPGTB_MMXq_MEMq [[gnu::used]] =
PCMPGTB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PCMPGTW_MMXq_MMXq [[gnu::used]] =
PCMPGTW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPGTW_MMXq_MEMq [[gnu::used]] =
PCMPGTW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PCMPGTD_MMXq_MMXq [[gnu::used]] =
PCMPGTD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPGTD_MMXq_MEMq [[gnu::used]] =
PCMPGTD<V64W, V64, MV64>;

extern "C" constexpr auto ISEL_PCMPGTQ_XMMdq_MEMdq [[gnu::used]] =
PCMPGTQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPGTQ_XMMdq_XMMdq [[gnu::used]] =
PCMPGTQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPGTW_XMMdq_MEMdq [[gnu::used]] =
PCMPGTW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPGTW_XMMdq_XMMdq [[gnu::used]] =
PCMPGTW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPGTB_XMMdq_MEMdq [[gnu::used]] =
PCMPGTB<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPGTB_XMMdq_XMMdq [[gnu::used]] =
PCMPGTB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPGTD_XMMdq_MEMdq [[gnu::used]] =
PCMPGTD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPGTD_XMMdq_XMMdq [[gnu::used]] =
PCMPGTD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VPCMPGTQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPGTQ<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPGTQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPGTQ<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPGTQ_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPGTQ<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPGTQ_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPGTQ<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPGTW_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPGTW<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPGTW_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPGTW<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPGTW_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPGTW<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPGTW_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPGTW<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPGTB_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPGTB<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPGTB_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPGTB<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPGTB_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPGTB<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPGTB_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPGTB<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPGTD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPGTD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPGTD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPGTD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPGTD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPGTD<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPGTD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPGTD<VV256W, V256, V256>;

extern "C" constexpr auto ISEL_PCMPEQB_MMXq_MMXq [[gnu::used]] =
PCMPEQB<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPEQB_MMXq_MEMq [[gnu::used]] =
PCMPEQB<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PCMPEQW_MMXq_MMXq [[gnu::used]] =
PCMPEQW<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPEQW_MMXq_MEMq [[gnu::used]] =
PCMPEQW<V64W, V64, MV64>;
extern "C" constexpr auto ISEL_PCMPEQD_MMXq_MMXq [[gnu::used]] =
PCMPEQD<V64W, V64, V64>;
extern "C" constexpr auto ISEL_PCMPEQD_MMXq_MEMq [[gnu::used]] =
PCMPEQD<V64W, V64, MV64>;

extern "C" constexpr auto ISEL_PCMPEQQ_XMMdq_MEMdq [[gnu::used]] =
PCMPEQQ<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPEQQ_XMMdq_XMMdq [[gnu::used]] =
PCMPEQQ<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPEQW_XMMdq_MEMdq [[gnu::used]] =
PCMPEQW<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPEQW_XMMdq_XMMdq [[gnu::used]] =
PCMPEQW<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPEQB_XMMdq_MEMdq [[gnu::used]] =
PCMPEQB<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPEQB_XMMdq_XMMdq [[gnu::used]] =
PCMPEQB<V128W, V128, V128>;
extern "C" constexpr auto ISEL_PCMPEQD_XMMdq_MEMdq [[gnu::used]] =
PCMPEQD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_PCMPEQD_XMMdq_XMMdq [[gnu::used]] =
PCMPEQD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VPCMPEQQ_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPEQQ<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPEQQ_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPEQQ<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPEQQ_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPEQQ<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPEQQ_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPEQQ<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPEQW_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPEQW<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPEQW_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPEQW<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPEQW_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPEQW<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPEQW_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPEQW<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPEQB_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPEQB<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPEQB_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPEQB<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPEQB_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPEQB<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPEQB_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPEQB<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VPCMPEQD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PCMPEQD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VPCMPEQD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PCMPEQD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VPCMPEQD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PCMPEQD<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VPCMPEQD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PCMPEQD<VV256W, V256, V256>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPSS(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();
auto op = _Read(memory, src3);
if (op >= 32) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}
auto v1 = FExtractV32(src1_vec, 0);
auto v2 = FExtractV32(src2_vec, 0);
bool cond =
CompareFloats<float32_t>(static_cast<FloatCompareOperator>(op), v1, v2);

dst_vec = UInsertV32(dst_vec, 0, Select<uint32_t>(cond, ~0_u32, 0_u32));

do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPSD(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto src1_vec = _FReadV64(memory, src1);
auto src2_vec = _FReadV64(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto op = _Read(memory, src3);
if (op >= 32) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}
auto v1 = FExtractV64(src1_vec, 0);
auto v2 = FExtractV64(src2_vec, 0);
bool cond =
CompareFloats<float64_t>(static_cast<FloatCompareOperator>(op), v1, v2);

dst_vec = UInsertV64(dst_vec, 0, Select<uint64_t>(cond, ~0_u64, 0_u64));

do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CMPSS_XMMss_MEMss_IMMb [[gnu::used]] =
CMPSS<V128W, V128, MV32>;
extern "C" constexpr auto ISEL_CMPSS_XMMss_XMMss_IMMb [[gnu::used]] =
CMPSS<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VCMPSS_XMMdq_XMMdq_MEMd_IMMb [[gnu::used]] =
CMPSS<VV128W, V128, MV32>;
extern "C" constexpr auto ISEL_VCMPSS_XMMdq_XMMdq_XMMd_IMMb [[gnu::used]] =
CMPSS<VV128W, V128, V128>;

extern "C" constexpr auto ISEL_CMPSD_XMM_XMMsd_MEMsd_IMMb [[gnu::used]] =
CMPSD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_CMPSD_XMM_XMMsd_XMMsd_IMMb [[gnu::used]] =
CMPSD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VCMPSD_XMMdq_XMMdq_MEMq_IMMb [[gnu::used]] =
CMPSD<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VCMPSD_XMMdq_XMMdq_XMMq_IMMb [[gnu::used]] =
CMPSD<VV128W, V128, V128>;

namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPPS(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);
auto dst_vec = _ZeroVec<uint32_t, decltype(_UReadV32(memory, dst))>();
auto op = _Read(memory, src3);
if (op >= 32) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < vec_count; i++) {
auto v1 = FExtractV32(src1_vec, i);
auto v2 = FExtractV32(src2_vec, i);

bool cond =
CompareFloats<float32_t>(static_cast<FloatCompareOperator>(op), v1, v2);

auto res = Select<uint32_t>(cond, ~0_u32, 0_u32);
dst_vec = UInsertV32(dst_vec, i, res);
}
do {
memory = _UWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
CMPPD(Memory *memory, State &state, D dst, S1 src1, S2 src2, I8 src3) {
auto src1_vec = _FReadV64(memory, src1);
auto src2_vec = _FReadV64(memory, src2);
auto dst_vec = _ZeroVec<uint64_t, decltype(_UReadV64(memory, dst))>();
auto op = _Read(memory, src3);
if (op >= 32) {
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < vec_count; i++) {
auto v1 = FExtractV64(src1_vec, i);
auto v2 = FExtractV64(src2_vec, i);

bool cond =
CompareFloats<float64_t>(static_cast<FloatCompareOperator>(op), v1, v2);

auto res = Select<uint64_t>(cond, ~0_u64, 0_u64);
dst_vec = UInsertV64(dst_vec, i, res);
}
do {
memory = _UWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_CMPPS_XMMps_MEMps_IMMb [[gnu::used]] =
CMPPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_CMPPS_XMMps_XMMps_IMMb [[gnu::used]] =
CMPPS<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VCMPPS_XMMdq_XMMdq_MEMdq_IMMb [[gnu::used]] =
CMPPS<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VCMPPS_XMMdq_XMMdq_XMMdq_IMMb [[gnu::used]] =
CMPPS<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VCMPPS_YMMqq_YMMqq_MEMqq_IMMb [[gnu::used]] =
CMPPS<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VCMPPS_YMMqq_YMMqq_YMMqq_IMMb [[gnu::used]] =
CMPPS<VV256W, V256, V256>;

extern "C" constexpr auto ISEL_CMPPD_XMMpd_MEMpd_IMMb [[gnu::used]] =
CMPPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_CMPPD_XMMpd_XMMpd_IMMb [[gnu::used]] =
CMPPD<V128W, V128, V128>;

extern "C" constexpr auto ISEL_VCMPPD_XMMdq_XMMdq_MEMdq_IMMb [[gnu::used]] =
CMPPD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VCMPPD_XMMdq_XMMdq_XMMdq_IMMb [[gnu::used]] =
CMPPD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VCMPPD_YMMqq_YMMqq_MEMqq_IMMb [[gnu::used]] =
CMPPD<VV256W, V256, MV256>;
extern "C" constexpr auto ISEL_VCMPPD_YMMqq_YMMqq_YMMqq_IMMb [[gnu::used]] =
CMPPD<VV256W, V256, V256>;

namespace {

enum InputFormat : uint8_t { kUInt8 = 0, kUInt16 = 1, kInt8 = 2, kInt16 = 3 };

enum AggregationOperation : uint8_t {
kEqualAny = 0,
kRanges = 1,
kEqualEach = 2,
kEqualOrdered = 3
};

enum Polarity : uint8_t {
kPositive = 0,
kNegative = 1,
kMaskedPositive = 2,
kMaskedNegative = 3
};

enum OutputSelection : uint8_t {
kLeastSignificantIndex = 0,
kMostSignificantIndex = 1
};

union StringCompareControl {
uint8_t flat;
struct {
uint8_t input_format : 2;
uint8_t agg_operation : 2;
uint8_t polarity : 2;
uint8_t output_selection : 1;
uint8_t should_be_0 : 1;
} __attribute__((packed));
} __attribute__((packed));

static_assert(1 == sizeof(StringCompareControl),
"Invalid packing of `StringCompareControl`.");

template <size_t x, size_t y> class BitMatrix : std::bitset<x * y> {
public:
[[gnu::always_inline]] inline bool Test(size_t i, size_t j) const {
return this->operator[]((x * i) + j);
}

[[gnu::always_inline]] inline void Set(size_t i, size_t j, bool val) {
this->operator[]((x * i) + j) = val;
}

private:
bool rows[x][y];
};

template <size_t num_elems>
[[gnu::always_inline]] inline static uint16_t
AggregateEqualAny(const BitMatrix<num_elems, num_elems> &bool_res,
const size_t src1_len, const size_t src2_len) {

uint16_t int_res_1 = 0;
uint16_t bit = 1;
for (size_t j = 0; j < src2_len; ++j, bit <<= 1) {

#pragma unroll
for (size_t i = 0; i < src1_len; ++i) {
if (bool_res.Test(i, j)) {
int_res_1 |= bit;
break;
}
}
}
return int_res_1;
}

template <size_t num_elems>
[[gnu::always_inline]] inline static uint16_t
AggregateRanges(const BitMatrix<num_elems, num_elems> &bool_res,
const size_t src1_len, const size_t src2_len) {

uint16_t int_res_1 = 0;
uint16_t bit = 1;

for (size_t j = 0; j < src2_len; ++j, bit <<= 1) {

#pragma unroll
for (size_t i = 0; i < (src1_len - 1); i += 2) {
const auto geq_lower_bound = bool_res.Test(i, j);
const auto leq_upper_bound = bool_res.Test(i + 1, j);
if (geq_lower_bound && leq_upper_bound) {
int_res_1 |= bit;
break;
}
}
}
return int_res_1;
}

template <size_t num_elems>
[[gnu::always_inline]] inline static uint16_t
AggregateEqualEach(const BitMatrix<num_elems, num_elems> &bool_res,
const size_t src1_len, const size_t src2_len) {

uint16_t int_res_1 = 0;
uint16_t bit = 1;

#pragma unroll
for (size_t i = 0; i < num_elems; ++i, bit <<= 1) {
const bool in_str1 = i < src1_len;
const bool in_str2 = i < src2_len;
if (in_str1 && in_str2) {
if (bool_res.Test(i, i)) {
int_res_1 |= bit;
}
} else if (!in_str1 && !in_str2) {
int_res_1 |= bit;
}
}
return int_res_1;
}

template <size_t num_elems>
[[gnu::always_inline]] inline static uint16_t
AggregateEqualOrdered(const BitMatrix<num_elems, num_elems> &bool_res,
const size_t src1_len, const size_t src2_len) {

if (src1_len > src2_len) {
return 0;
}

uint16_t int_res_1 = (0xFFFF_u16 >> (16 - num_elems));
uint16_t bit = 1;

for (size_t j = 0; j < num_elems; ++j, bit <<= 1) {

#pragma unroll
for (size_t i = 0, k = j; i < (num_elems - j) && k < num_elems; ++i, ++k) {
auto needle_valid = i < src1_len;
auto haystack_valid = k < src2_len;

if (!needle_valid) {
break;
} else if (!haystack_valid || !bool_res.Test(i, k)) {
int_res_1 ^= bit;
break;
}
}
}

return int_res_1;
}

template <typename V, size_t num_elems>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoPCMPISTRI(Memory *memory, State &state, const V &src1, const V &src2,
StringCompareControl control) {
BitMatrix<num_elems, num_elems> bool_res;
size_t src1_len = num_elems;
size_t src2_len = num_elems;

const auto agg_operation =
static_cast<AggregationOperation>(control.agg_operation);

const auto polarity = static_cast<Polarity>(control.polarity);
const auto output_selection =
static_cast<OutputSelection>(control.output_selection);

#pragma unroll
for (size_t i = 0; i < num_elems; ++i) {
if (!src1.elems[i]) {
src1_len = std::min<size_t>(src1_len, i);
}
if (!src2.elems[i]) {
src2_len = std::min<size_t>(src2_len, i);
}
}

for (size_t n = 0; n < num_elems; ++n) {
const auto reg = src1.elems[n];

#pragma unroll
for (size_t m = 0; m < num_elems; ++m) {
const auto reg_mem = src2.elems[m];

switch (agg_operation) {
case kEqualAny:
case kEqualEach:
case kEqualOrdered:
bool_res.Set(n, m, reg == reg_mem);
break;

case kRanges:
if (n & 1U) {
bool_res.Set(n, m, reg_mem <= reg);
} else {
bool_res.Set(n, m, reg_mem >= reg);
}
break;
}
}
}

uint16_t int_res_1 = 0;

switch (agg_operation) {
case kEqualAny:
int_res_1 = AggregateEqualAny<num_elems>(bool_res, src1_len, src2_len);
break;
case kRanges:
int_res_1 = AggregateRanges<num_elems>(bool_res, src1_len, src2_len);
break;
case kEqualEach:
int_res_1 = AggregateEqualEach<num_elems>(bool_res, src1_len, src2_len);
break;
case kEqualOrdered:
int_res_1 = AggregateEqualOrdered<num_elems>(bool_res, src1_len, src2_len);
break;
}

uint16_t int_res_2 = 0;
switch (polarity) {
case kPositive:
int_res_2 = int_res_1;
break;
case kNegative:
int_res_2 = (0xFFFF_u16 >> (16 - num_elems)) ^ int_res_1;
break;
case kMaskedPositive:
int_res_2 = int_res_1;
break;
case kMaskedNegative:
int_res_2 = int_res_1;

#pragma unroll
for (size_t i = 0; i < num_elems; ++i) {
auto mask = static_cast<uint16_t>(1_u16 << i);
if (i < src2_len) {
int_res_2 ^= mask;
}
}
break;
}

uint16_t index = num_elems;
switch (output_selection) {
case kLeastSignificantIndex:
if (auto lsb_index = __builtin_ffs(int_res_2)) {
index = static_cast<uint16_t>(lsb_index - 1);
}
break;
case kMostSignificantIndex:
if (int_res_2) {
uint16_t count = CountLeadingZeros(int_res_2) - (16_u16 - num_elems);
index = num_elems - count - 1;
}
break;
}

do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(static_cast<addr_t>(index)),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (static_cast<addr_t>(index)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(int_res_2 != 0_u16),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (int_res_2 != 0_u16));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(src2_len < num_elems),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (src2_len < num_elems));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(src1_len < num_elems),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (src1_len < num_elems));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(0_u16 != (int_res_2 & 1_u16)),
"Bad write!");
memory = _Write(memory, state.aflag.of, (0_u16 != (int_res_2 & 1_u16)));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.af, (false));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(false),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (false));
} while (false);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PCMPISTRI(Memory *memory, State &state, V128 src1, S2 src2, I8 src3) {
const StringCompareControl control = {.flat = _Read(memory, src3)};
switch (static_cast<InputFormat>(control.input_format)) {
case kUInt8:
return DoPCMPISTRI<uint8v16_t, 16>(memory, state, _UReadV8(memory, src1),
_UReadV8(memory, src2), control);
case kUInt16:
return DoPCMPISTRI<uint16v8_t, 8>(memory, state, _UReadV16(memory, src1),
_UReadV16(memory, src2), control);
case kInt8:
return DoPCMPISTRI<int8v16_t, 16>(memory, state, _SReadV8(memory, src1),
_SReadV8(memory, src2), control);
case kInt16:
return DoPCMPISTRI<int16v8_t, 8>(memory, state, _SReadV16(memory, src1),
_SReadV16(memory, src2), control);
}
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PCMPISTRI_XMMdq_XMMdq_IMMb [[gnu::used]] =
PCMPISTRI<V128>;
extern "C" constexpr auto ISEL_PCMPISTRI_XMMdq_MEMdq_IMMb [[gnu::used]] =
PCMPISTRI<MV128>;
extern "C" constexpr auto ISEL_VPCMPISTRI_XMMdq_XMMdq_IMMb [[gnu::used]] =
PCMPISTRI<V128>;
extern "C" constexpr auto ISEL_VPCMPISTRI_XMMdq_MEMdq_IMMb [[gnu::used]] =
PCMPISTRI<MV128>;

namespace {

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PSRLDQ(Memory *memory, State &state, D dst, S src1, I8 src2) {
auto vec = _UReadV8(memory, src1);
auto new_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto shift = std::min<size_t>(_Read(memory, src2), 16);

#pragma unroll
for (size_t i = shift, j = 0; i < 16; ++i, ++j) {
new_vec = UInsertV8(new_vec, j, UExtractV8(vec, i));
}
do {
memory = _UWriteV8(memory, dst, (new_vec));
} while (false);
return memory;
}

template <typename D, typename S>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VPSRLDQ(Memory *memory, State &state, D dst, S src1, I8 src2) {
auto vec = _UReadV8(memory, src1);
auto new_vec = _ZeroVec<uint8_t, decltype(_UReadV8(memory, dst))>();
auto shift = std::min<size_t>(_Read(memory, src2), 16);

#pragma unroll
for (size_t i = shift, j = 0; i < 16; ++i, ++j) {
new_vec = UInsertV8(new_vec, j, UExtractV8(vec, i));
new_vec = UInsertV8(new_vec, j + 16, UExtractV8(vec, i + 16));
}
do {
memory = _UWriteV8(memory, dst, (new_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PSRLDQ_XMMdq_IMMb [[gnu::used]] =
PSRLDQ<V128W, V128>;
extern "C" constexpr auto ISEL_VPSRLDQ_XMMdq_XMMdq_IMMb [[gnu::used]] =
PSRLDQ<VV128W, V128>;
extern "C" constexpr auto ISEL_VPSRLDQ_YMMqq_YMMqq_IMMb [[gnu::used]] =
VPSRLDQ<VV256W, V256>;
namespace {
template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MINSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV32(memory, src1);
auto src1_float = FExtractV32(dest_vec, 0);
auto src2_float = FExtractV32(_FReadV32(memory, src2), 0);

auto min = src1_float;

if (std::isunordered(src1_float, src2_float)) {
min = src2_float;
}

else if ((src1_float == 0.0) && (src2_float == 0.0)) {
min = src2_float;
}

else if (src1_float >= src2_float) {
min = src2_float;
}

dest_vec = FInsertV32(dest_vec, 0, min);
do {
memory = _FWriteV32(memory, dst, (dest_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MINSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV64(memory, src1);
auto src1_float = FExtractV64(dest_vec, 0);
auto src2_float = FExtractV64(_FReadV64(memory, src2), 0);

auto min = src1_float;

if (std::isunordered(src1_float, src2_float)) {
min = src2_float;
}

else if ((src1_float == 0.0) && (src2_float == 0.0)) {
min = src2_float;
}

else if (src1_float >= src2_float) {
min = src2_float;
}

dest_vec = FInsertV64(dest_vec, 0, min);
do {
memory = _FWriteV64(memory, dst, (dest_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MAXSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV32(memory, src1);
auto src1_float = FExtractV32(dest_vec, 0);
auto src2_float = FExtractV32(_FReadV32(memory, src2), 0);

auto max = src1_float;

if (std::isunordered(src1_float, src2_float)) {
max = src2_float;
}

else if ((src1_float == 0.0) && (src2_float == 0.0)) {
max = src2_float;
}

else if (src1_float < src2_float) {
max = src2_float;
}

dest_vec = FInsertV32(dest_vec, 0, max);
do {
memory = _FWriteV32(memory, dst, (dest_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MAXSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV64(memory, src1);
auto src1_float = FExtractV64(dest_vec, 0);
auto src2_float = FExtractV64(_FReadV64(memory, src2), 0);

auto max = src1_float;

if (std::isunordered(src1_float, src2_float)) {
max = src2_float;
}

else if ((src1_float == 0.0) && (src2_float == 0.0)) {
max = src2_float;
}

else if (src1_float < src2_float) {
max = src2_float;
}

dest_vec = FInsertV64(dest_vec, 0, max);
do {
memory = _FWriteV64(memory, dst, (dest_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MINSS_XMMss_MEMss [[gnu::used]] =
MINSS<V128W, V128, MV32>;
extern "C" constexpr auto ISEL_MINSS_XMMss_XMMss [[gnu::used]] =
MINSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMINSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
MINSS<VV128W, V128, MV32>;
extern "C" constexpr auto ISEL_VMINSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
MINSS<VV128W, V128, V128>;

extern "C" constexpr auto ISEL_MINSD_XMMsd_MEMsd [[gnu::used]] =
MINSD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_MINSD_XMMsd_XMMsd [[gnu::used]] =
MINSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMINSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
MINSD<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VMINSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
MINSD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_MAXSS_XMMss_MEMss [[gnu::used]] =
MAXSS<V128W, V128, MV32>;
extern "C" constexpr auto ISEL_MAXSS_XMMss_XMMss [[gnu::used]] =
MAXSS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMAXSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
MAXSS<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VMAXSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
MAXSS<VV128W, V128, V128>;

extern "C" constexpr auto ISEL_MAXSD_XMMsd_MEMsd [[gnu::used]] =
MAXSD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_MAXSD_XMMsd_XMMsd [[gnu::used]] =
MAXSD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VMAXSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
MAXSD<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VMAXSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
MAXSD<VV128W, V128, V128>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MINPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < vec_count; i++) {
auto v1 = FExtractV32(dest_vec, i);
auto v2 = FExtractV32(src2_vec, i);

auto min = v1;

if (__builtin_isunordered(v1, v2)) {
min = v2;

} else if ((v1 == 0.0) && (v2 == 0.0)) {
min = v2;

} else if (__builtin_isless(v2, v1)) {
min = v2;
}

dest_vec = FInsertV32(dest_vec, i, min);
}
do {
memory = _FWriteV32(memory, dst, (dest_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MAXPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto dest_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);

auto vec_count =
static_cast<addr_t>(VectorType<decltype(src2_vec)>::kNumElems);

#pragma unroll
for (std::size_t i = 0; i < vec_count; i++) {
auto v1 = FExtractV32(dest_vec, i);
auto v2 = FExtractV32(src2_vec, i);

auto max = v1;

if (__builtin_isunordered(v1, v2)) {
max = v2;

} else if ((v1 == 0.0) && (v2 == 0.0)) {
max = v2;

} else if (__builtin_isgreater(v2, v1)) {
max = v2;
}

dest_vec = FInsertV32(dest_vec, i, max);
}
do {
memory = _FWriteV32(memory, dst, (dest_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MINPS_XMMps_MEMps [[gnu::used]] =
MINPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_MINPS_XMMps_XMMps [[gnu::used]] =
MINPS<V128W, V128, V128>;

extern "C" constexpr auto ISEL_MAXPS_XMMps_XMMps [[gnu::used]] =
MAXPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_MAXPS_XMMps_MEMps [[gnu::used]] =
MAXPS<V128W, V128, MV128>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
UNPCKLPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto temp_vec = _FReadV32(memory, src1);

auto src1_float = FExtractV32(temp_vec, 1);
temp_vec = FInsertV32(temp_vec, 2, src1_float);

auto src2_vec = _FReadV32(memory, src2);

auto src2_float = FExtractV32(src2_vec, 0);
temp_vec = FInsertV32(temp_vec, 1, src2_float);

src2_float = FExtractV32(src2_vec, 1);
temp_vec = FInsertV32(temp_vec, 3, src2_float);

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
UNPCKLPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto temp_vec = _FReadV64(memory, src1);

auto src2_vec = _FReadV64(memory, src2);
auto src2_float = FExtractV64(src2_vec, 0);
temp_vec = FInsertV64(temp_vec, 1, src2_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_UNPCKLPS_XMMps_MEMdq [[gnu::used]] =
UNPCKLPS<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_UNPCKLPS_XMMps_XMMq [[gnu::used]] =
UNPCKLPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VUNPCKLPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
UNPCKLPS<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VUNPCKLPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
UNPCKLPS<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_UNPCKLPD_XMMpd_MEMdq [[gnu::used]] =
UNPCKLPD<V128W, V128, MV64>;
extern "C" constexpr auto ISEL_UNPCKLPD_XMMpd_XMMq [[gnu::used]] =
UNPCKLPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VUNPCKLPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
UNPCKLPD<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VUNPCKLPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
UNPCKLPD<VV128W, V128, V128>;
namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
UNPCKHPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto src1_vec = _FReadV32(memory, src1);
auto src2_vec = _FReadV32(memory, src2);

auto res = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();

res = FInsertV32(res, 0, FExtractV32(src1_vec, 2));
res = FInsertV32(res, 1, FExtractV32(src2_vec, 2));
res = FInsertV32(res, 2, FExtractV32(src1_vec, 3));
res = FInsertV32(res, 3, FExtractV32(src2_vec, 3));

do {
memory = _FWriteV32(memory, dst, (res));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
UNPCKHPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto temp_vec = _FReadV64(memory, src2);

auto src1_vec = _FReadV64(memory, src1);
auto src1_high_qword = FExtractV64(src1_vec, 1);
temp_vec = FInsertV64(temp_vec, 0, src1_high_qword);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_UNPCKHPD_XMMpd_MEMdq [[gnu::used]] =
UNPCKHPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_UNPCKHPD_XMMpd_XMMq [[gnu::used]] =
UNPCKHPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VUNPCKHPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
UNPCKHPD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VUNPCKHPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
UNPCKHPD<VV128W, V128, V128>;

extern "C" constexpr auto ISEL_UNPCKHPS_XMMps_MEMdq [[gnu::used]] =
UNPCKHPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_UNPCKHPS_XMMps_XMMdq [[gnu::used]] =
UNPCKHPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_VUNPCKHPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
UNPCKHPS<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VUNPCKHPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
UNPCKHPS<VV128W, V128, V128>;
namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
MOVDDUP(Memory *memory, State &state, D dst, S1 src) {

auto src_vec = _FReadV64(memory, src);

auto src_float = FExtractV64(src_vec, 0);

float64v2_t temp_vec = {};
temp_vec = FInsertV64(temp_vec, 0, src_float);
temp_vec = FInsertV64(temp_vec, 1, src_float);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_MOVDDUP_XMMdq_MEMq [[gnu::used]] =
MOVDDUP<V128W, MV64>;
extern "C" constexpr auto ISEL_MOVDDUP_XMMdq_XMMq [[gnu::used]] =
MOVDDUP<V128W, V128>;
extern "C" constexpr auto ISEL_VMOVDDUP_XMMdq_MEMq [[gnu::used]] =
MOVDDUP<VV128W, MV64>;
extern "C" constexpr auto ISEL_VMOVDDUP_XMMdq_XMMq [[gnu::used]] =
MOVDDUP<VV128W, V128>;
namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SQRTSS(Memory *memory, State &state, D dst, S1 src1) {

auto src_float = FExtractV32(_FReadV32(memory, src1), 0);

auto square_root = SquareRoot32(memory, state, src_float);
auto temp_vec = _FReadV32(memory, dst);
temp_vec = FInsertV32(temp_vec, 0, square_root);

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
RSQRTSS(Memory *memory, State &state, D dst, S1 src1) {

auto src_float = FExtractV32(_FReadV32(memory, src1), 0);

auto square_root = SquareRoot32(memory, state, src_float);
auto temp_vec = _FReadV32(memory, dst);
temp_vec = FInsertV32(temp_vec, 0, FDiv(1.0f, square_root));

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VSQRTSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto src_float = FExtractV32(_FReadV32(memory, src2), 0);

auto temp_vec = _FReadV32(memory, src1);

auto square_root = SquareRoot32(memory, state, src_float);
temp_vec = FInsertV32(temp_vec, 0, square_root);

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VRSQRTSS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto src_float = FExtractV32(_FReadV32(memory, src2), 0);

auto temp_vec = _FReadV32(memory, src1);

auto square_root = SquareRoot32(memory, state, src_float);
temp_vec = FInsertV32(temp_vec, 0, FDiv(1.0f, square_root));

do {
memory = _FWriteV32(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SQRTSS_XMMss_MEMss [[gnu::used]] =
SQRTSS<V128W, MV32>;
extern "C" constexpr auto ISEL_SQRTSS_XMMss_XMMss [[gnu::used]] =
SQRTSS<V128W, V128>;
extern "C" constexpr auto ISEL_VSQRTSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
VSQRTSS<VV128W, V128, MV32>;
extern "C" constexpr auto ISEL_VSQRTSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
VSQRTSS<VV128W, V128, V128>;

extern "C" constexpr auto ISEL_RSQRTSS_XMMss_MEMss [[gnu::used]] =
RSQRTSS<V128W, MV32>;
extern "C" constexpr auto ISEL_RSQRTSS_XMMss_XMMss [[gnu::used]] =
RSQRTSS<V128W, V128>;
extern "C" constexpr auto ISEL_VRSQRTSS_XMMdq_XMMdq_MEMd [[gnu::used]] =
VRSQRTSS<VV128W, V128, MV32>;
extern "C" constexpr auto ISEL_VRSQRTSS_XMMdq_XMMdq_XMMd [[gnu::used]] =
VRSQRTSS<VV128W, V128, V128>;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
SquareRoot64(Memory *&memory, State &state, float64_t src_float) -> float64_t {
auto square_root = src_float;

if (IsNaN(src_float)) {

if (IsSignalingNaN(src_float)) {
nan64_t temp_nan = {src_float};
temp_nan.is_quiet_nan = 1;
square_root = temp_nan.d;

} else {
square_root = src_float;
}
} else {

if (IsNegative(src_float) && src_float != -0.0) {
uint64_t indef_qnan = 0xFFF8000000000000ULL;
square_root = reinterpret_cast<float64_t &>(indef_qnan);
} else {
square_root = std::sqrt(src_float);
}
}

return square_root;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
SQRTSD(Memory *memory, State &state, D dst, S1 src1) {

auto src_float = FExtractV64(_FReadV64(memory, src1), 0);

auto square_root = SquareRoot64(memory, state, src_float);
auto temp_vec = _FReadV64(memory, dst);
temp_vec = FInsertV64(temp_vec, 0, square_root);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
VSQRTSD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {

auto src_float = FExtractV64(_FReadV64(memory, src2), 0);

auto temp_vec = _FReadV64(memory, src1);

auto square_root = SquareRoot64(memory, state, src_float);
temp_vec = FInsertV64(temp_vec, 0, square_root);

do {
memory = _FWriteV64(memory, dst, (temp_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_SQRTSD_XMMsd_MEMsd [[gnu::used]] =
SQRTSD<V128W, MV64>;
extern "C" constexpr auto ISEL_SQRTSD_XMMsd_XMMsd [[gnu::used]] =
SQRTSD<V128W, V128>;
extern "C" constexpr auto ISEL_VSQRTSD_XMMdq_XMMdq_MEMq [[gnu::used]] =
VSQRTSD<VV128W, V128, MV64>;
extern "C" constexpr auto ISEL_VSQRTSD_XMMdq_XMMdq_XMMq [[gnu::used]] =
VSQRTSD<VV128W, V128, V128>;

namespace {

template <typename D, typename S1, typename S2, typename PV>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PACKUSWB(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto src1_vec = _SReadV16(memory, src1);
auto src2_vec = _SReadV16(memory, src2);

PV packed = {};
const auto num_elems =
static_cast<addr_t>(VectorType<decltype(packed)>::kNumElems);
const auto half_num_elems = num_elems / 2UL;

#pragma unroll
for (size_t i = 0; i < half_num_elems; ++i) {
auto val = SExtractV16(src1_vec, i);
auto sat = std::max<int16_t>(std::min<int16_t>(val, 255), 0);
packed.elems[i] = static_cast<uint8_t>(sat);

auto val2 = SExtractV16(src2_vec, i);
auto sat2 = std::max<int16_t>(std::min<int16_t>(val2, 255), 0);
packed.elems[half_num_elems + i] = static_cast<uint8_t>(sat2);
}

do {
memory = _UWriteV8(memory, dst, (packed));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2, typename PV>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
PACKUSWB_AVX(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
const auto src1_vec = _SReadV16(memory, src1);
const auto src2_vec = _SReadV16(memory, src2);
PV packed = {};

const auto num_elems =
static_cast<addr_t>(VectorType<decltype(packed)>::kNumElems);
const auto half_num_elems = num_elems / 2UL;
const auto quarter_num_elems = num_elems / 4UL;

#pragma unroll
for (size_t i = 0; i < quarter_num_elems; ++i) {
auto val = SExtractV16(src1_vec, i);
auto sat = std::max<int16_t>(std::min<int16_t>(val, 255), 0);
packed.elems[i] = static_cast<uint8_t>(sat);

auto val2 = SExtractV16(src1_vec, quarter_num_elems + i);
auto sat2 = std::max<int16_t>(std::min<int16_t>(val2, 255), 0);
packed.elems[half_num_elems + i] = static_cast<uint8_t>(sat2);

auto val3 = SExtractV16(src2_vec, i);
auto sat3 = std::max<int16_t>(std::min<int16_t>(val3, 255), 0);
packed.elems[quarter_num_elems + i] = static_cast<uint8_t>(sat3);

auto val4 = SExtractV16(src2_vec, quarter_num_elems + i);
auto sat4 = std::max<int16_t>(std::min<int16_t>(val4, 255), 0);
packed.elems[half_num_elems + quarter_num_elems + i] =
static_cast<uint8_t>(sat4);
}

do {
memory = _UWriteV8(memory, dst, (packed));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_PACKUSWB_MMXq_MEMq [[gnu::used]] =
PACKUSWB<V64W, V64, MV64, uint8v8_t>;
extern "C" constexpr auto ISEL_PACKUSWB_MMXq_MMXq [[gnu::used]] =
PACKUSWB<V64W, V64, V64, uint8v8_t>;
extern "C" constexpr auto ISEL_PACKUSWB_XMMdq_MEMdq [[gnu::used]] =
PACKUSWB<V128W, V128, MV128, uint8v16_t>;
extern "C" constexpr auto ISEL_PACKUSWB_XMMdq_XMMdq [[gnu::used]] =
PACKUSWB<V128W, V128, V128, uint8v16_t>;
extern "C" constexpr auto ISEL_VPACKUSWB_XMMdq_XMMdq_MEMdq [[gnu::used]] =
PACKUSWB<VV256W, V128, MV128, uint8v16_t>;

extern "C" constexpr auto ISEL_VPACKUSWB_XMMdq_XMMdq_XMMdq [[gnu::used]] =
PACKUSWB<VV256W, V128, V128, uint8v16_t>;

extern "C" constexpr auto ISEL_VPACKUSWB_YMMqq_YMMqq_MEMqq [[gnu::used]] =
PACKUSWB_AVX<VV256W, V256, MV256, uint8v32_t>;

extern "C" constexpr auto ISEL_VPACKUSWB_YMMqq_YMMqq_YMMqq [[gnu::used]] =
PACKUSWB_AVX<VV256W, V256, V256, uint8v32_t>;

namespace {

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
HADDPS(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _FReadV32(memory, src1);
auto rhs_vec = _FReadV32(memory, src2);
auto dst_vec = _ZeroVec<float32_t, decltype(_FReadV32(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t index = 0; index < vec_count; index += 2) {
auto v1 = FExtractV32(lhs_vec, index);
auto v2 = FExtractV32(lhs_vec, index + 1);
auto i = UDiv(UInt32(index), UInt32(2));
dst_vec = FInsertV32(dst_vec, i, FAdd(v1, v2));
}

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
index += 2) {
auto v1 = FExtractV32(rhs_vec, index);
auto v2 = FExtractV32(rhs_vec, index + 1);
auto i = UDiv(UAdd(UInt32(index), UInt32(vec_count)), UInt32(2));
dst_vec = FInsertV32(dst_vec, i, FAdd(v1, v2));
}
do {
memory = _FWriteV32(memory, dst, (dst_vec));
} while (false);
return memory;
}

template <typename D, typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
HADDPD(Memory *memory, State &state, D dst, S1 src1, S2 src2) {
auto lhs_vec = _FReadV64(memory, src1);
auto rhs_vec = _FReadV64(memory, src2);
auto dst_vec = _ZeroVec<float64_t, decltype(_FReadV64(memory, dst))>();

auto vec_count =
static_cast<addr_t>(VectorType<decltype(lhs_vec)>::kNumElems);

#pragma unroll
for (size_t index = 0; index < vec_count; index += 2) {
auto v1 = FExtractV64(lhs_vec, index);
auto v2 = FExtractV64(lhs_vec, index + 1);
auto i = UDiv(UInt32(index), UInt32(2));
dst_vec = FInsertV64(dst_vec, i, FAdd(v1, v2));
}

#pragma unroll
for (size_t index = 0;
index < static_cast<addr_t>(VectorType<decltype(rhs_vec)>::kNumElems);
index += 2) {
auto v1 = FExtractV64(rhs_vec, index);
auto v2 = FExtractV64(rhs_vec, index + 1);
auto i = UDiv(UAdd(UInt32(index), UInt32(vec_count)), UInt32(2));
dst_vec = FInsertV64(dst_vec, i, FAdd(v1, v2));
}
do {
memory = _FWriteV64(memory, dst, (dst_vec));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_HADDPS_XMMps_XMMps [[gnu::used]] =
HADDPS<V128W, V128, V128>;
extern "C" constexpr auto ISEL_HADDPS_XMMps_MEMps [[gnu::used]] =
HADDPS<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VHADDPS_XMMdq_XMMdq_XMMdq [[gnu::used]] =
HADDPS<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VHADDPS_XMMdq_XMMdq_MEMdq [[gnu::used]] =
HADDPS<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VHADDPS_YMMqq_YMMqq_YMMqq [[gnu::used]] =
HADDPS<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VHADDPS_YMMqq_YMMqq_MEMqq [[gnu::used]] =
HADDPS<VV256W, V256, MV256>;

extern "C" constexpr auto ISEL_HADDPD_XMMpd_XMMpd [[gnu::used]] =
HADDPD<V128W, V128, V128>;
extern "C" constexpr auto ISEL_HADDPD_XMMpd_MEMpd [[gnu::used]] =
HADDPD<V128W, V128, MV128>;
extern "C" constexpr auto ISEL_VHADDPD_XMMdq_XMMdq_XMMdq [[gnu::used]] =
HADDPD<VV128W, V128, V128>;
extern "C" constexpr auto ISEL_VHADDPD_XMMdq_XMMdq_MEMdq [[gnu::used]] =
HADDPD<VV128W, V128, MV128>;
extern "C" constexpr auto ISEL_VHADDPD_YMMqq_YMMqq_YMMqq [[gnu::used]] =
HADDPD<VV256W, V256, V256>;
extern "C" constexpr auto ISEL_VHADDPD_YMMqq_YMMqq_MEMqq [[gnu::used]] =
HADDPD<VV256W, V256, MV256>;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LDMXCSR(Memory *memory, State &state, M32 src) {
auto &csr = state.x87.fxsave64.mxcsr;
csr.flat = _Read(memory, src);

int rounding_mode = 0;

if (!csr.rp && !csr.rn) {
rounding_mode = 0;
} else if (!csr.rp && csr.rn) {
rounding_mode = 0x400;
} else if (csr.rp && !csr.rn) {
rounding_mode = 0x800;
} else {
rounding_mode = 0xc00;
}
fesetround(rounding_mode);

return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
STMXCSR(Memory *memory, State &state, M32W dst) {
auto &csr = state.x87.fxsave64.mxcsr;

csr.pe = 0;

switch (fegetround()) {
default:
case 0:
csr.rp = 0;
csr.rn = 0;
break;
case 0x400:
csr.rp = 0;
csr.rn = 1;
break;
case 0x800:
csr.rp = 1;
csr.rn = 0;
break;
case 0xc00:
csr.rp = 1;
csr.rn = 1;
break;
}

do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(csr.flat),
"Bad write!");
memory = _Write(memory, dst, (csr.flat));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_LDMXCSR_MEMd [[gnu::used]] = LDMXCSR;
extern "C" constexpr auto ISEL_STMXCSR_MEMd [[gnu::used]] = STMXCSR;
extern "C" constexpr auto ISEL_VLDMXCSR_MEMd [[gnu::used]] = LDMXCSR;
extern "C" constexpr auto ISEL_VSTMXCSR_MEMd [[gnu::used]] = STMXCSR;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTOSB(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint8_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint8_t>(addr))>::BT) ==
sizeof(_Read(memory, state.gpr.rax.byte.low)),
"Bad write!");
memory = _Write(memory, WritePtr<uint8_t>(addr),
(_Read(memory, state.gpr.rax.byte.low)));
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_STOSB [[gnu::used]] = DoSTOSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTOSW(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint16_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint16_t>(addr))>::BT) ==
sizeof(_Read(memory, state.gpr.rax.word)),
"Bad write!");
memory = _Write(memory, WritePtr<uint16_t>(addr),
(_Read(memory, state.gpr.rax.word)));
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_STOSW [[gnu::used]] = DoSTOSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTOSD(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint32_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint32_t>(addr))>::BT) ==
sizeof(_Read(memory, state.gpr.rax.dword)),
"Bad write!");
memory = _Write(memory, WritePtr<uint32_t>(addr),
(_Read(memory, state.gpr.rax.dword)));
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_STOSD [[gnu::used]] = DoSTOSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSTOSQ(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint64_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint64_t>(addr))>::BT) ==
sizeof(_Read(memory, state.gpr.rax.qword)),
"Bad write!");
memory = _Write(memory, WritePtr<uint64_t>(addr),
(_Read(memory, state.gpr.rax.qword)));
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_STOSQ [[gnu::used]] = DoSTOSQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSCASB(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint8_t);
const uint8_t lhs = _Read(memory, state.gpr.rax.byte.low);
const uint8_t rhs = _Read(memory, ReadPtr<uint8_t>(addr));
const uint8_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_SCASB [[gnu::used]] = DoSCASB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSCASW(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint16_t);
const uint16_t lhs = _Read(memory, state.gpr.rax.word);
const uint16_t rhs = _Read(memory, ReadPtr<uint16_t>(addr));
const uint16_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_SCASW [[gnu::used]] = DoSCASW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSCASD(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint32_t);
const uint32_t lhs = _Read(memory, state.gpr.rax.dword);
const uint32_t rhs = _Read(memory, ReadPtr<uint32_t>(addr));
const uint32_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_SCASD [[gnu::used]] = DoSCASD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSCASQ(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint64_t);
const uint64_t lhs = _Read(memory, state.gpr.rax.qword);
const uint64_t rhs = _Read(memory, ReadPtr<uint64_t>(addr));
const uint64_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_SCASQ [[gnu::used]] = DoSCASQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLODSB(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rsi.qword);
const addr_t num_bytes = sizeof(uint8_t);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.byte.low)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.byte.low)>(
_Read(memory, ReadPtr<uint8_t>(addr)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.byte.low,
(ZExtTo<decltype(state.gpr.rax.byte.low)>(
_Read(memory, ReadPtr<uint8_t>(addr)))));
} while (false);
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_LODSB [[gnu::used]] = DoLODSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLODSW(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rsi.qword);
const addr_t num_bytes = sizeof(uint16_t);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.word)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.word)>(
_Read(memory, ReadPtr<uint16_t>(addr)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.word,
(ZExtTo<decltype(state.gpr.rax.word)>(
_Read(memory, ReadPtr<uint16_t>(addr)))));
} while (false);
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_LODSW [[gnu::used]] = DoLODSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLODSD(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rsi.qword);
const addr_t num_bytes = sizeof(uint32_t);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
_Read(memory, ReadPtr<uint32_t>(addr)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(
_Read(memory, ReadPtr<uint32_t>(addr)))));
} while (false);
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_LODSD [[gnu::used]] = DoLODSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoLODSQ(Memory *memory, State &state) {
const addr_t addr = _Read(memory, state.gpr.rsi.qword);
const addr_t num_bytes = sizeof(uint64_t);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(
_Read(memory, ReadPtr<uint64_t>(addr)))),
"Bad write!");
memory = _Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(
_Read(memory, ReadPtr<uint64_t>(addr)))));
} while (false);
} while (false);
addr_t next_addr = 0;
if (BNot(state.aflag.df)) {
next_addr = UAdd(addr, num_bytes);
} else {
next_addr = USub(addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_LODSQ [[gnu::used]] = DoLODSQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMOVSB(Memory *memory, State &state) {
const addr_t src_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t dst_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint8_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint8_t>(dst_addr))>::BT) ==
sizeof(_Read(memory, ReadPtr<uint8_t>(src_addr))),
"Bad write!");
memory = _Write(memory, WritePtr<uint8_t>(dst_addr),
(_Read(memory, ReadPtr<uint8_t>(src_addr))));
} while (false);
addr_t next_dst_addr = 0;
addr_t next_src_addr = 0;
if (BNot(state.aflag.df)) {
next_dst_addr = UAdd(dst_addr, num_bytes);
next_src_addr = UAdd(src_addr, num_bytes);
} else {
next_dst_addr = USub(dst_addr, num_bytes);
next_src_addr = USub(src_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_dst_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_dst_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_MOVSB [[gnu::used]] = DoMOVSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMOVSW(Memory *memory, State &state) {
const addr_t src_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t dst_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint16_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint16_t>(dst_addr))>::BT) ==
sizeof(_Read(memory, ReadPtr<uint16_t>(src_addr))),
"Bad write!");
memory = _Write(memory, WritePtr<uint16_t>(dst_addr),
(_Read(memory, ReadPtr<uint16_t>(src_addr))));
} while (false);
addr_t next_dst_addr = 0;
addr_t next_src_addr = 0;
if (BNot(state.aflag.df)) {
next_dst_addr = UAdd(dst_addr, num_bytes);
next_src_addr = UAdd(src_addr, num_bytes);
} else {
next_dst_addr = USub(dst_addr, num_bytes);
next_src_addr = USub(src_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_dst_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_dst_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_MOVSW [[gnu::used]] = DoMOVSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMOVSD(Memory *memory, State &state) {
const addr_t src_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t dst_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint32_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint32_t>(dst_addr))>::BT) ==
sizeof(_Read(memory, ReadPtr<uint32_t>(src_addr))),
"Bad write!");
memory = _Write(memory, WritePtr<uint32_t>(dst_addr),
(_Read(memory, ReadPtr<uint32_t>(src_addr))));
} while (false);
addr_t next_dst_addr = 0;
addr_t next_src_addr = 0;
if (BNot(state.aflag.df)) {
next_dst_addr = UAdd(dst_addr, num_bytes);
next_src_addr = UAdd(src_addr, num_bytes);
} else {
next_dst_addr = USub(dst_addr, num_bytes);
next_src_addr = USub(src_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_dst_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_dst_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_MOVSD [[gnu::used]] = DoMOVSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoMOVSQ(Memory *memory, State &state) {
const addr_t src_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t dst_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint64_t);
do {
static_assert(
sizeof(typename BaseType<decltype(WritePtr<uint64_t>(dst_addr))>::BT) ==
sizeof(_Read(memory, ReadPtr<uint64_t>(src_addr))),
"Bad write!");
memory = _Write(memory, WritePtr<uint64_t>(dst_addr),
(_Read(memory, ReadPtr<uint64_t>(src_addr))));
} while (false);
addr_t next_dst_addr = 0;
addr_t next_src_addr = 0;
if (BNot(state.aflag.df)) {
next_dst_addr = UAdd(dst_addr, num_bytes);
next_src_addr = UAdd(src_addr, num_bytes);
} else {
next_dst_addr = USub(dst_addr, num_bytes);
next_src_addr = USub(src_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_dst_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_dst_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_MOVSQ [[gnu::used]] = DoMOVSQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPSB(Memory *memory, State &state) {
const addr_t src1_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t src2_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint8_t);
const uint8_t lhs = _Read(memory, ReadPtr<uint8_t>(src1_addr));
const uint8_t rhs = _Read(memory, ReadPtr<uint8_t>(src2_addr));
const uint8_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_src1_addr = 0;
addr_t next_src2_addr = 0;
if (BNot(state.aflag.df)) {
next_src1_addr = UAdd(src1_addr, num_bytes);
next_src2_addr = UAdd(src2_addr, num_bytes);
} else {
next_src1_addr = USub(src1_addr, num_bytes);
next_src2_addr = USub(src2_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_src2_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_src2_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src1_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src1_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_CMPSB [[gnu::used]] = DoCMPSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPSW(Memory *memory, State &state) {
const addr_t src1_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t src2_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint16_t);
const uint16_t lhs = _Read(memory, ReadPtr<uint16_t>(src1_addr));
const uint16_t rhs = _Read(memory, ReadPtr<uint16_t>(src2_addr));
const uint16_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_src1_addr = 0;
addr_t next_src2_addr = 0;
if (BNot(state.aflag.df)) {
next_src1_addr = UAdd(src1_addr, num_bytes);
next_src2_addr = UAdd(src2_addr, num_bytes);
} else {
next_src1_addr = USub(src1_addr, num_bytes);
next_src2_addr = USub(src2_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_src2_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_src2_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src1_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src1_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_CMPSW [[gnu::used]] = DoCMPSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPSD(Memory *memory, State &state) {
const addr_t src1_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t src2_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint32_t);
const uint32_t lhs = _Read(memory, ReadPtr<uint32_t>(src1_addr));
const uint32_t rhs = _Read(memory, ReadPtr<uint32_t>(src2_addr));
const uint32_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_src1_addr = 0;
addr_t next_src2_addr = 0;
if (BNot(state.aflag.df)) {
next_src1_addr = UAdd(src1_addr, num_bytes);
next_src2_addr = UAdd(src2_addr, num_bytes);
} else {
next_src1_addr = USub(src1_addr, num_bytes);
next_src2_addr = USub(src2_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_src2_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_src2_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src1_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src1_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_CMPSD [[gnu::used]] = DoCMPSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoCMPSQ(Memory *memory, State &state) {
const addr_t src1_addr = _Read(memory, state.gpr.rsi.qword);
const addr_t src2_addr = _Read(memory, state.gpr.rdi.qword);
const addr_t num_bytes = sizeof(uint64_t);
const uint64_t lhs = _Read(memory, ReadPtr<uint64_t>(src1_addr));
const uint64_t rhs = _Read(memory, ReadPtr<uint64_t>(src2_addr));
const uint64_t res = USub(lhs, rhs);
WriteFlagsAddSub<tag_sub>(state, lhs, rhs, res);
addr_t next_src1_addr = 0;
addr_t next_src2_addr = 0;
if (BNot(state.aflag.df)) {
next_src1_addr = UAdd(src1_addr, num_bytes);
next_src2_addr = UAdd(src2_addr, num_bytes);
} else {
next_src1_addr = USub(src1_addr, num_bytes);
next_src2_addr = USub(src2_addr, num_bytes);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdi.qword)>::BT) ==
sizeof(next_src2_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rdi.qword, (next_src2_addr));
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rsi.qword)>::BT) ==
sizeof(next_src1_addr),
"Bad write!");
memory = _Write(memory, state.gpr.rsi.qword, (next_src1_addr));
} while (false);
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_CMPSQ [[gnu::used]] = DoCMPSQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_LODSB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoLODSB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_LODSB [[gnu::used]] = DoREP_LODSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_LODSW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoLODSW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_LODSW [[gnu::used]] = DoREP_LODSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_LODSD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoLODSD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_LODSD [[gnu::used]] = DoREP_LODSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_LODSQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoLODSQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_LODSQ [[gnu::used]] = DoREP_LODSQ;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_MOVSB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoMOVSB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_MOVSB [[gnu::used]] = DoREP_MOVSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_MOVSW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoMOVSW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_MOVSW [[gnu::used]] = DoREP_MOVSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_MOVSD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoMOVSD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_MOVSD [[gnu::used]] = DoREP_MOVSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_MOVSQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoMOVSQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_MOVSQ [[gnu::used]] = DoREP_MOVSQ;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_STOSB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoSTOSB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_STOSB [[gnu::used]] = DoREP_STOSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_STOSW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoSTOSW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_STOSW [[gnu::used]] = DoREP_STOSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_STOSD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoSTOSD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_STOSD [[gnu::used]] = DoREP_STOSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREP_STOSQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
while (UCmpNeq(count_reg, 0)) {
memory = DoSTOSQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
}
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REP_STOSQ [[gnu::used]] = DoREP_STOSQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_CMPSB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_CMPSB [[gnu::used]] = DoREPE_CMPSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_CMPSW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_CMPSW [[gnu::used]] = DoREPE_CMPSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_CMPSD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_CMPSD [[gnu::used]] = DoREPE_CMPSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_CMPSQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_CMPSQ [[gnu::used]] = DoREPE_CMPSQ;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_SCASB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_SCASB [[gnu::used]] = DoREPE_SCASB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_SCASW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_SCASW [[gnu::used]] = DoREPE_SCASW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_SCASD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_SCASD [[gnu::used]] = DoREPE_SCASD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPE_SCASQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), state.aflag.zf));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPE_SCASQ [[gnu::used]] = DoREPE_SCASQ;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_CMPSB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_CMPSB [[gnu::used]] = DoREPNE_CMPSB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_CMPSW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_CMPSW [[gnu::used]] = DoREPNE_CMPSW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_CMPSD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_CMPSD [[gnu::used]] = DoREPNE_CMPSD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_CMPSQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoCMPSQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_CMPSQ [[gnu::used]] = DoREPNE_CMPSQ;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_SCASB(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASB(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_SCASB [[gnu::used]] = DoREPNE_SCASB;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_SCASW(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASW(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_SCASW [[gnu::used]] = DoREPNE_SCASW;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_SCASD(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASD(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_SCASD [[gnu::used]] = DoREPNE_SCASD;
namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoREPNE_SCASQ(Memory *memory, State &state) {
auto count_reg = _Read(memory, state.gpr.rcx.qword);
if (UCmpEq(count_reg, 0)) {
return memory;
}
do {
memory = DoSCASQ(memory, state);
count_reg = USub(count_reg, 1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rcx.qword)>::BT) ==
sizeof(count_reg),
"Bad write!");
memory = _Write(memory, state.gpr.rcx.qword, (count_reg));
} while (false);
} while (BAnd(UCmpNeq(count_reg, 0), BNot(state.aflag.zf)));
return memory;
}
} // namespace
extern "C" constexpr auto ISEL_REPNE_SCASQ [[gnu::used]] = DoREPNE_SCASQ;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSYSCALL(Memory *memory, State &state, R64W) {
memory = __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86SysCall);
state.hyper_call = AsyncHyperCall::kX86SysCall;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSYSCALL_AMD(Memory *memory, State &state, R64W) {
memory = __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86SysCall);
state.hyper_call = AsyncHyperCall::kX86SysCall;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSYSENTER(Memory *memory, State &state, R64W) {
memory = __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86SysEnter);
state.hyper_call = AsyncHyperCall::kX86SysEnter;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoSYSEXIT(Memory *memory, State &state, R64W) {
memory = __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86SysExit);
state.hyper_call = AsyncHyperCall::kX86SysExit;
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_SYSCALL [[gnu::used]] = DoSYSCALL;

extern "C" constexpr auto ISEL_SYSCALL_AMD [[gnu::used]] = DoSYSCALL_AMD;

extern "C" constexpr auto ISEL_SYSENTER [[gnu::used]] = DoSYSENTER;

extern "C" constexpr auto ISEL_SYSEXIT [[gnu::used]] = DoSYSEXIT;
namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoRDTSC(Memory *memory, State &state) {
return __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86ReadTSC);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoRDTSCP(Memory *memory, State &state) {
return __remill_sync_hyper_call(state, memory, SyncHyperCall::kX86ReadTSCP);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LGDT(Memory *memory, State &state, M32 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.addr_to_load = AddressOf(src);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86LoadGlobalDescriptorTable);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
LIDT(Memory *memory, State &state, M32 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
state.addr_to_load = AddressOf(src);
return __remill_sync_hyper_call(
state, memory, SyncHyperCall::kX86LoadInterruptDescriptorTable);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoRDMSR(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86ReadModelSpecificRegister);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoWRMSR(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_sync_hyper_call(
state, memory, SyncHyperCall::kX86WriteModelSpecificRegister);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoWBINVD(Memory *memory, State &state) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86WriteBackInvalidate);
}

template <SyncHyperCall::Name kSetCR>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
WRITE_CONTROL_REG_32(Memory *memory, State &state, R64W dst, R32 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(_Read(memory, src))));
} while (false);
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return __remill_sync_hyper_call(state, memory, kSetCR);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
READ_CONTROL_REG_32(Memory *memory, State &state, R32W dst, R64 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(Trunc(_Read(memory, src)))),
"Bad write!");
memory = _Write(memory, dst,
(ZExtTo<decltype(dst)>(Trunc(_Read(memory, src)))));
} while (false);
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
READ_CONTROL_REG_64(Memory *memory, State &state, R64W dst, R64 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return memory;
}

template <SyncHyperCall::Name kSetCR>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
WRITE_CONTROL_REG_64(Memory *memory, State &state, R64W dst, R64 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return __remill_sync_hyper_call(state, memory, kSetCR);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
WRITE_DEBUG_REG_32(Memory *memory, State &state, R64W dst, R32 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(ZExtTo<decltype(dst)>(_Read(memory, src))),
"Bad write!");
memory = _Write(memory, dst, (ZExtTo<decltype(dst)>(_Read(memory, src))));
} while (false);
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kX86SetDebugReg);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
WRITE_DEBUG_REG_64(Memory *memory, State &state, R64W dst, R64 src) {
memory =
__remill_sync_hyper_call(state, memory, SyncHyperCall::kAssertPrivileged);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(_Read(memory, src)),
"Bad write!");
memory = _Write(memory, dst, (_Read(memory, src)));
} while (false);
auto u = __remill_undefined_8();
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.of)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.of, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.sf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.sf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.zf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.zf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.af)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.af, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.pf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.pf, (u));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.aflag.cf)>::BT) ==
sizeof(u),
"Bad write!");
memory = _Write(memory, state.aflag.cf, (u));
} while (false);
return __remill_sync_hyper_call(state, memory,
SyncHyperCall::kAMD64SetDebugReg);
}

} // namespace

extern "C" constexpr auto ISEL_RDTSC [[gnu::used]] = DoRDTSC;
extern "C" constexpr auto ISEL_RDTSCP [[gnu::used]] = DoRDTSCP;
extern "C" constexpr auto ISEL_RDMSR [[gnu::used]] = DoRDMSR;
extern "C" constexpr auto ISEL_WRMSR [[gnu::used]] = DoWRMSR;
extern "C" constexpr auto ISEL_WBINVD [[gnu::used]] = DoWBINVD;
extern "C" constexpr auto ISEL_LGDT_MEMs_32 [[gnu::used]] = LGDT;
extern "C" constexpr auto ISEL_LIDT_MEMs_32 [[gnu::used]] = LIDT;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR32_CR0 [[gnu::used]] =
WRITE_CONTROL_REG_32<SyncHyperCall::kX86SetControlReg0>;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR32_CR1 [[gnu::used]] =
WRITE_CONTROL_REG_32<SyncHyperCall::kX86SetControlReg1>;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR32_CR2 [[gnu::used]] =
WRITE_CONTROL_REG_32<SyncHyperCall::kX86SetControlReg2>;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR32_CR3 [[gnu::used]] =
WRITE_CONTROL_REG_32<SyncHyperCall::kX86SetControlReg3>;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR32_CR4 [[gnu::used]] =
WRITE_CONTROL_REG_32<SyncHyperCall::kX86SetControlReg4>;
extern "C" constexpr auto ISEL_MOV_CR_GPR32_CR [[gnu::used]] =
READ_CONTROL_REG_32;
extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR0 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg0>;

extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR1 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg1>;

extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR2 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg2>;

extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR3 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg3>;

extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR4 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg4>;

extern "C" constexpr auto ISEL_MOV_CR_CR_GPR64_CR8 [[gnu::used]] =
WRITE_CONTROL_REG_64<SyncHyperCall::kAMD64SetControlReg8>;

extern "C" constexpr auto ISEL_MOV_CR_GPR64_CR [[gnu::used]] =
READ_CONTROL_REG_64;

extern "C" constexpr auto ISEL_MOV_DR_DR_GPR32 [[gnu::used]] =
WRITE_DEBUG_REG_32;
extern "C" constexpr auto ISEL_MOV_DR_DR_GPR64 [[gnu::used]] =
WRITE_DEBUG_REG_64;
namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JMP(Memory *memory, State &state, T target_pc, R64W pc_dst) {
auto new_pc = _Read(memory, target_pc);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(new_pc)),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(new_pc)));
} while (false);
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(ZExtTo<decltype(pc_dst)>(new_pc)),
"Bad write!");
memory = _Write(memory, pc_dst, (ZExtTo<decltype(pc_dst)>(new_pc)));
} while (false);
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JMP_FAR_MEM(Memory *memory, State &state, T target_seg_pc, R64W pc_dst) {
state.hyper_call = AsyncHyperCall::kX86JmpFar;
uint64_t target_fword = UShr(UShl(_Read(memory, target_seg_pc), 0xf), 0xf);
auto pc = static_cast<uint32_t>(target_fword);
auto seg = static_cast<uint16_t>(UShr(target_fword, 32));
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(pc)),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(pc)));
} while (false);
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(ZExtTo<decltype(pc_dst)>(pc)),
"Bad write!");
memory = _Write(memory, pc_dst, (ZExtTo<decltype(pc_dst)>(pc)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.seg.cs.flat)>::BT) ==
sizeof(seg),
"Bad write!");
memory = _Write(memory, state.seg.cs.flat, (seg));
} while (false);

return memory;
}

template <typename S1, typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
JMP_FAR_PTR(Memory *memory, State &state, S1 src1, S2 src2, R64W pc_dst) {
state.hyper_call = AsyncHyperCall::kX86JmpFar;
auto pc = _Read(memory, src1);
auto seg = _Read(memory, src2);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(pc)),
"Bad write!");
memory = _Write(memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(pc)));
} while (false);
} while (false);
do {
do {
static_assert(sizeof(typename BaseType<decltype(pc_dst)>::BT) ==
sizeof(ZExtTo<decltype(pc_dst)>(pc)),
"Bad write!");
memory = _Write(memory, pc_dst, (ZExtTo<decltype(pc_dst)>(pc)));
} while (false);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(state.seg.cs.flat)>::BT) ==
sizeof(seg),
"Bad write!");
memory = _Write(memory, state.seg.cs.flat, (seg));
} while (false);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_JMP_RELBRd [[gnu::used]] = JMP<PC>;
extern "C" constexpr auto ISEL_JMP_RELBRb [[gnu::used]] = JMP<PC>;
extern "C" constexpr auto ISEL_JMP_RELBRz_64 [[gnu::used]] = JMP<PC>;

extern "C" constexpr auto ISEL_JMP_MEMv_64 [[gnu::used]] = JMP<M64>;
extern "C" constexpr auto ISEL_JMP_GPRv_64 [[gnu::used]] = JMP<R64>;

extern "C" constexpr auto ISEL_JMP_FAR_MEMp2_32 [[gnu::used]] =
JMP_FAR_MEM<M64>;

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FBLD(Memory *memory, State &state, RF80W, MBCD80 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src1);
} while (false);

auto src1_bcd = _ReadBCD80(memory, src1);
native_float80_t val = 0.0;
native_float80_t mag = 1.0;

#pragma unroll
for (addr_t i = 0; i < sizeof(src1_bcd.digit_pairs); i++) {

auto b = src1_bcd.digit_pairs[i].u8;
auto lo = b & 0xf;
auto hi = b >> 4;

val += static_cast<native_float80_t>(lo) * mag;
mag *= 10.0;
val += static_cast<native_float80_t>(hi) * mag;
mag *= 10.0;
}

if (src1_bcd.is_negative) {
val = -val;
}

do {
auto __x = val;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FILD(Memory *memory, State &state, RF80W, T src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src1);
} while (false);
do {
auto __x = Signed(_Read(memory, src1));
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FLD(Memory *memory, State &state, RF80W, T src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto val = _Read(memory, src1);
state.sw.ie |= IsSignalingNaN(val);
state.sw.de |= IsDenormal(val);
auto res = Float80(val);

if (state.sw.ie) {

static_assert(sizeof(native_float80_t) >= sizeof(nan80_t),
"Float/NaN size mismatch");

nan80_t res_nan = {static_cast<native_float80_t>(res)};

res_nan.is_quiet_nan = 1;
res = res_nan.d;
}

do {
auto __x = res;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FLDfromstack(Memory *memory, State &state, RF80W, RF80W src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
state.sw.ie = 0;
state.sw.de = 0;
do {
auto __x = _Read(memory, src1);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FLDmem(Memory *memory, State &state, RF80W dst, T src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src1);
} while (false);
return FLD(memory, state, dst, src1, pc, fop);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDLN2(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
uint64_t ln_2 = 0x3fe62e42fefa39efULL;
do {
auto __x = reinterpret_cast<float64_t &>(ln_2);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLD1(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
auto __x = 1.0;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDZ(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
auto __x = 0.0;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDLG2(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
uint64_t log10_2 = 0x3fd34413509f79ffULL;
do {
auto __x = reinterpret_cast<float64_t &>(log10_2);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDL2T(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
uint64_t log2_10 = 0x400a934f0979a371ULL;
do {
auto __x = reinterpret_cast<float64_t &>(log2_10);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDL2E(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
uint64_t log2_e = 0x3ff71547652b82feULL;
do {
auto __x = reinterpret_cast<float64_t &>(log2_e);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFLDPI(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
uint64_t pi = 0x400921fb54442d18ULL;
do {
auto __x = reinterpret_cast<float64_t &>(pi);
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFABS(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto res = CheckedFloatUnaryOp(state, FAbs80, st0);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFCHS(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto res = CheckedFloatUnaryOp(state, FNeg80, st0);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
return memory;
}
[[gnu::always_inline]] inline static uint8_t IsImprecise(float32_t x) {
return 0 != (reinterpret_cast<uint32_t &>(x) & 0xF);
}

[[gnu::always_inline]] inline static uint8_t IsImprecise(float64_t x) {
return 0 != (reinterpret_cast<uint64_t &>(x) & 0xFF);
}

[[gnu::always_inline]] inline static uint8_t IsImprecise(float80_t x) {
return 0 != (reinterpret_cast<uint64_t &>(x) & 0x7FFFF);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFCOS(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.ie |= IsSignalingNaN(st0) | IsInfinite(st0);
state.sw.de |= IsDenormal(st0);
auto res = CheckedFloatUnaryOp(state, FCos80, st0);
if (!IsNaN(res)) {
state.sw.pe |= IsImprecise(res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFSIN(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.ie |= IsSignalingNaN(st0) | IsInfinite(st0);
state.sw.de |= IsDenormal(st0);
auto res = CheckedFloatUnaryOp(state, FSin80, st0);
if (!IsNaN(res)) {
state.sw.pe = IsImprecise(res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFPTAN(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.ie |= IsSignalingNaN(st0) | IsInfinite(st0);
state.sw.de |= IsDenormal(st0);
auto res = CheckedFloatUnaryOp(state, FTan80, st0);
if (!IsNaN(res)) {
state.sw.pe = IsImprecise(res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
do {
auto __x = 1.0;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFPATAN(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);

auto st0 = _Read(memory, state.st.elems[0].val);
auto st1 = _Read(memory, state.st.elems[1].val);
auto res = CheckedFloatBinOp(state, FDiv80, st1, st0);
if (!state.sw.ie) {
state.sw.ie = IsSignalingNaN(res) | IsInfinite(res);
state.sw.de = IsDenormal(res);
state.sw.pe = IsImprecise(res);
}

do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[1].val)>::BT) ==
sizeof(FAtan80(res)),
"Bad write!");
memory = _Write(memory, state.st.elems[1].val, (FAtan80(res)));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFSQRT(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
if (IsZero(st0)) {
state.sw.ie = 0;
state.sw.de = 0;
state.sw.pe = 0;
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(st0),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (st0));
} while (false);
} else {
state.sw.ie |= IsSignalingNaN(st0) | IsNegative(st0);
state.sw.de |= IsDenormal(st0);
auto res = CheckedFloatUnaryOp(state, FSqrt80, st0);
if (!IsNaN(res)) {
state.sw.pe = IsImprecise(res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
}
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFSINCOS(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.ie |= IsSignalingNaN(st0) | IsInfinite(st0);
state.sw.de |= IsDenormal(st0);
auto sin_res = CheckedFloatUnaryOp(state, FSin80, st0);
auto cos_res = CheckedFloatUnaryOp(state, FCos80, st0);
if (!IsNaN(sin_res) && !IsNaN(cos_res)) {
state.sw.pe = IsImprecise(sin_res) | IsImprecise(cos_res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(sin_res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (sin_res));
} while (false);
do {
auto __x = cos_res;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFSCALE(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st1_int = FTruncTowardZero(_Read(memory, state.st.elems[1].val));
auto shift = Exp2(st1_int);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(FMul(_Read(memory, state.st.elems[0].val), Float80(shift))),
"Bad write!");
memory =
_Write(memory, state.st.elems[0].val,
(FMul(_Read(memory, state.st.elems[0].val), Float80(shift))));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoF2XM1(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.ie |= IsSignalingNaN(st0) | IsInfinite(st0);
state.sw.de |= IsDenormal(st0);
state.sw.ue = 0;
auto res = FSub(Float80(Exp2(st0)), Float80(1.0));
if (!IsNaN(res)) {
state.sw.pe = IsImprecise(res);
}
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (res));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFPREM(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto st1 = _Read(memory, state.st.elems[1].val);
auto rem = __builtin_fmodl(st0, st1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(Float80(rem)),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (Float80(rem)));
} while (false);

auto quot = Int64(FTruncTowardZero(FDiv(st0, st1)));
auto quot_lsb = TruncTo<uint8_t>(UInt64(SAbs(quot)));
state.sw.c0 = UAnd(UShr(quot_lsb, 2_u8), 1_u8);
state.sw.c2 = 0;
state.sw.c1 = UAnd(UShr(quot_lsb, 0_u8), 1_u8);
state.sw.c3 = UAnd(UShr(quot_lsb, 1_u8), 1_u8);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFPREM1(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto st1 = _Read(memory, state.st.elems[1].val);
auto rem = __builtin_remainderl(st0, st1);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(Float80(rem)),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (Float80(rem)));
} while (false);
auto quot = Float80ToInt64(FDiv80(st0, st1));
auto quot_lsb = TruncTo<uint8_t>(UInt64(SAbs(quot)));
state.sw.c0 = UAnd(UShr(quot_lsb, 2_u8), 1_u8);
state.sw.c2 = 0;
state.sw.c1 = UAnd(UShr(quot_lsb, 0_u8), 1_u8);
state.sw.c3 = UAnd(UShr(quot_lsb, 1_u8), 1_u8);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FPU_NOP(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFWAIT(Memory *memory, State &state) {
feraiseexcept(fetestexcept((0x20 | 0x04 | 0x10 | 0x08 | 0x01)));
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFNCLEX(Memory *memory, State &state) {
feclearexcept((0x20 | 0x04 | 0x10 | 0x08 | 0x01));
state.sw.pe = 0;
state.sw.ue = 0;
state.sw.oe = 0;
state.sw.ze = 0;
state.sw.de = 0;
state.sw.ie = 0;

state.sw.c0 = __remill_undefined_8();
state.sw.c1 = __remill_undefined_8();
state.sw.c2 = __remill_undefined_8();
state.sw.c3 = __remill_undefined_8();

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FBLD_ST0_MEMmem80dec [[gnu::used]] = FBLD;

extern "C" constexpr auto ISEL_FILD_ST0_MEMmem16int [[gnu::used]] = FILD<M16>;
extern "C" constexpr auto ISEL_FILD_ST0_MEMmem32int [[gnu::used]] = FILD<M32>;
extern "C" constexpr auto ISEL_FILD_ST0_MEMm64int [[gnu::used]] = FILD<M64>;

extern "C" constexpr auto ISEL_FLD_ST0_MEMmem32real [[gnu::used]] =
FLDmem<MF32>;
extern "C" constexpr auto ISEL_FLD_ST0_X87 [[gnu::used]] = FLDfromstack;
extern "C" constexpr auto ISEL_FLD_ST0_MEMm64real [[gnu::used]] = FLDmem<MF64>;
extern "C" constexpr auto ISEL_FLD_ST0_MEMmem80real [[gnu::used]] =
FLDmem<MF80>;

extern "C" constexpr auto ISEL_FLDLN2 [[gnu::used]] = DoFLDLN2;
extern "C" constexpr auto ISEL_FLD1 [[gnu::used]] = DoFLD1;
extern "C" constexpr auto ISEL_FLDZ [[gnu::used]] = DoFLDZ;
extern "C" constexpr auto ISEL_FLDLG2 [[gnu::used]] = DoFLDLG2;
extern "C" constexpr auto ISEL_FLDL2T [[gnu::used]] = DoFLDL2T;
extern "C" constexpr auto ISEL_FLDL2E [[gnu::used]] = DoFLDL2E;
extern "C" constexpr auto ISEL_FLDPI [[gnu::used]] = DoFLDPI;

extern "C" constexpr auto ISEL_FNOP [[gnu::used]] = FPU_NOP;
extern "C" constexpr auto ISEL_FWAIT [[gnu::used]] = DoFWAIT;
extern "C" constexpr auto ISEL_FNCLEX [[gnu::used]] = DoFNCLEX;
extern "C" constexpr auto ISEL_FABS [[gnu::used]] = DoFABS;
extern "C" constexpr auto ISEL_FCHS [[gnu::used]] = DoFCHS;
extern "C" constexpr auto ISEL_FCOS [[gnu::used]] = DoFCOS;
extern "C" constexpr auto ISEL_FSIN [[gnu::used]] = DoFSIN;
extern "C" constexpr auto ISEL_FPTAN [[gnu::used]] = DoFPTAN;
extern "C" constexpr auto ISEL_FPATAN [[gnu::used]] = DoFPATAN;
extern "C" constexpr auto ISEL_FSQRT [[gnu::used]] = DoFSQRT;
extern "C" constexpr auto ISEL_FSINCOS [[gnu::used]] = DoFSINCOS;
extern "C" constexpr auto ISEL_FSCALE [[gnu::used]] = DoFSCALE;
extern "C" constexpr auto ISEL_F2XM1 [[gnu::used]] = DoF2XM1;
extern "C" constexpr auto ISEL_FPREM [[gnu::used]] = DoFPREM;
extern "C" constexpr auto ISEL_FPREM1 [[gnu::used]] = DoFPREM1;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUB(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FSub80, _Read(memory, src1),
Float80(_Read(memory, src2)))),
"Bad write!");
memory = _Write(memory, dst,
(CheckedFloatBinOp(state, FSub80, _Read(memory, src1),
Float80(_Read(memory, src2)))));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUBmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FSUB(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUBP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
memory = FSUB<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISUB(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FSub80, _Read(memory, src1),
Float80(Signed(_Read(memory, src2))))),
"Bad write!");
memory = _Write(memory, dst,
(CheckedFloatBinOp(state, FSub80, _Read(memory, src1),
Float80(Signed(_Read(memory, src2))))));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUBR(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FSub80,
Float80(_Read(memory, src2)),
_Read(memory, src1))),
"Bad write!");
memory =
_Write(memory, dst,
(CheckedFloatBinOp(state, FSub80, Float80(_Read(memory, src2)),
_Read(memory, src1))));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUBRmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FSUBR(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSUBRP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
memory = FSUBR<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISUBR(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(
state, FSub80, Float80(Signed(_Read(memory, src2))),
_Read(memory, src1))),
"Bad write!");
memory = _Write(
memory, dst,
(CheckedFloatBinOp(state, FSub80, Float80(Signed(_Read(memory, src2))),
_Read(memory, src1))));
} while (false);
return memory;
}
} // namespace

extern "C" constexpr auto ISEL_FSUB_ST0_MEMmem32real [[gnu::used]] =
FSUBmem<MF32>;
extern "C" constexpr auto ISEL_FSUB_ST0_MEMm64real [[gnu::used]] =
FSUBmem<MF64>;
extern "C" constexpr auto ISEL_FSUB_ST0_X87 [[gnu::used]] = FSUB<RF80W>;
extern "C" constexpr auto ISEL_FSUB_X87_ST0 [[gnu::used]] = FSUB<RF80W>;
extern "C" constexpr auto ISEL_FSUBP_X87_ST0 [[gnu::used]] = FSUBP<RF80W>;

extern "C" constexpr auto ISEL_FSUBR_ST0_MEMmem32real [[gnu::used]] =
FSUBRmem<MF32>;
extern "C" constexpr auto ISEL_FSUBR_ST0_MEMm64real [[gnu::used]] =
FSUBRmem<MF64>;
extern "C" constexpr auto ISEL_FSUBR_ST0_X87 [[gnu::used]] = FSUBR<RF80W>;
extern "C" constexpr auto ISEL_FSUBR_X87_ST0 [[gnu::used]] = FSUBR<RF80W>;
extern "C" constexpr auto ISEL_FSUBRP_X87_ST0 [[gnu::used]] = FSUBRP<RF80W>;

extern "C" constexpr auto ISEL_FISUB_ST0_MEMmem32int [[gnu::used]] = FISUB<M32>;
extern "C" constexpr auto ISEL_FISUB_ST0_MEMmem16int [[gnu::used]] = FISUB<M16>;
extern "C" constexpr auto ISEL_FISUBR_ST0_MEMmem32int [[gnu::used]] =
FISUBR<M32>;
extern "C" constexpr auto ISEL_FISUBR_ST0_MEMmem16int [[gnu::used]] =
FISUBR<M16>;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FADD(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FAdd80, _Read(memory, src1),
Float80(_Read(memory, src2)))),
"Bad write!");
memory = _Write(memory, dst,
(CheckedFloatBinOp(state, FAdd80, _Read(memory, src1),
Float80(_Read(memory, src2)))));
} while (false);

state.sw.c0 = __remill_undefined_8();
state.sw.c2 = __remill_undefined_8();
state.sw.c3 = __remill_undefined_8();
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FADDmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FADD(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FADDP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
memory = FADD<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FIADD(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
auto res = CheckedFloatBinOp(state, FAdd80, Float80(_Read(memory, src1)),
Float80(Signed(_Read(memory, src2))));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Float80(res)),
"Bad write!");
memory = _Write(memory, dst, (Float80(res)));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FADD_ST0_MEMmem32real [[gnu::used]] =
FADDmem<MF32>;
extern "C" constexpr auto ISEL_FADD_ST0_X87 [[gnu::used]] = FADD<RF80W>;
extern "C" constexpr auto ISEL_FADD_ST0_MEMm64real [[gnu::used]] =
FADDmem<MF64>;
extern "C" constexpr auto ISEL_FADD_X87_ST0 [[gnu::used]] = FADD<RF80W>;
extern "C" constexpr auto ISEL_FADDP_X87_ST0 [[gnu::used]] = FADDP<RF80W>;
extern "C" constexpr auto ISEL_FIADD_ST0_MEMmem32int [[gnu::used]] = FIADD<M32>;
extern "C" constexpr auto ISEL_FIADD_ST0_MEMmem16int [[gnu::used]] = FIADD<M16>;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FMUL(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FMul80, _Read(memory, src1),
Float80(_Read(memory, src2)))),
"Bad write!");
memory = _Write(memory, dst,
(CheckedFloatBinOp(state, FMul80, _Read(memory, src1),
Float80(_Read(memory, src2)))));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FMULmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FMUL(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FMULP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
memory = FMUL<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FIMUL(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
auto res = CheckedFloatBinOp(state, FMul80, Float80(_Read(memory, src1)),
Float80(Signed(_Read(memory, src2))));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(res),
"Bad write!");
memory = _Write(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FMUL_ST0_MEMmem32real [[gnu::used]] =
FMULmem<MF32>;
extern "C" constexpr auto ISEL_FMUL_ST0_X87 [[gnu::used]] = FMUL<RF80W>;
extern "C" constexpr auto ISEL_FMUL_ST0_MEMm64real [[gnu::used]] =
FMULmem<MF64>;
extern "C" constexpr auto ISEL_FMUL_X87_ST0 [[gnu::used]] = FMUL<RF80W>;
extern "C" constexpr auto ISEL_FMULP_X87_ST0 [[gnu::used]] = FMULP<RF80W>;
extern "C" constexpr auto ISEL_FIMUL_ST0_MEMmem32int [[gnu::used]] = FIMUL<M32>;
extern "C" constexpr auto ISEL_FIMUL_ST0_MEMmem16int [[gnu::used]] = FIMUL<M16>;

namespace {

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIV(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(
sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(CheckedFloatBinOp(state, FDiv80, _Read(memory, src1),
Float80(_Read(memory, src2)))),
"Bad write!");
memory = _Write(memory, dst,
(CheckedFloatBinOp(state, FDiv80, _Read(memory, src1),
Float80(_Read(memory, src2)))));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIVmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FDIV(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIVP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
memory = FDIV<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FIDIV(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
auto res = CheckedFloatBinOp(state, FDiv80, Float80(_Read(memory, src1)),
Float80(Signed(_Read(memory, src2))));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(res),
"Bad write!");
memory = _Write(memory, dst, (res));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIVR(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto res = CheckedFloatBinOp(state, FDiv80, Float80(_Read(memory, src2)),
_Read(memory, src1));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(res),
"Bad write!");
memory = _Write(memory, dst, (res));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIVRmem(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FDIVR(memory, state, dst, src1, src2, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FDIVRP(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
memory = FDIVR<T>(memory, state, dst, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FIDIVR(Memory *memory, State &state, RF80W dst, RF80W src1, T src2, PC pc,
I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
auto res =
CheckedFloatBinOp(state, FDiv80, Float80(Signed(_Read(memory, src2))),
Float80(_Read(memory, src1)));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(res),
"Bad write!");
memory = _Write(memory, dst, (res));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FDIV_ST0_MEMmem32real [[gnu::used]] =
FDIVmem<MF32>;
extern "C" constexpr auto ISEL_FDIV_ST0_MEMm64real [[gnu::used]] =
FDIVmem<MF64>;
extern "C" constexpr auto ISEL_FDIV_ST0_X87 [[gnu::used]] = FDIV<RF80W>;
extern "C" constexpr auto ISEL_FDIV_X87_ST0 [[gnu::used]] = FDIV<RF80W>;
extern "C" constexpr auto ISEL_FDIVP_X87_ST0 [[gnu::used]] = FDIVP<RF80W>;

extern "C" constexpr auto ISEL_FDIVR_ST0_MEMmem32real [[gnu::used]] =
FDIVRmem<MF32>;
extern "C" constexpr auto ISEL_FDIVR_ST0_MEMm64real [[gnu::used]] =
FDIVRmem<MF64>;
extern "C" constexpr auto ISEL_FDIVR_ST0_X87 [[gnu::used]] = FDIVR<RF80W>;
extern "C" constexpr auto ISEL_FDIVR_X87_ST0 [[gnu::used]] = FDIVR<RF80W>;
extern "C" constexpr auto ISEL_FDIVRP_X87_ST0 [[gnu::used]] = FDIVRP<RF80W>;

extern "C" constexpr auto ISEL_FIDIV_ST0_MEMmem32int [[gnu::used]] = FIDIV<M32>;
extern "C" constexpr auto ISEL_FIDIV_ST0_MEMmem16int [[gnu::used]] = FIDIV<M16>;
extern "C" constexpr auto ISEL_FIDIVR_ST0_MEMmem32int [[gnu::used]] =
FIDIVR<M32>;
extern "C" constexpr auto ISEL_FIDIVR_ST0_MEMmem16int [[gnu::used]] =
FIDIVR<M16>;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FBSTP(Memory *memory, State &state, MBCD80W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
bcd80_t out_bcd = {};

auto read = _Read(memory, src);
auto rounded = FRoundUsingMode(read);
auto rounded_abs = FAbs(rounded);

constexpr native_float80_t max_bcd80_float = 1e18 - 65;
auto out_of_range = rounded_abs > max_bcd80_float;

if (out_of_range || IsNaN(read) || IsInfinite(read)) {
state.sw.ie = 1;
state.sw.pe = 0;
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return _WriteBCD80Indefinite(memory, dst);
}

if (rounded != read) {
state.sw.pe = 1;

if (read < rounded) {
state.sw.c1 = 1;
}
}

if (IsNegative(rounded)) {
out_bcd.is_negative = true;
}

auto casted = static_cast<uint64_t>(rounded_abs);

for (uint64_t i = 0; i < sizeof(out_bcd.digit_pairs); i++) {
out_bcd.digit_pairs[i].pair.lsd = static_cast<uint8_t>(casted % 10);
casted /= 10;
out_bcd.digit_pairs[i].pair.msd = static_cast<uint8_t>(casted % 10);
casted /= 10;
}

memory = _WriteBCD80(memory, dst, out_bcd);

(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FST(Memory *memory, State &state, T dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
typedef typename BaseType<T>::BT BT;
auto res = CheckedFloatUnaryOp(
state, [=](native_float80_t x) { return static_cast<BT>(x); },
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) == sizeof(res),
"Bad write!");
memory = _Write(memory, dst, (res));
} while (false);
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSTmem(Memory *memory, State &state, T dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
return FST(memory, state, dst, src, pc, fop);
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSTP(Memory *memory, State &state, T dst, RF80W src, PC pc, I16 fop) {
memory = FST<T>(memory, state, dst, src, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename T>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FSTPmem(Memory *memory, State &state, T dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
return FSTP(memory, state, dst, src, pc, fop);
}

template <typename C1, typename C2>
[[gnu::always_inline]] inline __attribute__((flatten)) static auto
ConvertToInt(Memory *&memory, State &state, C1 cast, C2 convert,
native_float80_t input) -> decltype(cast(input)) {
auto rounded = FRoundUsingMode80(input);
auto casted = CheckedFloatUnaryOp(state, cast, rounded);
auto converted = convert(rounded);
auto back = static_cast<native_float80_t>(converted);

if (!state.sw.ie && !state.sw.pe) {
if (converted != casted || IsInfinite(input) || IsNaN(input)) {
state.sw.ie = 1;
state.sw.pe = 0;
} else {
if (back != rounded) {
state.sw.ie = static_cast<uint8_t>(FAbs80(back) < FAbs80(input));
state.sw.pe = 1 - state.sw.ie;
} else {
state.sw.pe = static_cast<uint8_t>(rounded != input);
state.sw.ie = 0;
}
}
}

return converted;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTm16(Memory *memory, State &state, M16W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
auto res = ConvertToInt(memory, state, Int16<float80_t>, Float80ToInt16,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTm32(Memory *memory, State &state, M32W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto res = ConvertToInt(memory, state, Int32<float80_t>, Float80ToInt32,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTPm16(Memory *memory, State &state, M16W dst, RF80W src, PC pc, I16 fop) {
memory = FISTm16(memory, state, dst, src, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTPm32(Memory *memory, State &state, M32W dst, RF80W src, PC pc, I16 fop) {
memory = FISTm32(memory, state, dst, src, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTPm64(Memory *memory, State &state, M64W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
auto res = ConvertToInt(memory, state, Int64<float80_t>, Float80ToInt64,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFINCSTP(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFDECSTP(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
auto __x = state.st.elems[7].val;
state.st.elems[7].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[0].val;
state.st.elems[0].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 7) % 8);
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FBSTP_MEMmem80dec_ST0 [[gnu::used]] = FBSTP;
extern "C" constexpr auto ISEL_FSTP_MEMmem32real_ST0 [[gnu::used]] =
FSTPmem<MF32W>;
extern "C" constexpr auto ISEL_FSTP_MEMmem80real_ST0 [[gnu::used]] =
FSTPmem<MF80W>;
extern "C" constexpr auto ISEL_FSTP_MEMm64real_ST0 [[gnu::used]] =
FSTPmem<MF64W>;
extern "C" constexpr auto ISEL_FSTP_X87_ST0 [[gnu::used]] = FSTP<RF80W>;
extern "C" constexpr auto ISEL_FSTP_X87_ST0_DFD0 [[gnu::used]] = FSTP<RF80W>;
extern "C" constexpr auto ISEL_FSTP_X87_ST0_DFD1 [[gnu::used]] = FSTP<RF80W>;
extern "C" constexpr auto ISEL_FST_MEMmem32real_ST0 [[gnu::used]] =
FSTmem<MF32W>;
extern "C" constexpr auto ISEL_FST_MEMm64real_ST0 [[gnu::used]] = FSTmem<MF64W>;
extern "C" constexpr auto ISEL_FST_X87_ST0 [[gnu::used]] = FST<RF80W>;
extern "C" constexpr auto ISEL_FIST_MEMmem16int_ST0 [[gnu::used]] = FISTm16;
extern "C" constexpr auto ISEL_FIST_MEMmem32int_ST0 [[gnu::used]] = FISTm32;
extern "C" constexpr auto ISEL_FISTP_MEMmem16int_ST0 [[gnu::used]] = FISTPm16;
extern "C" constexpr auto ISEL_FISTP_MEMmem32int_ST0 [[gnu::used]] = FISTPm32;
extern "C" constexpr auto ISEL_FISTP_MEMm64int_ST0 [[gnu::used]] = FISTPm64;
extern "C" constexpr auto ISEL_FDECSTP [[gnu::used]] = DoFDECSTP;
extern "C" constexpr auto ISEL_FINCSTP [[gnu::used]] = DoFINCSTP;

template <typename C1, typename C2>
[[gnu::always_inline]] inline __attribute__((flatten)) static auto
TruncateToInt(Memory *&memory, State &state, C1 cast, C2 convert,
float80_t input) -> decltype(cast(input)) {
auto truncated = FTruncTowardZero80(input);
auto casted = CheckedFloatUnaryOp(state, cast, truncated);
auto converted = convert(truncated);
auto back = static_cast<float80_t>(converted);

if (!state.sw.ie && !state.sw.pe) {
if (converted != casted || IsInfinite(input) || IsNaN(input)) {
state.sw.ie = 1;
state.sw.pe = 0;
} else {
if (back != truncated) {
state.sw.ie = static_cast<uint8_t>(FAbs80(back) < FAbs80(input));
state.sw.pe = 1 - state.sw.ie;
} else {
state.sw.pe = static_cast<uint8_t>(truncated != input);
state.sw.ie = 0;
}
}
}

return converted;
}

namespace {
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTTPm16(Memory *memory, State &state, M16W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
auto res = TruncateToInt(memory, state, Int16<float80_t>, Float80ToInt16,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTTPm32(Memory *memory, State &state, M32W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
auto res = TruncateToInt(memory, state, Int32<float80_t>, Float80ToInt32,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FISTTPm64(Memory *memory, State &state, M64W dst, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
state.x87.fxsave64.dp = AddressOf(dst);
} while (false);
auto res = TruncateToInt(memory, state, Int64<float80_t>, Float80ToInt64,
_Read(memory, src));
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Unsigned(res)),
"Bad write!");
memory = _Write(memory, dst, (Unsigned(res)));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FISTTP_MEMmem16int_ST0 [[gnu::used]] = FISTTPm16;
extern "C" constexpr auto ISEL_FISTTP_MEMmem32int_ST0 [[gnu::used]] = FISTTPm32;
extern "C" constexpr auto ISEL_FISTTP_MEMm64int_ST0 [[gnu::used]] = FISTTPm64;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FXCH(Memory *memory, State &state, RF80W dst1, RF80W src1, RF80W dst2,
RF80W src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, src1);
auto sti = _Read(memory, src2);
do {
static_assert(sizeof(typename BaseType<decltype(dst1)>::BT) == sizeof(sti),
"Bad write!");
memory = _Write(memory, dst1, (sti));
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst2)>::BT) == sizeof(st0),
"Bad write!");
memory = _Write(memory, dst2, (st0));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FXCH_ST0_X87 [[gnu::used]] = FXCH;
extern "C" constexpr auto ISEL_FXCH_ST0_X87_DFC1 [[gnu::used]] = FXCH;
extern "C" constexpr auto ISEL_FXCH_ST0_X87_DDC1 [[gnu::used]] = FXCH;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFXAM(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 =
static_cast<native_float80_t>(_Read(memory, state.st.elems[0].val));

uint8_t sign = __builtin_signbit(st0) == 0 ? 0_u8 : 1_u8;
auto c = __builtin_fpclassify(0, 1, 4, 3,

2, st0);
switch (c) {
case 0:
state.sw.c0 = 1;
state.sw.c1 = 0;
state.sw.c2 = 0;
state.sw.c3 = 0;
break;

case 1:
state.sw.c0 = 1;
state.sw.c1 = 0;
state.sw.c2 = 1;
state.sw.c3 = 0;
break;

case 2:
state.sw.c0 = 0;
state.sw.c1 = 0;
state.sw.c2 = 0;
state.sw.c3 = 1;
break;

case 3:
state.sw.c0 = 0;
state.sw.c1 = sign;
state.sw.c2 = 1;
state.sw.c3 = 1;
break;

case 4:
state.sw.c0 = 0;
state.sw.c1 = sign;
state.sw.c2 = 1;
state.sw.c3 = 0;
break;

default:
state.sw.c0 = 0;
state.sw.c1 = 0;
state.sw.c2 = 0;
state.sw.c3 = 0;
break;
}
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
OrderedCompare(Memory *&memory, State &state, native_float80_t src1,
native_float80_t src2) -> void {
state.sw.de |= IsDenormal(src1) | IsDenormal(src2);
state.sw.ie = 0;

if (__builtin_isunordered(src1, src2)) {
state.sw.c0 = 1;
state.sw.c2 = 1;
state.sw.c3 = 1;
state.sw.ie = 1;
} else if (__builtin_isless(src1, src2)) {
state.sw.c0 = 1;
state.sw.c2 = 0;
state.sw.c3 = 0;

} else if (__builtin_isgreater(src1, src2)) {
state.sw.c0 = 0;
state.sw.c2 = 0;
state.sw.c3 = 0;

} else {
state.sw.c0 = 0;
state.sw.c2 = 0;
state.sw.c3 = 1;
}
}

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
UnorderedCompare(Memory *&memory, State &state, native_float80_t src1,
native_float80_t src2) -> void {
state.sw.de |= IsDenormal(src1) | IsDenormal(src2);
state.sw.ie = 0;

if (__builtin_isunordered(src1, src2)) {
state.sw.c0 = 1;
state.sw.c2 = 1;
state.sw.c3 = 1;
state.sw.ie = IsSignalingNaN(src1) | IsSignalingNaN(src1);
} else if (__builtin_isless(src1, src2)) {
state.sw.c0 = 1;
state.sw.c2 = 0;
state.sw.c3 = 0;

} else if (__builtin_isgreater(src1, src2)) {
state.sw.c0 = 0;
state.sw.c2 = 0;
state.sw.c3 = 0;

} else {
state.sw.c0 = 0;
state.sw.c2 = 0;
state.sw.c3 = 1;
}
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFTST(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
state.sw.c1 = 0;

OrderedCompare(memory, state, st0, 0.0);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOM(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, src1);
auto sti = _Read(memory, src2);

UnorderedCompare(memory, state, st0, sti);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOM(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, src1);
auto sti = _Read(memory, src2);

OrderedCompare(memory, state, st0, sti);
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOMmem(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FUCOM(memory, state, src1, src2, pc, fop);
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOMmem(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FCOM(memory, state, src1, src2, pc, fop);
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOMP(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
memory = FUCOM<S2>(memory, state, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOMP(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
memory = FCOM<S2>(memory, state, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOMPmem(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FUCOMP(memory, state, src1, src2, pc, fop);
}

template <typename S2>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOMPmem(Memory *memory, State &state, RF80W src1, S2 src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.dp = AddressOf(src2);
} while (false);
return FCOMP(memory, state, src1, src2, pc, fop);
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFUCOMPP(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
RF80W st0 = {&state.st.elems[0].val};
RF80W st1 = {&state.st.elems[1].val};
memory = FUCOM<RF80W>(memory, state, st0, st1, pc, fop);

(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFCOMPP(Memory *memory, State &state, PC pc, I16 fop) {
RF80W st0 = {&state.st.elems[0].val};
RF80W st1 = {&state.st.elems[1].val};
memory = FCOM<RF80W>(memory, state, st0, st1, pc, fop);

(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
UnorderedCompareEflags(Memory *&memory, State &state, native_float80_t src1,
native_float80_t src2) -> void {
state.sw.de |= IsDenormal(src1) | IsDenormal(src2);
state.sw.ie = 0;

if (__builtin_isunordered(src1, src2)) {
state.aflag.cf = 1;
state.aflag.pf = 1;
state.aflag.zf = 1;
state.sw.ie = IsSignalingNaN(src1) | IsSignalingNaN(src1);

} else if (__builtin_isless(src1, src2)) {
state.aflag.cf = 1;
state.aflag.pf = 0;
state.aflag.zf = 0;

} else if (__builtin_isgreater(src1, src2)) {
state.aflag.cf = 0;
state.aflag.pf = 0;
state.aflag.zf = 0;

} else {
state.aflag.cf = 0;
state.aflag.pf = 0;
state.aflag.zf = 1;
}
}

[[gnu::always_inline]] inline __attribute__((flatten)) static auto
OrderedCompareEflags(Memory *&memory, State &state, native_float80_t src1,
native_float80_t src2) -> void {
state.sw.de |= IsDenormal(src1) | IsDenormal(src2);
state.sw.ie = 0;

if (__builtin_isunordered(src1, src2)) {
state.aflag.cf = 1;
state.aflag.pf = 1;
state.aflag.zf = 1;
state.sw.ie = 1;

} else if (__builtin_isless(src1, src2)) {
state.aflag.cf = 1;
state.aflag.pf = 0;
state.aflag.zf = 0;

} else if (__builtin_isgreater(src1, src2)) {
state.aflag.cf = 0;
state.aflag.pf = 0;
state.aflag.zf = 0;

} else {
state.aflag.cf = 0;
state.aflag.pf = 0;
state.aflag.zf = 1;
}
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOMI(Memory *memory, State &state, RF80W src1, RF80W src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, src1);
auto sti = _Read(memory, src2);
state.sw.c1 = 0;
state.aflag.of = 0;
state.aflag.sf = 0;
state.aflag.af = 0;
UnorderedCompareEflags(memory, state, st0, sti);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FUCOMIP(Memory *memory, State &state, RF80W src1, RF80W src2, PC pc, I16 fop) {
memory = FUCOMI(memory, state, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOMI(Memory *memory, State &state, RF80W src1, RF80W src2, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, src1);
auto sti = _Read(memory, src2);
state.sw.c1 = 0;
state.aflag.of = 0;
state.aflag.sf = 0;
state.aflag.af = 0;
OrderedCompareEflags(memory, state, st0, sti);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCOMIP(Memory *memory, State &state, RF80W src1, RF80W src2, PC pc, I16 fop) {
memory = FCOMI(memory, state, src1, src2, pc, fop);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FXAM [[gnu::used]] = DoFXAM;
extern "C" constexpr auto ISEL_FTST [[gnu::used]] = DoFTST;

extern "C" constexpr auto ISEL_FUCOM_ST0_X87 [[gnu::used]] = FUCOM<RF80W>;
extern "C" constexpr auto ISEL_FUCOMP_ST0_X87 [[gnu::used]] = FUCOMP<RF80W>;
extern "C" constexpr auto ISEL_FUCOMPP [[gnu::used]] = DoFUCOMPP;

extern "C" constexpr auto ISEL_FUCOMI_ST0_X87 [[gnu::used]] = FUCOMI;
extern "C" constexpr auto ISEL_FUCOMIP_ST0_X87 [[gnu::used]] = FUCOMIP;

extern "C" constexpr auto ISEL_FCOMI_ST0_X87 [[gnu::used]] = FCOMI;
extern "C" constexpr auto ISEL_FCOMIP_ST0_X87 [[gnu::used]] = FCOMIP;

extern "C" constexpr auto ISEL_FCOM_ST0_X87 [[gnu::used]] = FCOM<RF80W>;
extern "C" constexpr auto ISEL_FCOM_ST0_X87_DCD0 [[gnu::used]] = FCOM<RF80W>;
extern "C" constexpr auto ISEL_FCOM_ST0_MEMmem32real [[gnu::used]] =
FCOMmem<MF32>;
extern "C" constexpr auto ISEL_FCOM_ST0_MEMm64real [[gnu::used]] =
FCOMmem<MF64>;

extern "C" constexpr auto ISEL_FCOMP_ST0_X87 [[gnu::used]] = FCOMP<RF80W>;
extern "C" constexpr auto ISEL_FCOMP_ST0_MEMmem32real [[gnu::used]] =
FCOMPmem<MF32>;
extern "C" constexpr auto ISEL_FCOMP_ST0_MEMm64real [[gnu::used]] =
FCOMPmem<MF64>;
extern "C" constexpr auto ISEL_FCOMP_ST0_X87_DCD1 [[gnu::used]] = FCOMP<RF80W>;
extern "C" constexpr auto ISEL_FCOMP_ST0_X87_DED0 [[gnu::used]] = FCOMP<RF80W>;
extern "C" constexpr auto ISEL_FCOMPP [[gnu::used]] = DoFCOMPP;

namespace {

template <typename D>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FNSTSW(Memory *memory, State &state, D dst) {
auto &sw = state.x87.fxsave64.swd;
sw.c0 = state.sw.c0;
sw.c1 = state.sw.c1;
sw.c2 = state.sw.c2;
sw.c3 = state.sw.c3;
sw.pe = state.sw.pe;
sw.ue = state.sw.ue;
sw.oe = state.sw.oe;
sw.ze = state.sw.ze;
sw.de = state.sw.de;
sw.ie = state.sw.ie;
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(sw.flat),
"Bad write!");
memory = _Write(memory, dst, (sw.flat));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FNSTCW(Memory *memory, State &state, M16W dst) {
auto &cw = state.x87.fxsave64.cwd;
cw.pc = kPrecisionSingle;

switch (fegetround()) {
default:
case 0:
cw.rc = kFPURoundToNearestEven;
break;
case 0x400:
cw.rc = kFPURoundDownNegInf;
break;
case 0x800:
cw.rc = kFPURoundUpInf;
break;
case 0xc00:
cw.rc = kFPURoundToZero;
break;
}
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(cw.flat),
"Bad write!");
memory = _Write(memory, dst, (cw.flat));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FLDCW(Memory *memory, State &state, M16 cwd) {
auto &cw = state.x87.fxsave64.cwd;
cw.flat = _Read(memory, cwd);
cw.pc = kPrecisionSingle;
int rounding_mode = 0;
switch (cw.rc) {
case kFPURoundToNearestEven:
rounding_mode = 0;
break;

case kFPURoundDownNegInf:
rounding_mode = 0x400;
break;

case kFPURoundUpInf:
rounding_mode = 0x800;
break;

case kFPURoundToZero:
rounding_mode = 0xc00;
break;
}
fesetround(rounding_mode);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FNSTSW_MEMmem16 [[gnu::used]] = FNSTSW<M16W>;
extern "C" constexpr auto ISEL_FNSTSW_AX [[gnu::used]] = FNSTSW<R16W>;
extern "C" constexpr auto ISEL_FNSTCW_MEMmem16 [[gnu::used]] = FNSTCW;
extern "C" constexpr auto ISEL_FLDCW_MEMmem16 [[gnu::used]] = FLDCW;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFRNDINT(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto rounded = FRoundUsingMode(st0);
state.sw.ie |= IsSignalingNaN(st0);
state.sw.de |= IsDenormal(st0);
if (!IsNaN(rounded)) {
state.sw.pe = st0 != rounded;
}

do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[0].val)>::BT) ==
sizeof(rounded),
"Bad write!");
memory = _Write(memory, state.st.elems[0].val, (rounded));
} while (false);
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFYL2X(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto st1 = _Read(memory, state.st.elems[1].val);
state.sw.ze = IsZero(st0);
state.sw.de = IsDenormal(st0) | IsDenormal(st1);
state.sw.ie = (IsSignalingNaN(st0) || IsSignalingNaN(st1)) ||
(IsNegative(st0) && !IsInfinite(st0) && !state.sw.ze);
auto res = FMul(st1, Log2(st0));
state.sw.pe = IsImprecise(res);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[1].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[1].val, (res));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFYL2XP1(Memory *memory, State &state, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
auto st0 = _Read(memory, state.st.elems[0].val);
auto st1 = _Read(memory, state.st.elems[1].val);
state.sw.ze = IsZero(st0);
state.sw.de = IsDenormal(st0) | IsDenormal(st1);
state.sw.ie = IsSignalingNaN(st0) || IsSignalingNaN(st1);
auto res = FMul(st1, Log2(FAdd(st0, Float80(1.0))));
state.sw.pe = IsImprecise(res);
do {
static_assert(
sizeof(typename BaseType<decltype(state.st.elems[1].val)>::BT) ==
sizeof(res),
"Bad write!");
memory = _Write(memory, state.st.elems[1].val, (res));
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FFREE(Memory *memory, State &state, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
(void)src;
return memory;
}

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FFREEP(Memory *memory, State &state, RF80W src, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
(void)({
auto __x = state.st.elems[0].val;
state.st.elems[0].val = state.st.elems[1].val;
state.st.elems[1].val = state.st.elems[2].val;
state.st.elems[2].val = state.st.elems[3].val;
state.st.elems[3].val = state.st.elems[4].val;
state.st.elems[4].val = state.st.elems[5].val;
state.st.elems[5].val = state.st.elems[6].val;
state.st.elems[6].val = state.st.elems[7].val;
state.st.elems[7].val = __x;
state.x87.fxsave64.swd.top =
static_cast<uint16_t>((state.x87.fxsave64.swd.top + 9) % 8);
__x;
});
(void)src;
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FRNDINT [[gnu::used]] = DoFRNDINT;
extern "C" constexpr auto ISEL_FYL2X [[gnu::used]] = DoFYL2X;
extern "C" constexpr auto ISEL_FYL2XP1 [[gnu::used]] = DoFYL2XP1;

extern "C" constexpr auto ISEL_FFREE_X87 [[gnu::used]] = FFREE;
extern "C" constexpr auto ISEL_FFREEP_X87 [[gnu::used]] = FFREEP;

namespace {

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVNP(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(BNot(state.aflag.pf), _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(memory, dst,
(Select(BNot(state.aflag.pf), _Read(memory, src1),
_Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVNZ(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(BNot(state.aflag.zf), _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(memory, dst,
(Select(BNot(state.aflag.zf), _Read(memory, src1),
_Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVNB(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(BNot(state.aflag.cf), _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(memory, dst,
(Select(BNot(state.aflag.cf), _Read(memory, src1),
_Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVNBE(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(BNot(BOr(state.aflag.cf, state.aflag.zf)),
_Read(memory, src1), _Read(memory, dst))),
"Bad write!");
memory = _Write(memory, dst,
(Select(BNot(BOr(state.aflag.cf, state.aflag.zf)),
_Read(memory, src1), _Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVBE(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(BOr(state.aflag.cf, state.aflag.zf),
_Read(memory, src1), _Read(memory, dst))),
"Bad write!");
memory = _Write(memory, dst,
(Select(BOr(state.aflag.cf, state.aflag.zf),
_Read(memory, src1), _Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVP(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(state.aflag.pf, _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(
memory, dst,
(Select(state.aflag.pf, _Read(memory, src1), _Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVZ(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(state.aflag.zf, _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(
memory, dst,
(Select(state.aflag.zf, _Read(memory, src1), _Read(memory, dst))));
} while (false);
return memory;
}

template <typename D, typename S1>
[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
FCMOVB(Memory *memory, State &state, D dst, S1 src1, PC pc, I16 fop) {
do {
state.x87.fxsave64.fop = _Read(memory, fop);
state.x87.fxsave64.ip = _Read(memory, pc);
} while (false);
do {
static_assert(sizeof(typename BaseType<decltype(dst)>::BT) ==
sizeof(Select(state.aflag.cf, _Read(memory, src1),
_Read(memory, dst))),
"Bad write!");
memory = _Write(
memory, dst,
(Select(state.aflag.cf, _Read(memory, src1), _Read(memory, dst))));
} while (false);
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FCMOVNU_ST0_X87 [[gnu::used]] =
FCMOVNP<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVNB_ST0_X87 [[gnu::used]] =
FCMOVNB<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVNE_ST0_X87 [[gnu::used]] =
FCMOVNZ<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVBE_ST0_X87 [[gnu::used]] =
FCMOVBE<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVNBE_ST0_X87 [[gnu::used]] =
FCMOVNBE<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVU_ST0_X87 [[gnu::used]] =
FCMOVP<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVE_ST0_X87 [[gnu::used]] =
FCMOVZ<RF80W, RF80W>;
extern "C" constexpr auto ISEL_FCMOVB_ST0_X87 [[gnu::used]] =
FCMOVB<RF80W, RF80W>;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoFNINIT(Memory *memory, State &state) {

state.x87.fsave.cwd.flat = 0x037F;
state.x87.fsave.swd.flat = 0x0000;
state.x87.fsave.ftw.flat = 0x0000;
state.x87.fsave.dp = 0x0;
state.x87.fsave.ip = 0x0;
state.x87.fsave.fop = 0x0;
state.x87.fsave.ds.flat = 0x0000;
state.x87.fsave.cs.flat = 0x0000;

std::feclearexcept((0x20 | 0x04 | 0x10 | 0x08 | 0x01));

std::fesetround(0);

return memory;
}

} // namespace

extern "C" constexpr auto ISEL_FNINIT [[gnu::used]] = DoFNINIT;

namespace {

[[gnu::always_inline]] inline __attribute__((flatten)) static Memory *
DoXGETBV(Memory *memory, State &state, PC next_pc) {
switch (_Read(memory, state.gpr.rcx.dword)) {

case 0:
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rax.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rax.qword)>(state.xcr0.eax)),
"Bad write!");
memory =
_Write(memory, state.gpr.rax.qword,
(ZExtTo<decltype(state.gpr.rax.qword)>(state.xcr0.eax)));
} while (false);
} while (false);
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rdx.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rdx.qword)>(state.xcr0.edx)),
"Bad write!");
memory =
_Write(memory, state.gpr.rdx.qword,
(ZExtTo<decltype(state.gpr.rdx.qword)>(state.xcr0.edx)));
} while (false);
} while (false);
break;

case 1: {
XCR0 xcr0 = {};
xcr0.x87_fpu_mmx = 1;
xcr0.xmm = 1;
xcr0.ymm = 1;
xcr0.opmask = 1;
xcr0.zmm_hi256 = 1;
xcr0.hi16_zmm = 1;
break;
}

default:
do {
do {
static_assert(
sizeof(typename BaseType<decltype(state.gpr.rip.qword)>::BT) ==
sizeof(ZExtTo<decltype(state.gpr.rip.qword)>(
_Read(memory, next_pc))),
"Bad write!");
memory = _Write(
memory, state.gpr.rip.qword,
(ZExtTo<decltype(state.gpr.rip.qword)>(_Read(memory, next_pc))));
} while (false);
} while (false);
return __remill_error(state, _Read(memory, state.gpr.rip.qword), memory);
}
return memory;
}

} // namespace

extern "C" constexpr auto ISEL_XGETBV [[gnu::used]] = DoXGETBV;
